// ../../node_modules/@preact/signals-core/dist/signals-core.mjs
var i = Symbol.for("preact-signals");
function t() {
  if (r > 1) {
    r--;
    return;
  }
  let i3, t2 = false;
  while (void 0 !== s) {
    let o = s;
    s = void 0;
    f++;
    while (void 0 !== o) {
      const n2 = o.o;
      o.o = void 0;
      o.f &= -3;
      if (!(8 & o.f) && v(o))
        try {
          o.c();
        } catch (o2) {
          if (!t2) {
            i3 = o2;
            t2 = true;
          }
        }
      o = n2;
    }
  }
  f = 0;
  r--;
  if (t2)
    throw i3;
}
var n;
var s;
function h(i3) {
  const t2 = n;
  n = void 0;
  try {
    return i3();
  } finally {
    n = t2;
  }
}
var r = 0;
var f = 0;
var e = 0;
function c(i3) {
  if (void 0 === n)
    return;
  let t2 = i3.n;
  if (void 0 === t2 || t2.t !== n) {
    t2 = { i: 0, S: i3, p: n.s, n: void 0, t: n, e: void 0, x: void 0, r: t2 };
    if (void 0 !== n.s)
      n.s.n = t2;
    n.s = t2;
    i3.n = t2;
    if (32 & n.f)
      i3.S(t2);
    return t2;
  } else if (-1 === t2.i) {
    t2.i = 0;
    if (void 0 !== t2.n) {
      t2.n.p = t2.p;
      if (void 0 !== t2.p)
        t2.p.n = t2.n;
      t2.p = n.s;
      t2.n = void 0;
      n.s.n = t2;
      n.s = t2;
    }
    return t2;
  }
}
function u(i3, t2) {
  this.v = i3;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i3) {
  const t2 = this.t;
  if (t2 !== i3 && void 0 === i3.e) {
    i3.x = t2;
    this.t = i3;
    if (void 0 !== t2)
      t2.e = i3;
    else
      h(() => {
        var i4;
        null == (i4 = this.W) || i4.call(this);
      });
  }
};
u.prototype.U = function(i3) {
  if (void 0 !== this.t) {
    const t2 = i3.e, o = i3.x;
    if (void 0 !== t2) {
      t2.x = o;
      i3.e = void 0;
    }
    if (void 0 !== o) {
      o.e = t2;
      i3.x = void 0;
    }
    if (i3 === this.t) {
      this.t = o;
      if (void 0 === o)
        h(() => {
          var i4;
          null == (i4 = this.Z) || i4.call(this);
        });
    }
  }
};
u.prototype.subscribe = function(i3) {
  return E(() => {
    const t2 = this.value, o = n;
    n = void 0;
    try {
      i3(t2);
    } finally {
      n = o;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  const i3 = n;
  n = void 0;
  try {
    return this.value;
  } finally {
    n = i3;
  }
};
Object.defineProperty(u.prototype, "value", { get() {
  const i3 = c(this);
  if (void 0 !== i3)
    i3.i = this.i;
  return this.v;
}, set(i3) {
  if (i3 !== this.v) {
    if (f > 100)
      throw new Error("Cycle detected");
    this.v = i3;
    this.i++;
    e++;
    r++;
    try {
      for (let i4 = this.t; void 0 !== i4; i4 = i4.x)
        i4.t.N();
    } finally {
      t();
    }
  }
} });
function d(i3, t2) {
  return new u(i3, t2);
}
function v(i3) {
  for (let t2 = i3.s; void 0 !== t2; t2 = t2.n)
    if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i)
      return true;
  return false;
}
function l(i3) {
  for (let t2 = i3.s; void 0 !== t2; t2 = t2.n) {
    const o = t2.S.n;
    if (void 0 !== o)
      t2.r = o;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i3.s = t2;
      break;
    }
  }
}
function y(i3) {
  let t2, o = i3.s;
  while (void 0 !== o) {
    const i4 = o.p;
    if (-1 === o.i) {
      o.S.U(o);
      if (void 0 !== i4)
        i4.n = o.n;
      if (void 0 !== o.n)
        o.n.p = i4;
    } else
      t2 = o;
    o.S.n = o.r;
    if (void 0 !== o.r)
      o.r = void 0;
    o = i4;
  }
  i3.s = t2;
}
function a(i3, t2) {
  u.call(this, void 0);
  this.x = i3;
  this.s = void 0;
  this.g = e - 1;
  this.f = 4;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
}
a.prototype = new u();
a.prototype.h = function() {
  this.f &= -3;
  if (1 & this.f)
    return false;
  if (32 == (36 & this.f))
    return true;
  this.f &= -5;
  if (this.g === e)
    return true;
  this.g = e;
  this.f |= 1;
  if (this.i > 0 && !v(this)) {
    this.f &= -2;
    return true;
  }
  const i3 = n;
  try {
    l(this);
    n = this;
    const i4 = this.x();
    if (16 & this.f || this.v !== i4 || 0 === this.i) {
      this.v = i4;
      this.f &= -17;
      this.i++;
    }
  } catch (i4) {
    this.v = i4;
    this.f |= 16;
    this.i++;
  }
  n = i3;
  y(this);
  this.f &= -2;
  return true;
};
a.prototype.S = function(i3) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (let i4 = this.s; void 0 !== i4; i4 = i4.n)
      i4.S.S(i4);
  }
  u.prototype.S.call(this, i3);
};
a.prototype.U = function(i3) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i3);
    if (void 0 === this.t) {
      this.f &= -33;
      for (let i4 = this.s; void 0 !== i4; i4 = i4.n)
        i4.S.U(i4);
    }
  }
};
a.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (let i3 = this.t; void 0 !== i3; i3 = i3.x)
      i3.t.N();
  }
};
Object.defineProperty(a.prototype, "value", { get() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  const i3 = c(this);
  this.h();
  if (void 0 !== i3)
    i3.i = this.i;
  if (16 & this.f)
    throw this.v;
  return this.v;
} });
function w(i3, t2) {
  return new a(i3, t2);
}
function _(i3) {
  const o = i3.u;
  i3.u = void 0;
  if ("function" == typeof o) {
    r++;
    const s3 = n;
    n = void 0;
    try {
      o();
    } catch (t2) {
      i3.f &= -2;
      i3.f |= 8;
      b(i3);
      throw t2;
    } finally {
      n = s3;
      t();
    }
  }
}
function b(i3) {
  for (let t2 = i3.s; void 0 !== t2; t2 = t2.n)
    t2.S.U(t2);
  i3.x = void 0;
  i3.s = void 0;
  _(i3);
}
function g(i3) {
  if (n !== this)
    throw new Error("Out-of-order effect");
  y(this);
  n = i3;
  this.f &= -2;
  if (8 & this.f)
    b(this);
  t();
}
function p(i3) {
  this.x = i3;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
}
p.prototype.c = function() {
  const i3 = this.S();
  try {
    if (8 & this.f)
      return;
    if (void 0 === this.x)
      return;
    const t2 = this.x();
    if ("function" == typeof t2)
      this.u = t2;
  } finally {
    i3();
  }
};
p.prototype.S = function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  l(this);
  r++;
  const i3 = n;
  n = this;
  return g.bind(this, i3);
};
p.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = s;
    s = this;
  }
};
p.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f))
    b(this);
};
p.prototype.dispose = function() {
  this.d();
};
function E(i3) {
  const t2 = new p(i3);
  try {
    t2.c();
  } catch (i4) {
    t2.d();
    throw i4;
  }
  const o = t2.d.bind(t2);
  o[Symbol.dispose] = o;
  return o;
}

// ../../node_modules/@preact/signals-react/runtime/dist/runtime.mjs
import { version as i2, useRef as r2, useMemo as f2, useEffect as s2, useLayoutEffect as u2 } from "react";
import { useSyncExternalStore as c2 } from "use-sync-external-store/shim/index.js";
var [l2] = i2.split(".").map(Number);
var d2 = Symbol.for(l2 >= 19 ? "react.transitional.element" : "react.element");
var m = Symbol.dispose || Symbol.for("Symbol.dispose");
var b2;
function y2(t2, n2) {
  const e2 = n2.effect.S();
  b2 = n2;
  return g2.bind(n2, t2, e2);
}
function g2(t2, n2) {
  n2();
  b2 = t2;
}
var h2 = () => {
};
var v2 = { o: 0, effect: { s: void 0, c() {
}, S: () => h2, d() {
} }, subscribe: () => h2, getSnapshot: () => 0, S() {
}, f() {
}, [m]() {
} };
var _2 = Promise.prototype.then.bind(Promise.resolve());
var S;
function w2() {
  if (!S)
    S = _2(x);
}
function x() {
  var t2;
  S = void 0;
  null == (t2 = b2) || t2.f();
}
var j = "undefined" != typeof window ? u2 : s2;
function P(t2 = 0) {
  w2();
  const n2 = r2();
  if (null == n2.current)
    if ("undefined" == typeof window)
      n2.current = v2;
    else
      n2.current = function(t3) {
        let n3, e3, i3, r3 = 0, f3 = E(function() {
          n3 = this;
        });
        n3.c = function() {
          r3 = r3 + 1 | 0;
          if (i3)
            i3();
        };
        return { o: t3, effect: n3, subscribe(t4) {
          i3 = t4;
          return function() {
            r3 = r3 + 1 | 0;
            i3 = void 0;
            f3();
          };
        }, getSnapshot: () => r3, S() {
          if (null == b2) {
            e3 = y2(void 0, this);
            return;
          }
          const t4 = b2.o, n4 = this.o;
          if (0 == t4 && 0 == n4 || 0 == t4 && 1 == n4) {
            b2.f();
            e3 = y2(void 0, this);
          } else if (1 == t4 && 0 == n4 || 2 == t4 && 0 == n4)
            ;
          else
            e3 = y2(b2, this);
        }, f() {
          const t4 = e3;
          e3 = void 0;
          null == t4 || t4();
        }, [m]() {
          this.f();
        } };
      }(t2);
  const e2 = n2.current;
  c2(e2.subscribe, e2.getSnapshot, e2.getSnapshot);
  e2.S();
  if (0 === t2)
    j(x);
  return e2;
}
Object.defineProperties(u.prototype, { $$typeof: { configurable: true, value: d2 }, type: { configurable: true, value: function({ data: t2 }) {
  const n2 = P(1);
  try {
    return t2.value;
  } finally {
    n2.f();
  }
} }, props: { configurable: true, get() {
  return { data: this };
} }, ref: { configurable: true, value: null } });
function $(t2) {
  return P(t2);
}

// ../sdk-react-context/build/index.mjs
import { createContext } from "react";
if (!globalThis.WixReactContext) {
  globalThis.WixReactContext = createContext(void 0);
}
var WixContext = globalThis.WixReactContext;

// src/index.tsx
import React, {
  createContext as createContext2,
  useContext,
  useState
} from "react";

// ../services-definitions/build/index.js
function defineService(id) {
  return id;
}
function implementService(_3, factory) {
  return factory;
}
implementService.withConfig = function() {
  return function(_3, factory) {
    return factory;
  };
};

// src/core-services/provide-component/definition.ts
var ProvideComponentServiceDefinition = defineService("core:provide-component");

// ../services-definitions/build/core-services/signals/definition.js
var SignalsServiceDefinition = defineService("core:signals");

// ../services-manager/build/core-services/signals/service.js
var SignalsServiceFactory = implementService(SignalsServiceDefinition, () => {
  return {
    signal: (initialValue) => {
      const sig = d(initialValue);
      const signal = {
        get: () => sig.value,
        set: (newValue) => sig.value = newValue,
        peek: () => sig.peek()
      };
      return signal;
    },
    computed: (fn) => {
      const sig = w(fn);
      const signal = {
        get: () => sig.value,
        peek: () => sig.peek()
      };
      return signal;
    },
    effect: E
  };
});

// ../services-manager/build/services-manager.js
function createServicesManager(servicesBindings, parentServicesManager) {
  const coreRegisteredServices = createServicesMap().addService(SignalsServiceDefinition, SignalsServiceFactory);
  const bindingsByDefinition = new Map([
    ...servicesBindings ? servicesBindings.registeredServices : [],
    ...coreRegisteredServices.registeredServices
  ].map((service) => [service.definition.toString(), service]));
  const initializedServices = /* @__PURE__ */ new Map();
  const manager = {
    getService(definition) {
      if (!initializedServices.has(definition.toString())) {
        const service = bindingsByDefinition.get(definition.toString());
        if (!service) {
          if (parentServicesManager) {
            return parentServicesManager.getService(definition);
          }
          throw new Error(`Service ${definition} is not provided`);
        }
        initializedServices.set(definition.toString(), service.impl({
          config: service.config,
          getService: manager.getService
        }));
      }
      return initializedServices.get(definition.toString());
    },
    hasService(definition) {
      return bindingsByDefinition.has(definition.toString());
    },
    addService(definition, impl, config) {
      if (!manager.hasService(definition)) {
        bindingsByDefinition.set(definition.toString(), {
          definition,
          impl,
          config: config || {}
        });
        if (!initializedServices.has(definition.toString())) {
          initializedServices.set(definition.toString(), impl({
            config: config || {},
            getService: manager.getService
          }));
        }
      } else {
        throw new Error(`Service ${definition.toString()} is already provided`);
      }
    },
    addServices(servicesToAdd) {
      servicesToAdd.registeredServices.forEach(({ definition }) => {
        if (manager.hasService(definition)) {
          throw new Error(`Service ${definition.toString()} is already provided`);
        }
      });
      servicesToAdd.registeredServices.forEach(({ definition, impl, config }) => {
        bindingsByDefinition.set(definition.toString(), {
          definition,
          impl,
          config: config || {}
        });
      });
      servicesToAdd.registeredServices.forEach(({ definition, impl, config }) => {
        if (!initializedServices.has(definition.toString())) {
          initializedServices.set(definition.toString(), impl({
            config: config || {},
            getService: manager.getService
          }));
        }
      });
    }
  };
  bindingsByDefinition.forEach(({ definition, impl, config }) => {
    if (!initializedServices.has(definition.toString())) {
      initializedServices.set(definition, impl({
        config: config || {},
        getService: manager.getService
      }));
    }
  });
  return manager;
}
function createServicesMap(registeredServices = []) {
  return {
    registeredServices,
    addService(definition, impl, config) {
      return createServicesMap([
        ...registeredServices,
        { definition, impl, config }
      ]);
    }
  };
}

// src/index.tsx
function ServicesManagerProvider({
  servicesManager,
  children
}) {
  const getProvidedComponent = () => {
    const provideComponentService = servicesManager.hasService(
      ProvideComponentServiceDefinition
    ) ? servicesManager.getService(ProvideComponentServiceDefinition) : {
      getAllTopComponents: () => null,
      getAllBottomComponents: () => null
    };
    return {
      TopComponents: provideComponentService?.getAllTopComponents(),
      BottomComponents: provideComponentService?.getAllBottomComponents()
    };
  };
  const { TopComponents, BottomComponents } = getProvidedComponent();
  return /* @__PURE__ */ React.createElement(
    WixContext.Provider,
    {
      value: {
        getService: servicesManager.getService
      }
    },
    TopComponents && /* @__PURE__ */ React.createElement(TopComponents, null),
    children,
    BottomComponents && /* @__PURE__ */ React.createElement(BottomComponents, null)
  );
}
function useGetService() {
  const maybeContext = useContext(WixContext);
  if (!maybeContext) {
    throw new Error(
      "No ServiceManagerProvider found in the component tree, make sure to wrap your app with ServicesManagerProvider"
    );
  }
  return maybeContext.getService;
}
function useService(service) {
  const getService = useGetService();
  $();
  return getService(service);
}
function useServices(services) {
  const getService = useGetService();
  if (!getService) {
    throw new Error(
      "No ServiceManagerProvider found in the component tree, make sure to wrap your app with ServicesManagerProvider"
    );
  }
  return services.map((service) => getService(service));
}
var InternalServicesManagerContext = createContext2(void 0);
function WixServices(props) {
  const parentServicesManager = useContext(
    InternalServicesManagerContext
  );
  const [servicesManager] = useState(
    () => createServicesManager(props.servicesMap, parentServicesManager)
  );
  return /* @__PURE__ */ React.createElement(InternalServicesManagerContext.Provider, { value: servicesManager }, /* @__PURE__ */ React.createElement(ServicesManagerProvider, { servicesManager }, props.children));
}
export {
  ServicesManagerProvider,
  WixServices,
  useGetService,
  useService,
  useServices
};
