"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.ErrorHandlerV2 = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _ErrorAccessor = require("../state/ErrorAccessor");
var _reportGetResolvedErrorBi = require("./reportGetResolvedErrorBi");
var _fallbackMessage = require("../fallbackMessage");
class ErrorHandlerV2 {
  constructor(_errorHandler) {
    (0, _defineProperty2.default)(this, "errorHandler", void 0);
    (0, _defineProperty2.default)(this, "withErrorHandler", async (fn, errorCodesMap, options = {}) => {
      const {
        errorHandler
      } = this;
      const ops = {
        errorCodesMap: {
          validationError: errorCodesMap,
          statusCodeError: options.statusCodesOverrides,
          applicationError: Object.entries(errorCodesMap).reduce((acc, [key, value]) => {
            if (value) {
              acc[key] = (_, error) => value(error);
            }
            return acc;
          }, {}),
          serverError: options.serverErrorOverride
        }
      };
      const response = await errorHandler.withErrorHandler(fn, ops);
      if (typeof Response !== 'undefined' && response instanceof Response) {
        const errorAccessor = new _ErrorAccessor.ErrorAccessor({
          error: response
        });
        errorHandler._setErrorHandlerErrorCodesMap(errorAccessor, ops);
        const {
          errorHandlerState
        } = errorAccessor;
        if (!response.ok && errorHandlerState) {
          errorHandlerState.responseData = await response.json().catch(() => null);
        }
      }
      return response;
    });
    (0, _defineProperty2.default)(this, "getResolvedError", error => {
      const {
        errorHandler
      } = this;
      const {
        errorMonitor
      } = errorHandler;
      try {
        const errorAccessor = new _ErrorAccessor.ErrorAccessor({
          error
        });
        const {
          httpError,
          errorHandlerState
        } = errorAccessor;
        const errorResolution = errorHandler._resolveError(errorAccessor);
        const resolvedError = errorHandlerState == null ? void 0 : errorHandlerState.resolvedError;
        const message = (resolvedError == null ? void 0 : resolvedError.message) ?? _fallbackMessage.fallbackMessage;
        const action = resolvedError == null ? void 0 : resolvedError.action;
        const requestId = (resolvedError == null ? void 0 : resolvedError.requestId) ?? (httpError == null ? void 0 : httpError.requestId);
        (0, _reportGetResolvedErrorBi.reportGetResolvedErrorBi)(errorHandler, {
          message,
          action,
          errorAccessor,
          errorResolution
        });
        return {
          message,
          action,
          requestId,
          ...resolvedError
        };
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
        throw e;
      }
    });
    (0, _defineProperty2.default)(this, "showError", (error, props) => {
      this.errorHandler.showError(error, props);
    });
    (0, _defineProperty2.default)(this, "reportRetryAttempt", error => {
      this.errorHandler.reportRetryAttempt(error);
    });
    (0, _defineProperty2.default)(this, "handleError", (error, options) => {
      const {
        errorHandler
      } = this;
      if (typeof Response !== 'undefined' && error instanceof Response) {
        if (!error.ok) {
          errorHandler.handleError(error, options);
        }
      } else {
        errorHandler.handleError(error, options);
      }
    });
    this.errorHandler = _errorHandler;
  }
}
exports.ErrorHandlerV2 = ErrorHandlerV2;
//# sourceMappingURL=ErrorHandlerV2.js.map