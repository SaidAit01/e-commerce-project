"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.ErrorResolution = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _resolveFromMapping = require("../util/resolveFromMapping");
class ErrorResolution {
  constructor(params) {
    (0, _defineProperty2.default)(this, "errorAccessor", void 0);
    (0, _defineProperty2.default)(this, "errorCodesMap", void 0);
    (0, _defineProperty2.default)(this, "commonErrorsMapState", void 0);
    (0, _defineProperty2.default)(this, "onlineManager", void 0);
    (0, _defineProperty2.default)(this, "consumerResolvedError", void 0);
    (0, _defineProperty2.default)(this, "commonResolvedError", void 0);
    this.commonErrorsMapState = params.commonErrorsMapState;
    this.errorAccessor = params.errorAccessor;
    this.errorCodesMap = params.errorCodesMap;
    this.onlineManager = params.onlineManager;
  }
  get commonErrors() {
    return this.commonErrorsMapState.commonErrors;
  }
  _resolveNetworkError() {
    const {
      onlineManager,
      commonErrors,
      errorAccessor
    } = this;
    if (!commonErrors) {
      return null;
    }
    if (onlineManager.onLine) {
      return commonErrors.getNetworkErrorShowErrorProps(errorAccessor);
    }
    return commonErrors.connectionErrorShowErrorProps;
  }
  _resolveCommonError() {
    const {
      errorAccessor,
      commonErrors,
      errorCodesMap
    } = this;
    const {
      error,
      httpError,
      validationError
    } = errorAccessor;
    if (httpError == null) {
      return this._resolveNetworkError();
    }
    if (!commonErrors) {
      return null;
    }
    if (validationError) {
      var _commonErrors$commonE;
      return (_commonErrors$commonE = commonErrors.commonErrorsMap.statusCodeError) == null || _commonErrors$commonE.INVALID_ARGUMENT == null ? void 0 : _commonErrors$commonE.INVALID_ARGUMENT(error);
    }
    const resolvedError = (0, _resolveFromMapping.resolveFromMapping)({
      errorAccessor,
      errorCodesMap: commonErrors.commonErrorsMap
    });
    if (!resolvedError) {
      return (errorCodesMap == null || errorCodesMap.serverError == null ? void 0 : errorCodesMap.serverError(error)) ?? commonErrors.defaultErrorShowErrorProps;
    }
    return resolvedError;
  }
  _resolveConsumerError() {
    const {
      errorCodesMap,
      errorAccessor
    } = this;
    const {
      httpError
    } = errorAccessor;
    if (httpError == null || errorCodesMap == null) {
      return null;
    }
    return (0, _resolveFromMapping.resolveFromMapping)({
      errorAccessor,
      errorCodesMap
    });
  }
  resolve() {
    this.consumerResolvedError = this._resolveConsumerError();

    // If consumer resolved the error, we don't need to resolve the common error
    if (this.consumerResolvedError != null) {
      return;
    }
    this.commonResolvedError = this._resolveCommonError();
  }
  get errorToShow() {
    return this.consumerResolvedError ?? this.commonResolvedError;
  }
}
exports.ErrorResolution = ErrorResolution;
//# sourceMappingURL=ErrorResolution.js.map