"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.ErrorHandlerTestkitBase = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _events = require("events");
var _resolveFromMapping2 = require("../util/resolveFromMapping");
var _TranslationsState = require("../state/TranslationsState");
var _CommonErrorsMapState = require("../state/CommonErrorsMapState");
var _ErrorAccessor = require("../state/ErrorAccessor");
var _statusCodeTextToNumeric = require("../util/statusCodeTextToNumeric");
var _fallbackMessage = require("../fallbackMessage");
function isInteger(value) {
  return Number.isInteger(value);
}
class ErrorHandlerTestkitBase {
  constructor(params) {
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _defineProperty2.default)(this, "translations", void 0);
    (0, _defineProperty2.default)(this, "commonErrorsMap", void 0);
    (0, _defineProperty2.default)(this, "showError", props => {
      const {
        events
      } = this;
      events.on('showError', () => props);
    });
    (0, _defineProperty2.default)(this, "getCommonErrorMessageByStatus", async status => {
      var _resolveFromMapping;
      const {
        commonErrorsMap
      } = this;
      await commonErrorsMap.getInitPromise();
      if (!commonErrorsMap.commonErrors) {
        return undefined;
      }
      const httpError = Object.assign(new Error(), {
        name: '',
        message: '',
        response: {
          status: isInteger(status) ? status : _statusCodeTextToNumeric.statusCodeTextToNumeric[status] ?? 0,
          statusText: '',
          data: {},
          headers: {},
          config: {}
        },
        config: {},
        toJSON: () => ({}),
        __CANCEL__: false
      });
      return (_resolveFromMapping = (0, _resolveFromMapping2.resolveFromMapping)({
        errorCodesMap: commonErrorsMap.commonErrors.commonErrorsMap,
        errorAccessor: new _ErrorAccessor.ErrorAccessor({
          error: httpError
        })
      })) == null ? void 0 : _resolveFromMapping.message;
    });
    this.translations = new _TranslationsState.TranslationsState({
      createI18n: params.createI18n
    });
    this.commonErrorsMap = new _CommonErrorsMapState.CommonErrorsMapState({
      translations: this.translations,
      errorMonitor: {
        captureException: () => {}
      }
    });
  }
  get showErrorMock() {
    const {
      events
    } = this;
    return {
      get calls() {
        return events.listeners('showError').map(cb => cb());
      },
      get latest() {
        var _listeners;
        const listeners = events.listeners('showError');
        return (_listeners = listeners[listeners.length - 1]) == null ? void 0 : _listeners.call(listeners);
      }
    };
  }
  async getClientErrorMessages() {
    const {
      translations
    } = this;
    const t = await translations.getTranslateFn();
    return {
      networkError: t('errorHandler.common-error.networkError'),
      timeoutExceeded: t('errorHandler.common-error.technicalIssue.generic'),
      requestAborted: t('errorHandler.common-error.technicalIssue.generic'),
      otherNetworkError: t('errorHandler.common-error.technicalIssue-unmappedError'),
      noConnection: t('errorHandler.common-error.noConnection'),
      fallbackMessage: t('errorHandler.common-error.technicalIssue'),
      fallbackMessageEn: _fallbackMessage.fallbackMessage
    };
  }
}
exports.ErrorHandlerTestkitBase = ErrorHandlerTestkitBase;
//# sourceMappingURL=ErrorHandlerTestkitBase.js.map