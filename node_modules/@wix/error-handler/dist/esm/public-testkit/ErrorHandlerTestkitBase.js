import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { EventEmitter } from 'events';
import { resolveFromMapping } from '../util/resolveFromMapping';
import { TranslationsState } from '../state/TranslationsState';
import { CommonErrorsMapState } from '../state/CommonErrorsMapState';
import { ErrorAccessor } from '../state/ErrorAccessor';
import { statusCodeTextToNumeric } from '../util/statusCodeTextToNumeric';
import { fallbackMessage } from '../fallbackMessage';
function isInteger(value) {
  return Number.isInteger(value);
}
export class ErrorHandlerTestkitBase {
  constructor(params) {
    _defineProperty(this, "events", new EventEmitter());
    _defineProperty(this, "translations", void 0);
    _defineProperty(this, "commonErrorsMap", void 0);
    _defineProperty(this, "showError", props => {
      const {
        events
      } = this;
      events.on('showError', () => props);
    });
    _defineProperty(this, "getCommonErrorMessageByStatus", async status => {
      var _resolveFromMapping;
      const {
        commonErrorsMap
      } = this;
      await commonErrorsMap.getInitPromise();
      if (!commonErrorsMap.commonErrors) {
        return undefined;
      }
      const httpError = Object.assign(new Error(), {
        name: '',
        message: '',
        response: {
          status: isInteger(status) ? status : statusCodeTextToNumeric[status] ?? 0,
          statusText: '',
          data: {},
          headers: {},
          config: {}
        },
        config: {},
        toJSON: () => ({}),
        __CANCEL__: false
      });
      return (_resolveFromMapping = resolveFromMapping({
        errorCodesMap: commonErrorsMap.commonErrors.commonErrorsMap,
        errorAccessor: new ErrorAccessor({
          error: httpError
        })
      })) == null ? void 0 : _resolveFromMapping.message;
    });
    this.translations = new TranslationsState({
      createI18n: params.createI18n
    });
    this.commonErrorsMap = new CommonErrorsMapState({
      translations: this.translations,
      errorMonitor: {
        captureException: () => {}
      }
    });
  }
  get showErrorMock() {
    const {
      events
    } = this;
    return {
      get calls() {
        return events.listeners('showError').map(cb => cb());
      },
      get latest() {
        var _listeners;
        const listeners = events.listeners('showError');
        return (_listeners = listeners[listeners.length - 1]) == null ? void 0 : _listeners.call(listeners);
      }
    };
  }
  async getClientErrorMessages() {
    const {
      translations
    } = this;
    const t = await translations.getTranslateFn();
    return {
      networkError: t('errorHandler.common-error.networkError'),
      timeoutExceeded: t('errorHandler.common-error.technicalIssue.generic'),
      requestAborted: t('errorHandler.common-error.technicalIssue.generic'),
      otherNetworkError: t('errorHandler.common-error.technicalIssue-unmappedError'),
      noConnection: t('errorHandler.common-error.noConnection'),
      fallbackMessage: t('errorHandler.common-error.technicalIssue'),
      fallbackMessageEn: fallbackMessage
    };
  }
}
//# sourceMappingURL=ErrorHandlerTestkitBase.js.map