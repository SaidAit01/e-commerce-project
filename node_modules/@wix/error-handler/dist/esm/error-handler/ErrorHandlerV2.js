import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { ErrorAccessor } from '../state/ErrorAccessor';
import { reportGetResolvedErrorBi } from './reportGetResolvedErrorBi';
import { fallbackMessage } from '../fallbackMessage';
export class ErrorHandlerV2 {
  constructor(_errorHandler) {
    var _this = this;
    _defineProperty(this, "errorHandler", void 0);
    _defineProperty(this, "withErrorHandler", async function (fn, errorCodesMap, options) {
      if (options === void 0) {
        options = {};
      }
      const {
        errorHandler
      } = _this;
      const ops = {
        errorCodesMap: {
          validationError: errorCodesMap,
          statusCodeError: options.statusCodesOverrides,
          applicationError: Object.entries(errorCodesMap).reduce((acc, _ref) => {
            let [key, value] = _ref;
            if (value) {
              acc[key] = (_, error) => value(error);
            }
            return acc;
          }, {}),
          serverError: options.serverErrorOverride
        }
      };
      const response = await errorHandler.withErrorHandler(fn, ops);
      if (typeof Response !== 'undefined' && response instanceof Response) {
        const errorAccessor = new ErrorAccessor({
          error: response
        });
        errorHandler._setErrorHandlerErrorCodesMap(errorAccessor, ops);
        const {
          errorHandlerState
        } = errorAccessor;
        if (!response.ok && errorHandlerState) {
          errorHandlerState.responseData = await response.json().catch(() => null);
        }
      }
      return response;
    });
    _defineProperty(this, "getResolvedError", error => {
      const {
        errorHandler
      } = this;
      const {
        errorMonitor
      } = errorHandler;
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        const {
          httpError,
          errorHandlerState
        } = errorAccessor;
        const errorResolution = errorHandler._resolveError(errorAccessor);
        const resolvedError = errorHandlerState == null ? void 0 : errorHandlerState.resolvedError;
        const message = (resolvedError == null ? void 0 : resolvedError.message) ?? fallbackMessage;
        const action = resolvedError == null ? void 0 : resolvedError.action;
        const requestId = (resolvedError == null ? void 0 : resolvedError.requestId) ?? (httpError == null ? void 0 : httpError.requestId);
        reportGetResolvedErrorBi(errorHandler, {
          message,
          action,
          errorAccessor,
          errorResolution
        });
        return {
          message,
          action,
          requestId,
          ...resolvedError
        };
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
        throw e;
      }
    });
    _defineProperty(this, "showError", (error, props) => {
      this.errorHandler.showError(error, props);
    });
    _defineProperty(this, "reportRetryAttempt", error => {
      this.errorHandler.reportRetryAttempt(error);
    });
    _defineProperty(this, "handleError", (error, options) => {
      const {
        errorHandler
      } = this;
      if (typeof Response !== 'undefined' && error instanceof Response) {
        if (!error.ok) {
          errorHandler.handleError(error, options);
        }
      } else {
        errorHandler.handleError(error, options);
      }
    });
    this.errorHandler = _errorHandler;
  }
}
//# sourceMappingURL=ErrorHandlerV2.js.map