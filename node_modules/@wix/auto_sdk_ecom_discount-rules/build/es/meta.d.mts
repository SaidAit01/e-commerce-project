import { CreateDiscountRuleRequest as CreateDiscountRuleRequest$1, CreateDiscountRuleResponse as CreateDiscountRuleResponse$1, GetDiscountRuleRequest as GetDiscountRuleRequest$1, GetDiscountRuleResponse as GetDiscountRuleResponse$1, UpdateDiscountRuleRequest as UpdateDiscountRuleRequest$1, UpdateDiscountRuleResponse as UpdateDiscountRuleResponse$1, DeleteDiscountRuleRequest as DeleteDiscountRuleRequest$1, DeleteDiscountRuleResponse as DeleteDiscountRuleResponse$1, QueryDiscountRulesRequest as QueryDiscountRulesRequest$1, QueryDiscountRulesResponse as QueryDiscountRulesResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

interface DiscountRule {
    /**
     * Discount rule ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /**
     * Discount rule name.
     * @minLength 1
     * @maxLength 50
     */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts;
    /**
     * Discount rule status.
     * Default: `UNDEFINED`
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/** DiscountTrigger - description of a set of conditions, that if met, will trigger the associated rule actions */
interface DiscountTrigger extends DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
    /** Trigger type. */
    triggerType?: TriggerTypeWithLiterals;
}
/** @oneof */
interface DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
}
/**
 * This object represents a scope of catalog items. Examples:
 * 1. All catalog items of a specific app - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id`
 * 2. Specific catalog item - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id` + `catalog_item_ids`
 * 3. External catalog filter - type = CUSTOM_FILTER, CustomFilter with 'app_id' + 'params'
 */
interface Scope extends ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
    /**
     * Scope ID.
     * @minLength 1
     * @maxLength 100
     */
    id?: string;
    /** Scope type. */
    type?: ScopeTypeWithLiterals;
}
/** @oneof */
interface ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
}
declare enum ScopeType {
    UNDEFINED_SCOPE = "UNDEFINED_SCOPE",
    /** Specific catalog items */
    CATALOG_ITEM = "CATALOG_ITEM",
    /** Specific items by custom filters */
    CUSTOM_FILTER = "CUSTOM_FILTER"
}
/** @enumType */
type ScopeTypeWithLiterals = ScopeType | 'UNDEFINED_SCOPE' | 'CATALOG_ITEM' | 'CUSTOM_FILTER';
interface CatalogItemFilter {
    /**
     * Catalog App ID. For example, the Wix Stores, Wix Bookings, or 3rd-party `appId`.
     * @format GUID
     */
    catalogAppId?: string;
    /**
     * ID of the item within its Wix or 3rd-party catalog. For example, `productId` for Wix Stores.
     * @minLength 1
     * @maxLength 36
     * @maxSize 50
     */
    catalogItemIds?: string[];
}
interface CustomFilter {
    /**
     * Custom filter app ID, when relevant.
     * @format GUID
     */
    appId?: string;
    /**
     * Custom filter in `{ "key": "value" }` form.
     * For example, an array of `collectionIDs`:
     * `{ ["collectionId": "12345"], ["collectionId": "67890"] }`.
     */
    params?: Record<string, any> | null;
}
interface And {
    /**
     * List of triggers to have an "AND" operator between their results.
     * @minSize 2
     * @maxSize 5
     */
    triggers?: DiscountTrigger[];
}
interface Or {
    /**
     * List of triggers to have an "OR" operator between their results.
     * @minSize 2
     * @maxSize 5
     */
    triggers?: DiscountTrigger[];
}
interface Custom {
    /**
     * Trigger ID.
     * @minLength 1
     * @maxLength 100
     */
    id?: string;
    /**
     * ID of the app that created the trigger.
     * @format GUID
     */
    appId?: string;
}
interface SubtotalRange {
    /**
     * Relevant scopes for `SPECIFIC_ITEMS` target type.
     * @maxSize 50
     */
    scopes?: Scope[];
    /**
     * Minimum subtotal price (inclusive).
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    from?: string | null;
    /**
     * Maximum subtotal price (inclusive).
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    to?: string | null;
}
interface ItemQuantityRange {
    /**
     * Relevant scopes for `SPECIFIC_ITEMS` target type.
     * @maxSize 50
     */
    scopes?: Scope[];
    /**
     * Minimum item quantity (inclusive).
     * @min 1
     */
    from?: number | null;
    /**
     * Maximum item quantity (inclusive).
     * @min 1
     */
    to?: number | null;
}
declare enum TriggerType {
    UNDEFINED = "UNDEFINED",
    /** Operator used for chaining multiple triggers. Currently 1 `AND` chain operator is supported. */
    AND = "AND",
    /** Subtotal must be within the specified `subtotalRange` values. */
    SUBTOTAL_RANGE = "SUBTOTAL_RANGE",
    /** Quantity of items in scope must be within specified `itemQuantityRange` values. */
    ITEM_QUANTITY_RANGE = "ITEM_QUANTITY_RANGE",
    /** Custom trigger type defined in `customTrigger` object. */
    CUSTOM = "CUSTOM",
    /** Chain multiple triggers with OR operator */
    OR = "OR"
}
/** @enumType */
type TriggerTypeWithLiterals = TriggerType | 'UNDEFINED' | 'AND' | 'SUBTOTAL_RANGE' | 'ITEM_QUANTITY_RANGE' | 'CUSTOM' | 'OR';
interface ActiveTimeInfo {
    /** Date and time the discount rule is active **from**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    start?: Date | null;
    /** Date and time the discount rule is active **till**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    end?: Date | null;
}
interface Discounts {
    /**
     * Discounts.
     * @minSize 1
     * @maxSize 1
     */
    values?: Discount[];
}
interface Discount extends DiscountDiscountOneOf {
    /**
     * Percentage to discount from original price.
     * @min 0.1
     * @max 100
     */
    percentage?: number;
    /**
     * Amount to discount from original price.
     * @decimalValue options { gt:0, lte:1000000000000000, maxScale:4 }
     */
    fixedAmount?: string;
    /**
     * Fixed price. Line item will be fixed to this price.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    fixedPrice?: string;
    /**
     * Discount target.
     *
     * + `SPECIFIC_ITEMS`: Discount applies to a specific set of items.
     */
    targetType?: TypeWithLiterals;
    /** Data related to `SPECIFIC_ITEMS` target type. */
    specificItemsInfo?: SpecificItemsInfo;
    /** Discount type. */
    discountType?: DiscountTypeWithLiterals;
}
/** @oneof */
interface DiscountDiscountOneOf {
    /**
     * Percentage to discount from original price.
     * @min 0.1
     * @max 100
     */
    percentage?: number;
    /**
     * Amount to discount from original price.
     * @decimalValue options { gt:0, lte:1000000000000000, maxScale:4 }
     */
    fixedAmount?: string;
    /**
     * Fixed price. Line item will be fixed to this price.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    fixedPrice?: string;
}
declare enum Type {
    /** Target type is not defined */
    UNDEFINED = "UNDEFINED",
    /** Target type is a set of specific items */
    SPECIFIC_ITEMS = "SPECIFIC_ITEMS"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNDEFINED' | 'SPECIFIC_ITEMS';
interface SpecificItemsInfo {
    /**
     * All associated scopes for `SPECIFIC_ITEMS` target type.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** Price is reduced by percentage value. */
    PERCENTAGE = "PERCENTAGE",
    /** Price is reduced by fixed amount. */
    FIXED_AMOUNT = "FIXED_AMOUNT",
    /** Price will be set to fixed amount. */
    FIXED_PRICE = "FIXED_PRICE"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNDEFINED' | 'PERCENTAGE' | 'FIXED_AMOUNT' | 'FIXED_PRICE';
declare enum Status {
    /** Rule status is not defined. */
    UNDEFINED = "UNDEFINED",
    /** Rule status is live. */
    LIVE = "LIVE",
    /** Rule status is expired, it might have been live in the past. */
    EXPIRED = "EXPIRED",
    /** Rule status is pending, it might be live in the future. */
    PENDING = "PENDING"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNDEFINED' | 'LIVE' | 'EXPIRED' | 'PENDING';
interface CreateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface CreateDiscountRuleResponse {
    /** Discount rule. */
    discountRule?: DiscountRule;
}
interface GetDiscountRuleRequest {
    /**
     * ID of the discount rule to retrieve.
     * @format GUID
     */
    discountRuleId: string;
}
interface GetDiscountRuleResponse {
    /** The requested discount rule. */
    discountRule?: DiscountRule;
}
interface UpdateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface UpdateDiscountRuleResponse {
    /** Updated discount rule. */
    discountRule?: DiscountRule;
}
interface DeleteDiscountRuleRequest {
    /**
     * ID of the discount rule to delete.
     * @format GUID
     */
    discountRuleId: string;
}
interface DeleteDiscountRuleResponse {
}
interface QueryDiscountRulesRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface PlatformPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryDiscountRulesResponse {
    /** List of discount rules. */
    discountRules?: DiscountRule[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PlatformPagingMetadata;
}
interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createDiscountRule(): __PublicMethodMetaInfo<'POST', {}, CreateDiscountRuleRequest$1, CreateDiscountRuleRequest, CreateDiscountRuleResponse$1, CreateDiscountRuleResponse>;
declare function getDiscountRule(): __PublicMethodMetaInfo<'GET', {
    discountRuleId: string;
}, GetDiscountRuleRequest$1, GetDiscountRuleRequest, GetDiscountRuleResponse$1, GetDiscountRuleResponse>;
declare function updateDiscountRule(): __PublicMethodMetaInfo<'PATCH', {
    discountRuleId: string;
}, UpdateDiscountRuleRequest$1, UpdateDiscountRuleRequest, UpdateDiscountRuleResponse$1, UpdateDiscountRuleResponse>;
declare function deleteDiscountRule(): __PublicMethodMetaInfo<'DELETE', {
    discountRuleId: string;
}, DeleteDiscountRuleRequest$1, DeleteDiscountRuleRequest, DeleteDiscountRuleResponse$1, DeleteDiscountRuleResponse>;
declare function queryDiscountRules(): __PublicMethodMetaInfo<'POST', {}, QueryDiscountRulesRequest$1, QueryDiscountRulesRequest, QueryDiscountRulesResponse$1, QueryDiscountRulesResponse>;

export { type __PublicMethodMetaInfo, createDiscountRule, deleteDiscountRule, getDiscountRule, queryDiscountRules, updateDiscountRule };
