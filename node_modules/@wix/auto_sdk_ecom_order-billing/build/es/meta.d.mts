import { GetOrderRefundabilityRequest as GetOrderRefundabilityRequest$1, GetOrderRefundabilityResponse as GetOrderRefundabilityResponse$1, CalculateRefundRequest as CalculateRefundRequest$1, CalculateRefundResponse as CalculateRefundResponse$1, RefundPaymentsRequest as RefundPaymentsRequest$1, RefundPaymentsResponse as RefundPaymentsResponse$1, AuthorizeChargeWithSavedPaymentMethodRequest as AuthorizeChargeWithSavedPaymentMethodRequest$1, AuthorizeChargeWithSavedPaymentMethodResponse as AuthorizeChargeWithSavedPaymentMethodResponse$1, VoidAuthorizedPaymentsRequest as VoidAuthorizedPaymentsRequest$1, VoidAuthorizedPaymentsResponse as VoidAuthorizedPaymentsResponse$1, CaptureAuthorizedPaymentsRequest as CaptureAuthorizedPaymentsRequest$1, CaptureAuthorizedPaymentsResponse as CaptureAuthorizedPaymentsResponse$1, GenerateReceiptsRequest as GenerateReceiptsRequest$1, GenerateReceiptsResponse as GenerateReceiptsResponse$1, RedeemGiftCardRequest as RedeemGiftCardRequest$1, RedeemGiftCardResponse as RedeemGiftCardResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

interface GetOrderRefundabilityRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
interface GetOrderRefundabilityResponse {
    /**
     * Payments and their refundability amounts and statuses.
     * @maxSize 100
     */
    payments?: PaymentRefundability[];
    /** Aggregated payments summary. */
    paymentsSummary?: PaymentsSummary;
    /**
     * List of line item refund quantities.
     * @maxSize 300
     */
    lineItems?: LineItemRefundability[];
    /** Shipping refund amounts - both previously refunded and the amount still available for refund. */
    shipping?: ShippingRefundability;
    /**
     * List of additional fee refund amounts - both previously refunded and the amount still available for refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefundability[];
}
interface PaymentRefundability extends PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
    /** Payment details. */
    payment?: PaymentInfo;
    /**
     * URL to the payment provider's dashboard.
     * @format WEB_URL
     */
    providerLink?: string | null;
}
/** @oneof */
interface PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
}
interface PaymentInfo extends PaymentInfoSummaryOneOf, PaymentInfoPaymentMethodDetailsOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Payment method. Non-exhaustive list of supported values:
     *
     * `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 50
     */
    paymentMethod?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
}
/** @oneof */
interface PaymentInfoSummaryOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
}
/** @oneof */
interface PaymentInfoPaymentMethodDetailsOneOf {
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
interface MonetaryPaymentSummary {
    /** Paid amount. */
    paid?: Price;
    /** Refunded amount. */
    refunded?: Price;
    /** Pending refund amount. */
    refundPending?: Price;
    /**
     * Maximum amount to refund,  **if** the refund is available.
     * max_refund = paid - refunded - refund_pending
     * `maxRefund` is calculated as `paid` minus `refunded` minus `refundPending`.
     */
    maxRefund?: Price;
}
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface MembershipPaymentSummary {
    /**
     * IDs of line items paid with a membership.
     * @format GUID
     * @maxSize 100
     */
    paidLineItemIds?: string[];
    /**
     * IDs of line items previously refunded, and paid with a membership.
     * @format GUID
     * @maxSize 100
     */
    refundedLineItemIds?: string[];
    /**
     * IDs of line items paid with a membership and available for refund.
     * @format GUID
     * @maxSize 100
     */
    refundableLineItemIds?: string[];
}
interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
interface ManuallyRefundablePaymentStatus {
    /** Reason why the payment must be manually refunded via the payment provider's dashboard. */
    reason?: ManuallyRefundableReasonWithLiterals;
}
declare enum ManuallyRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    EXPIRED = "EXPIRED",
    NOT_SUPPORTED = "NOT_SUPPORTED",
    OFFLINE = "OFFLINE",
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
/** @enumType */
type ManuallyRefundableReasonWithLiterals = ManuallyRefundableReason | 'UNKNOWN_REASON' | 'EXPIRED' | 'NOT_SUPPORTED' | 'OFFLINE' | 'REQUIRES_CARD_READER';
interface NonRefundablePaymentStatus {
    /** Reason why the payment is not refundable. */
    reason?: NonRefundableReasonWithLiterals;
}
declare enum NonRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    NOT_PAID = "NOT_PAID",
    ZERO_PRICE = "ZERO_PRICE",
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    PENDING_REFUND = "PENDING_REFUND",
    FORBIDDEN = "FORBIDDEN",
    TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
    ORDER_IS_PENDING = "ORDER_IS_PENDING",
    ORDER_IS_REJECTED = "ORDER_IS_REJECTED",
    AMOUNT_OFFSET_BY_CHARGEBACK = "AMOUNT_OFFSET_BY_CHARGEBACK"
}
/** @enumType */
type NonRefundableReasonWithLiterals = NonRefundableReason | 'UNKNOWN_REASON' | 'ALREADY_REFUNDED' | 'PROVIDER_IS_DOWN' | 'NOT_PAID' | 'ZERO_PRICE' | 'DISABLED_BY_PROVIDER' | 'PENDING_REFUND' | 'FORBIDDEN' | 'TRANSACTION_NOT_FOUND' | 'ORDER_IS_PENDING' | 'ORDER_IS_REJECTED' | 'AMOUNT_OFFSET_BY_CHARGEBACK';
interface PaymentsSummary {
    /** Monetary payments summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payments summary. */
    membership?: MembershipPaymentSummary;
}
interface LineItemRefundability {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /** Original line item quantity before any refunds. */
    originalQuantity?: number;
    /** Previously refunded line item quantity. */
    refundedQuantity?: number;
    /** Line item quantity that is available for refund. */
    availableRefundQuantity?: number;
}
interface ShippingRefundability {
    /** Original shipping fee amount. */
    amount?: Price;
    /** Previously refunded shipping fee amount. */
    refundedAmount?: Price;
    /** Shipping fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface AdditionalFeeRefundability {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /** Original additional fee amount. */
    amount?: Price;
    /** Previously refunded additional fee amount. */
    refundedAmount?: Price;
    /** Additional fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface CalculateRefundRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
interface RefundItems {
    /**
     * Line items and their quantities to refund.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees and their amounts to refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount to refund. */
    shipping?: ShippingRefund;
}
interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to refund.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
interface ShippingRefund {
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
interface CalculateRefundResponse extends CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
    /**
     * Aggregated summary of all items provided for refund.
     *
     * This field is not returned when refund is not available for the given list of items.
     */
    summary?: AggregatedRefundSummary;
    /** Calculated summary of each item provided for refund. */
    calculatedRefundItems?: CalculatedRefundItems;
}
/** @oneof */
interface CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
}
interface AggregatedRefundSummary {
    /** Total refund amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
    /** Total cost of the line items being refunded (without tax and discount). */
    lineItemsSubtotal?: Price;
    /** Total cost of the additional fees being refunded. */
    additionalFeesTotal?: Price;
}
interface CalculatedRefundItems {
    /**
     * Calculated refund details for each line item.
     * @maxSize 300
     */
    lineItems?: CalculatedLineItemRefund[];
    /**
     * Calculated refund details for each additional fee.
     * @maxSize 100
     */
    additionalFees?: CalculatedAdditionalFeeRefund[];
    /** Calculated refund details for the shipping fee. */
    shipping?: CalculatedShippingRefund;
}
interface CalculatedLineItemRefund {
    /** Line item refund details. */
    item?: LineItemRefund;
    /** Calculated refund summary for this line item. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundSummary {
    /** Total refundable amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
}
interface CalculatedAdditionalFeeRefund {
    /** Additional fee refund details. */
    additionalFee?: AdditionalFeeRefund;
    /** Calculated refund summary for this additional fee. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedShippingRefund {
    /** Shipping refund details. */
    shipping?: ShippingRefund;
    /** Calculated refund summary for shipping. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundNotAvailableStatus {
    /**
     * Refund calculation errors.
     * @maxSize 401
     */
    errors?: CalculationError[];
}
interface CalculationError extends CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
    /** Error details */
    error?: Details;
}
/** @oneof */
interface CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
}
interface Details extends DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
    /**
     * deprecated in API's - to enable migration from rendering arbitrary tracing to rest response
     * @deprecated
     */
    tracing?: Record<string, string>;
}
/** @oneof */
interface DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * example result:
 * {
 * "fieldViolations": [
 * {
 * "field": "fieldA",
 * "description": "invalid music note. supported notes: [do,re,mi,fa,sol,la,ti]",
 * "violatedRule": "OTHER",
 * "ruleName": "INVALID_NOTE",
 * "data": {
 * "value": "FI"
 * }
 * },
 * {
 * "field": "fieldB",
 * "description": "field value out of range. supported range: [0-20]",
 * "violatedRule": "MAX",
 * "data": {
 * "threshold": 20
 * }
 * },
 * {
 * "field": "fieldC",
 * "description": "invalid phone number. provide a valid phone number of size: [7-12], supported characters: [0-9, +, -, (, )]",
 * "violatedRule": "FORMAT",
 * "data": {
 * "type": "PHONE"
 * }
 * }
 * ]
 * }
 */
interface ValidationError {
    fieldViolations?: FieldViolation[];
}
declare enum RuleType {
    VALIDATION = "VALIDATION",
    OTHER = "OTHER",
    MAX = "MAX",
    MIN = "MIN",
    MAX_LENGTH = "MAX_LENGTH",
    MIN_LENGTH = "MIN_LENGTH",
    MAX_SIZE = "MAX_SIZE",
    MIN_SIZE = "MIN_SIZE",
    FORMAT = "FORMAT",
    DECIMAL_LTE = "DECIMAL_LTE",
    DECIMAL_GTE = "DECIMAL_GTE",
    DECIMAL_LT = "DECIMAL_LT",
    DECIMAL_GT = "DECIMAL_GT",
    DECIMAL_MAX_SCALE = "DECIMAL_MAX_SCALE",
    INVALID_ENUM_VALUE = "INVALID_ENUM_VALUE",
    REQUIRED_FIELD = "REQUIRED_FIELD",
    FIELD_NOT_ALLOWED = "FIELD_NOT_ALLOWED",
    ONE_OF_ALIGNMENT = "ONE_OF_ALIGNMENT",
    EXACT_LENGTH = "EXACT_LENGTH",
    EXACT_SIZE = "EXACT_SIZE",
    REQUIRED_ONE_OF_FIELD = "REQUIRED_ONE_OF_FIELD"
}
/** @enumType */
type RuleTypeWithLiterals = RuleType | 'VALIDATION' | 'OTHER' | 'MAX' | 'MIN' | 'MAX_LENGTH' | 'MIN_LENGTH' | 'MAX_SIZE' | 'MIN_SIZE' | 'FORMAT' | 'DECIMAL_LTE' | 'DECIMAL_GTE' | 'DECIMAL_LT' | 'DECIMAL_GT' | 'DECIMAL_MAX_SCALE' | 'INVALID_ENUM_VALUE' | 'REQUIRED_FIELD' | 'FIELD_NOT_ALLOWED' | 'ONE_OF_ALIGNMENT' | 'EXACT_LENGTH' | 'EXACT_SIZE' | 'REQUIRED_ONE_OF_FIELD';
interface FieldViolation {
    field?: string;
    description?: string;
    violatedRule?: RuleTypeWithLiterals;
    /** applicable when violated_rule=OTHER */
    ruleName?: string | null;
    data?: Record<string, any> | null;
}
interface SystemError {
    /** Error code. */
    errorCode?: string | null;
}
interface RefundPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * List of payments and their amounts to refund.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /**
     * Customer-provided reason for the refund.
     * @maxLength 200
     */
    customerReason?: string | null;
}
interface PaymentRefund {
    /**
     * Specific payment within the order to refund
     * @format GUID
     */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Indicates that refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, refund will be added with status SUCCEEDED and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
interface RefundSideEffects {
    /** Restocking side effects. */
    restock?: RestockSideEffects;
    /** Notification side effects. */
    notifications?: NotificationSideEffects;
}
interface RestockItem {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to restock.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface RestockSideEffects {
    /**
     * List of items to restock.
     * @maxSize 300
     */
    lineItems?: RestockItem[];
}
interface NotificationSideEffects {
    /**
     * Whether to send a refund confirmation email to the customer.
     *
     * Default: `false`
     */
    sendCustomerEmail?: boolean;
    /**
     * Custom message added to the refund confirmation email.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface RefundPaymentsResponse {
    /** Refund details. */
    refund?: Refund;
    /** The order's transactions records after the refunds were performed. */
    orderTransactions?: OrderTransactions;
}
interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: V1AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatusWithLiterals;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
/** @enumType */
type RefundStatusWithLiterals = RefundStatus | 'PENDING' | 'SUCCEEDED' | 'FAILED' | 'SCHEDULED' | 'STARTED';
interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: V1LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: V1AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: V1ShippingRefund;
}
interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface V1LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
interface V1AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
interface PaymentReceiptInfoOneOf {
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
    /**
     * Record of chargebacks made by the buyer.
     * @maxSize 6
     */
    chargebacks?: Chargeback[];
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
/** @enumType */
type TransactionStatusWithLiterals = TransactionStatus | 'UNDEFINED' | 'APPROVED' | 'PENDING' | 'PENDING_MERCHANT' | 'CANCELED' | 'DECLINED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'AUTHORIZED' | 'VOIDED';
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: V1ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatusWithLiterals;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationCaptureStatusWithLiterals = AuthorizationCaptureStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatusWithLiterals;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: ReasonWithLiterals;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationVoidStatusWithLiterals = AuthorizationVoidStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
/** Reason the authorization was voided. */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'MANUAL' | 'SCHEDULED';
interface V1ScheduledAction {
    /** Type of the action. */
    actionType?: ActionTypeWithLiterals;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ActionTypeWithLiterals = ActionType | 'UNKNOWN_ACTION_TYPE' | 'VOID' | 'CAPTURE';
interface Chargeback {
    /**
     * Chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    id?: string;
    /**
     * Date and time the chargeback was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    createdDate?: Date | null;
    /**
     * Date and time the chargeback was updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Amount.
     * @readonly
     * @immutable
     */
    amount?: Price;
    /**
     * Reversal amount. Present only when status is REVERSED.
     * @readonly
     */
    reversalAmount?: Price;
    /**
     * Status.
     *
     * Default: `"APPROVED"`.
     */
    status?: ChargebackStatusWithLiterals;
    /**
     * External chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    externalId?: string | null;
}
declare enum ChargebackStatus {
    UNSPECIFIED = "UNSPECIFIED",
    /** Chargeback was approved. */
    APPROVED = "APPROVED",
    /** Chargeback was reversed. */
    REVERSED = "REVERSED"
}
/** @enumType */
type ChargebackStatusWithLiterals = ChargebackStatus | 'UNSPECIFIED' | 'APPROVED' | 'REVERSED';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
interface AuthorizeChargeWithSavedPaymentMethodRequest {
    /**
     * Order ID.
     *
     * The order must have a saved payment method associated.
     * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
     * If no saved payment exists, the call will fail.
     * @format GUID
     */
    orderId: string;
    /** Amount to authorize. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
interface DelayedCaptureSettings {
    /** The action to perform on the authorized payment after the specified duration. */
    scheduledAction?: ScheduledActionWithLiterals;
    /**
     * Delay duration before performing the scheduled action.
     * > **Note:** If not set, the payment provider's default period will be used.
     */
    delayDuration?: Duration;
}
declare enum ScheduledAction {
    UNSPECIFIED = "UNSPECIFIED",
    /** Whether payment will be auto-voided when duration passes. */
    VOID = "VOID",
    /** Whether payment will be auto-captured when duration passes. */
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ScheduledActionWithLiterals = ScheduledAction | 'UNSPECIFIED' | 'VOID' | 'CAPTURE';
interface Duration {
    /**
     * Amount of units. For example, 30 MINUTES, 1 HOURS, 7 DAYS, etc
     * @min 1
     */
    count?: number;
    /** Duration unit: MINUTES, HOURS and DAYS */
    unit?: DurationUnitWithLiterals;
}
declare enum DurationUnit {
    UNKNOWN_DURATION_UNIT = "UNKNOWN_DURATION_UNIT",
    MINUTES = "MINUTES",
    HOURS = "HOURS",
    DAYS = "DAYS"
}
/** @enumType */
type DurationUnitWithLiterals = DurationUnit | 'UNKNOWN_DURATION_UNIT' | 'MINUTES' | 'HOURS' | 'DAYS';
interface AuthorizeChargeWithSavedPaymentMethodResponse {
    /** Authorized payment. */
    payment?: Payment;
    /** Order transactions updated with authorized payment. */
    orderTransactions?: OrderTransactions;
}
interface VoidAuthorizedPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of the authorized payments to void.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
interface VoidAuthorizedPaymentsResponse {
    /** Order transactions updated with voided payment. */
    orderTransactions?: OrderTransactions;
}
interface CaptureAuthorizedPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * List payment IDs and amounts to capture.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
interface PaymentCapture {
    /**
     * ID of the payment to capture.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Capture amount.
     *
     * > **Note:** If not provided, the full authorized amount will be captured.
     */
    amount?: Price;
}
interface CaptureAuthorizedPaymentsResponse {
    /** Order transactions updated with captured payment. */
    orderTransactions?: OrderTransactions;
}
interface GenerateReceiptsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment IDs.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
interface GenerateReceiptsResponse {
    /** Generated receipts information. */
    receipts?: ReceiptInfo[];
}
interface ReceiptInfo {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Receipt ID.
     * @format GUID
     */
    receiptId?: string;
}
interface RedeemGiftCardRequest {
    /**
     * ID of the order to pay for with the gift card.
     * @format GUID
     */
    orderId: string;
    /**
     * Code of the gift card to redeem.
     * @minLength 8
     * @maxLength 20
     */
    giftCardCode: string;
    /** Amount to redeem from the gift card. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
}
interface RedeemGiftCardResponse {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** Gift card payment. */
    payment?: Payment;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getOrderRefundability(): __PublicMethodMetaInfo<'POST', {}, GetOrderRefundabilityRequest$1, GetOrderRefundabilityRequest, GetOrderRefundabilityResponse$1, GetOrderRefundabilityResponse>;
declare function calculateRefund(): __PublicMethodMetaInfo<'POST', {}, CalculateRefundRequest$1, CalculateRefundRequest, CalculateRefundResponse$1, CalculateRefundResponse>;
declare function refundPayments(): __PublicMethodMetaInfo<'POST', {}, RefundPaymentsRequest$1, RefundPaymentsRequest, RefundPaymentsResponse$1, RefundPaymentsResponse>;
declare function authorizeChargeWithSavedPaymentMethod(): __PublicMethodMetaInfo<'POST', {}, AuthorizeChargeWithSavedPaymentMethodRequest$1, AuthorizeChargeWithSavedPaymentMethodRequest, AuthorizeChargeWithSavedPaymentMethodResponse$1, AuthorizeChargeWithSavedPaymentMethodResponse>;
declare function voidAuthorizedPayments(): __PublicMethodMetaInfo<'POST', {}, VoidAuthorizedPaymentsRequest$1, VoidAuthorizedPaymentsRequest, VoidAuthorizedPaymentsResponse$1, VoidAuthorizedPaymentsResponse>;
declare function captureAuthorizedPayments(): __PublicMethodMetaInfo<'POST', {}, CaptureAuthorizedPaymentsRequest$1, CaptureAuthorizedPaymentsRequest, CaptureAuthorizedPaymentsResponse$1, CaptureAuthorizedPaymentsResponse>;
declare function generateReceipts(): __PublicMethodMetaInfo<'POST', {}, GenerateReceiptsRequest$1, GenerateReceiptsRequest, GenerateReceiptsResponse$1, GenerateReceiptsResponse>;
declare function redeemGiftCard(): __PublicMethodMetaInfo<'POST', {}, RedeemGiftCardRequest$1, RedeemGiftCardRequest, RedeemGiftCardResponse$1, RedeemGiftCardResponse>;

export { type __PublicMethodMetaInfo, authorizeChargeWithSavedPaymentMethod, calculateRefund, captureAuthorizedPayments, generateReceipts, getOrderRefundability, redeemGiftCard, refundPayments, voidAuthorizedPayments };
