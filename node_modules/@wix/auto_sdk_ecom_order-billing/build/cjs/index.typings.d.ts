import { NonNullablePaths } from '@wix/sdk-types';

interface OrderBilling {
    /**
     * Entity ID.
     * @format GUID
     */
    _id?: string | null;
}
interface GetOrderRefundabilityRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
interface GetOrderRefundabilityResponse {
    /**
     * Payments and their refundability amounts and statuses.
     * @maxSize 100
     */
    payments?: PaymentRefundability[];
    /** Aggregated payments summary. */
    paymentsSummary?: PaymentsSummary;
    /**
     * List of line item refund quantities.
     * @maxSize 300
     */
    lineItems?: LineItemRefundability[];
    /** Shipping refund amounts - both previously refunded and the amount still available for refund. */
    shipping?: ShippingRefundability;
    /**
     * List of additional fee refund amounts - both previously refunded and the amount still available for refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefundability[];
}
interface PaymentRefundability extends PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
    /** Payment details. */
    payment?: PaymentInfo;
    /**
     * URL to the payment provider's dashboard.
     * @format WEB_URL
     */
    providerLink?: string | null;
}
/** @oneof */
interface PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
}
interface PaymentInfo extends PaymentInfoSummaryOneOf, PaymentInfoPaymentMethodDetailsOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Payment method. Non-exhaustive list of supported values:
     *
     * `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 50
     */
    paymentMethod?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
}
/** @oneof */
interface PaymentInfoSummaryOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
}
/** @oneof */
interface PaymentInfoPaymentMethodDetailsOneOf {
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
interface MonetaryPaymentSummary {
    /** Paid amount. */
    paid?: Price;
    /** Refunded amount. */
    refunded?: Price;
    /** Pending refund amount. */
    refundPending?: Price;
    /**
     * Maximum amount to refund,  **if** the refund is available.
     * max_refund = paid - refunded - refund_pending
     * `maxRefund` is calculated as `paid` minus `refunded` minus `refundPending`.
     */
    maxRefund?: Price;
}
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface MembershipPaymentSummary {
    /**
     * IDs of line items paid with a membership.
     * @format GUID
     * @maxSize 100
     */
    paidLineItemIds?: string[];
    /**
     * IDs of line items previously refunded, and paid with a membership.
     * @format GUID
     * @maxSize 100
     */
    refundedLineItemIds?: string[];
    /**
     * IDs of line items paid with a membership and available for refund.
     * @format GUID
     * @maxSize 100
     */
    refundableLineItemIds?: string[];
}
interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
interface ManuallyRefundablePaymentStatus {
    /** Reason why the payment must be manually refunded via the payment provider's dashboard. */
    reason?: ManuallyRefundableReasonWithLiterals;
}
declare enum ManuallyRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    EXPIRED = "EXPIRED",
    NOT_SUPPORTED = "NOT_SUPPORTED",
    OFFLINE = "OFFLINE",
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
/** @enumType */
type ManuallyRefundableReasonWithLiterals = ManuallyRefundableReason | 'UNKNOWN_REASON' | 'EXPIRED' | 'NOT_SUPPORTED' | 'OFFLINE' | 'REQUIRES_CARD_READER';
interface NonRefundablePaymentStatus {
    /** Reason why the payment is not refundable. */
    reason?: NonRefundableReasonWithLiterals;
}
declare enum NonRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    NOT_PAID = "NOT_PAID",
    ZERO_PRICE = "ZERO_PRICE",
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    PENDING_REFUND = "PENDING_REFUND",
    FORBIDDEN = "FORBIDDEN",
    TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
    ORDER_IS_PENDING = "ORDER_IS_PENDING",
    ORDER_IS_REJECTED = "ORDER_IS_REJECTED",
    AMOUNT_OFFSET_BY_CHARGEBACK = "AMOUNT_OFFSET_BY_CHARGEBACK"
}
/** @enumType */
type NonRefundableReasonWithLiterals = NonRefundableReason | 'UNKNOWN_REASON' | 'ALREADY_REFUNDED' | 'PROVIDER_IS_DOWN' | 'NOT_PAID' | 'ZERO_PRICE' | 'DISABLED_BY_PROVIDER' | 'PENDING_REFUND' | 'FORBIDDEN' | 'TRANSACTION_NOT_FOUND' | 'ORDER_IS_PENDING' | 'ORDER_IS_REJECTED' | 'AMOUNT_OFFSET_BY_CHARGEBACK';
interface PaymentsSummary {
    /** Monetary payments summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payments summary. */
    membership?: MembershipPaymentSummary;
}
interface LineItemRefundability {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /** Original line item quantity before any refunds. */
    originalQuantity?: number;
    /** Previously refunded line item quantity. */
    refundedQuantity?: number;
    /** Line item quantity that is available for refund. */
    availableRefundQuantity?: number;
}
interface ShippingRefundability {
    /** Original shipping fee amount. */
    amount?: Price;
    /** Previously refunded shipping fee amount. */
    refundedAmount?: Price;
    /** Shipping fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface AdditionalFeeRefundability {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /** Original additional fee amount. */
    amount?: Price;
    /** Previously refunded additional fee amount. */
    refundedAmount?: Price;
    /** Additional fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface CalculateRefundRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
interface RefundItems {
    /**
     * Line items and their quantities to refund.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees and their amounts to refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount to refund. */
    shipping?: ShippingRefund;
}
interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to refund.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
interface ShippingRefund {
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
interface CalculateRefundResponse extends CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
    /**
     * Aggregated summary of all items provided for refund.
     *
     * This field is not returned when refund is not available for the given list of items.
     */
    summary?: AggregatedRefundSummary;
    /** Calculated summary of each item provided for refund. */
    calculatedRefundItems?: CalculatedRefundItems;
}
/** @oneof */
interface CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
}
interface AggregatedRefundSummary {
    /** Total refund amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
    /** Total cost of the line items being refunded (without tax and discount). */
    lineItemsSubtotal?: Price;
    /** Total cost of the additional fees being refunded. */
    additionalFeesTotal?: Price;
}
interface CalculatedRefundItems {
    /**
     * Calculated refund details for each line item.
     * @maxSize 300
     */
    lineItems?: CalculatedLineItemRefund[];
    /**
     * Calculated refund details for each additional fee.
     * @maxSize 100
     */
    additionalFees?: CalculatedAdditionalFeeRefund[];
    /** Calculated refund details for the shipping fee. */
    shipping?: CalculatedShippingRefund;
}
interface CalculatedLineItemRefund {
    /** Line item refund details. */
    item?: LineItemRefund;
    /** Calculated refund summary for this line item. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundSummary {
    /** Total refundable amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
}
interface CalculatedAdditionalFeeRefund {
    /** Additional fee refund details. */
    additionalFee?: AdditionalFeeRefund;
    /** Calculated refund summary for this additional fee. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedShippingRefund {
    /** Shipping refund details. */
    shipping?: ShippingRefund;
    /** Calculated refund summary for shipping. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundNotAvailableStatus {
    /**
     * Refund calculation errors.
     * @maxSize 401
     */
    errors?: CalculationError[];
}
interface CalculationError extends CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
    /** Error details */
    error?: Details;
}
/** @oneof */
interface CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
}
interface Details extends DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
    /**
     * deprecated in API's - to enable migration from rendering arbitrary tracing to rest response
     * @deprecated
     */
    tracing?: Record<string, string>;
}
/** @oneof */
interface DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * example result:
 * {
 * "fieldViolations": [
 * {
 * "field": "fieldA",
 * "description": "invalid music note. supported notes: [do,re,mi,fa,sol,la,ti]",
 * "violatedRule": "OTHER",
 * "ruleName": "INVALID_NOTE",
 * "data": {
 * "value": "FI"
 * }
 * },
 * {
 * "field": "fieldB",
 * "description": "field value out of range. supported range: [0-20]",
 * "violatedRule": "MAX",
 * "data": {
 * "threshold": 20
 * }
 * },
 * {
 * "field": "fieldC",
 * "description": "invalid phone number. provide a valid phone number of size: [7-12], supported characters: [0-9, +, -, (, )]",
 * "violatedRule": "FORMAT",
 * "data": {
 * "type": "PHONE"
 * }
 * }
 * ]
 * }
 */
interface ValidationError {
    fieldViolations?: FieldViolation[];
}
declare enum RuleType {
    VALIDATION = "VALIDATION",
    OTHER = "OTHER",
    MAX = "MAX",
    MIN = "MIN",
    MAX_LENGTH = "MAX_LENGTH",
    MIN_LENGTH = "MIN_LENGTH",
    MAX_SIZE = "MAX_SIZE",
    MIN_SIZE = "MIN_SIZE",
    FORMAT = "FORMAT",
    DECIMAL_LTE = "DECIMAL_LTE",
    DECIMAL_GTE = "DECIMAL_GTE",
    DECIMAL_LT = "DECIMAL_LT",
    DECIMAL_GT = "DECIMAL_GT",
    DECIMAL_MAX_SCALE = "DECIMAL_MAX_SCALE",
    INVALID_ENUM_VALUE = "INVALID_ENUM_VALUE",
    REQUIRED_FIELD = "REQUIRED_FIELD",
    FIELD_NOT_ALLOWED = "FIELD_NOT_ALLOWED",
    ONE_OF_ALIGNMENT = "ONE_OF_ALIGNMENT",
    EXACT_LENGTH = "EXACT_LENGTH",
    EXACT_SIZE = "EXACT_SIZE",
    REQUIRED_ONE_OF_FIELD = "REQUIRED_ONE_OF_FIELD"
}
/** @enumType */
type RuleTypeWithLiterals = RuleType | 'VALIDATION' | 'OTHER' | 'MAX' | 'MIN' | 'MAX_LENGTH' | 'MIN_LENGTH' | 'MAX_SIZE' | 'MIN_SIZE' | 'FORMAT' | 'DECIMAL_LTE' | 'DECIMAL_GTE' | 'DECIMAL_LT' | 'DECIMAL_GT' | 'DECIMAL_MAX_SCALE' | 'INVALID_ENUM_VALUE' | 'REQUIRED_FIELD' | 'FIELD_NOT_ALLOWED' | 'ONE_OF_ALIGNMENT' | 'EXACT_LENGTH' | 'EXACT_SIZE' | 'REQUIRED_ONE_OF_FIELD';
interface FieldViolation {
    field?: string;
    description?: string;
    violatedRule?: RuleTypeWithLiterals;
    /** applicable when violated_rule=OTHER */
    ruleName?: string | null;
    data?: Record<string, any> | null;
}
interface SystemError {
    /** Error code. */
    errorCode?: string | null;
}
interface RefundPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * List of payments and their amounts to refund.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /**
     * Customer-provided reason for the refund.
     * @maxLength 200
     */
    customerReason?: string | null;
}
interface PaymentRefund {
    /**
     * Specific payment within the order to refund
     * @format GUID
     */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Indicates that refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, refund will be added with status SUCCEEDED and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
interface ExternalRefundInfo {
    /**
     * Affects the refund status of the refund and payment.
     * If set to `SUCCEEDED`, the payment will be marked as refunded immediately.
     * If set to `PENDING`, the payment will not be marked as refunded until the payment provider notifies us about the success/failure of the refund
     * OR until the caller updates the refund status to SUCCEEDED/FAILED. Meanwhile additional refunds for this payment are blocked.
     */
    refundStatus?: ExternalRefundStatusWithLiterals;
}
declare enum ExternalRefundStatus {
    /** An external refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** An external refund was or going to be initiated on payment provider side. */
    PENDING = "PENDING"
}
/** @enumType */
type ExternalRefundStatusWithLiterals = ExternalRefundStatus | 'SUCCEEDED' | 'PENDING';
interface RefundSideEffects {
    /** Restocking side effects. */
    restock?: RestockSideEffects;
    /** Notification side effects. */
    notifications?: NotificationSideEffects;
}
interface RestockItem {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to restock.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface RestockSideEffects {
    /**
     * List of items to restock.
     * @maxSize 300
     */
    lineItems?: RestockItem[];
}
interface NotificationSideEffects {
    /**
     * Whether to send a refund confirmation email to the customer.
     *
     * Default: `false`
     */
    sendCustomerEmail?: boolean;
    /**
     * Custom message added to the refund confirmation email.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface RefundPaymentsResponse {
    /** Refund details. */
    refund?: Refund;
    /** The order's transactions records after the refunds were performed. */
    orderTransactions?: OrderTransactions;
}
interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: V1AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatusWithLiterals;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
/** @enumType */
type RefundStatusWithLiterals = RefundStatus | 'PENDING' | 'SUCCEEDED' | 'FAILED' | 'SCHEDULED' | 'STARTED';
interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: V1LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: V1AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: V1ShippingRefund;
}
interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface V1LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
interface V1AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
interface PaymentReceiptInfoOneOf {
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
    /**
     * Record of chargebacks made by the buyer.
     * @maxSize 6
     */
    chargebacks?: Chargeback[];
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
/** @enumType */
type TransactionStatusWithLiterals = TransactionStatus | 'UNDEFINED' | 'APPROVED' | 'PENDING' | 'PENDING_MERCHANT' | 'CANCELED' | 'DECLINED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'AUTHORIZED' | 'VOIDED';
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: V1ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatusWithLiterals;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationCaptureStatusWithLiterals = AuthorizationCaptureStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatusWithLiterals;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: ReasonWithLiterals;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationVoidStatusWithLiterals = AuthorizationVoidStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
/** Reason the authorization was voided. */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'MANUAL' | 'SCHEDULED';
interface V1ScheduledAction {
    /** Type of the action. */
    actionType?: ActionTypeWithLiterals;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ActionTypeWithLiterals = ActionType | 'UNKNOWN_ACTION_TYPE' | 'VOID' | 'CAPTURE';
interface Chargeback {
    /**
     * Chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    _id?: string;
    /**
     * Date and time the chargeback was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Date and time the chargeback was updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Amount.
     * @readonly
     * @immutable
     */
    amount?: Price;
    /**
     * Reversal amount. Present only when status is REVERSED.
     * @readonly
     */
    reversalAmount?: Price;
    /**
     * Status.
     *
     * Default: `"APPROVED"`.
     */
    status?: ChargebackStatusWithLiterals;
    /**
     * External chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    externalId?: string | null;
}
declare enum ChargebackStatus {
    UNSPECIFIED = "UNSPECIFIED",
    /** Chargeback was approved. */
    APPROVED = "APPROVED",
    /** Chargeback was reversed. */
    REVERSED = "REVERSED"
}
/** @enumType */
type ChargebackStatusWithLiterals = ChargebackStatus | 'UNSPECIFIED' | 'APPROVED' | 'REVERSED';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
interface MembershipPaymentDetails {
    /**
     * Membership ID.
     * @minLength 1
     * @maxLength 100
     */
    membershipId?: string;
    /**
     * ID of the line item this membership applies to.
     * @minLength 1
     * @maxLength 100
     */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatusWithLiterals;
    /** Membership name. */
    name?: MembershipName;
    /**
     * The transaction ID in the membership system. Can be used to void the transaction.
     * @minLength 1
     * @maxLength 100
     */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * ID of the application providing this payment option.
     * @format GUID
     */
    providerAppId?: string;
}
declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
/** @enumType */
type MembershipPaymentStatusWithLiterals = MembershipPaymentStatus | 'CHARGED' | 'CHARGE_FAILED';
interface MembershipName {
    /**
     * Membership name.
     * @maxLength 100
     */
    original?: string;
    /**
     * Translated membership name. Defaults to `original` when not provided.
     * @maxLength 100
     */
    translated?: string | null;
}
interface WixReceiptInfo {
    /**
     * Receipt ID
     * @format GUID
     */
    receiptId?: string;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface ExternalReceiptInfo {
    /**
     * External receipt ID
     * @maxLength 100
     */
    receiptId?: string | null;
    /**
     * ID of the app providing the receipt
     * @format GUID
     */
    appId?: string | null;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface PaymentNotRefundableDetails {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
}
interface AuthorizeChargeWithSavedPaymentMethodRequest {
    /**
     * Order ID.
     *
     * The order must have a saved payment method associated.
     * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
     * If no saved payment exists, the call will fail.
     * @format GUID
     */
    orderId: string;
    /** Amount to authorize. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
interface DelayedCaptureSettings {
    /** The action to perform on the authorized payment after the specified duration. */
    scheduledAction?: ScheduledActionWithLiterals;
    /**
     * Delay duration before performing the scheduled action.
     * > **Note:** If not set, the payment provider's default period will be used.
     */
    delayDuration?: Duration;
}
declare enum ScheduledAction {
    UNSPECIFIED = "UNSPECIFIED",
    /** Whether payment will be auto-voided when duration passes. */
    VOID = "VOID",
    /** Whether payment will be auto-captured when duration passes. */
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ScheduledActionWithLiterals = ScheduledAction | 'UNSPECIFIED' | 'VOID' | 'CAPTURE';
interface Duration {
    /**
     * Amount of units. For example, 30 MINUTES, 1 HOURS, 7 DAYS, etc
     * @min 1
     */
    count?: number;
    /** Duration unit: MINUTES, HOURS and DAYS */
    unit?: DurationUnitWithLiterals;
}
declare enum DurationUnit {
    UNKNOWN_DURATION_UNIT = "UNKNOWN_DURATION_UNIT",
    MINUTES = "MINUTES",
    HOURS = "HOURS",
    DAYS = "DAYS"
}
/** @enumType */
type DurationUnitWithLiterals = DurationUnit | 'UNKNOWN_DURATION_UNIT' | 'MINUTES' | 'HOURS' | 'DAYS';
interface AuthorizeChargeWithSavedPaymentMethodResponse {
    /** Authorized payment. */
    payment?: Payment;
    /** Order transactions updated with authorized payment. */
    orderTransactions?: OrderTransactions;
}
interface VoidAuthorizedPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of the authorized payments to void.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
interface VoidAuthorizedPaymentsResponse {
    /** Order transactions updated with voided payment. */
    orderTransactions?: OrderTransactions;
}
interface CaptureAuthorizedPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * List payment IDs and amounts to capture.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
interface PaymentCapture {
    /**
     * ID of the payment to capture.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Capture amount.
     *
     * > **Note:** If not provided, the full authorized amount will be captured.
     */
    amount?: Price;
}
interface CaptureAuthorizedPaymentsResponse {
    /** Order transactions updated with captured payment. */
    orderTransactions?: OrderTransactions;
}
interface GenerateReceiptsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment IDs.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
interface GenerateReceiptsResponse {
    /** Generated receipts information. */
    receipts?: ReceiptInfo[];
}
interface ReceiptInfo {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Receipt ID.
     * @format GUID
     */
    receiptId?: string;
}
interface RedeemGiftCardRequest {
    /**
     * ID of the order to pay for with the gift card.
     * @format GUID
     */
    orderId: string;
    /**
     * Code of the gift card to redeem.
     * @minLength 8
     * @maxLength 20
     */
    giftCardCode: string;
    /** Amount to redeem from the gift card. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
}
interface RedeemGiftCardResponse {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** Gift card payment. */
    payment?: Payment;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
/** @docsIgnore */
type RefundPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'LINE_ITEM_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ADDITIONAL_FEE_NOT_FOUND';
    description?: string;
    data?: AdditionalFeeRefund;
} | {
    code?: 'SHIPPING_NOT_FOUND';
    description?: string;
    data?: ShippingRefund;
} | {
    code?: 'INVALID_PAYMENT_REFUND_AMOUNT';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'INVALID_ADDITIONAL_FEE_REFUND_AMOUNT';
    description?: string;
    data?: AdditionalFeeRefund;
} | {
    code?: 'INVALID_SHIPPING_REFUND_AMOUNT';
    description?: string;
    data?: ShippingRefund;
} | {
    code?: 'INVALID_LINE_ITEM_REFUND_QUANTITY';
    description?: string;
    data?: LineItemRefund;
} | {
    code?: 'INVALID_LINE_ITEM_RESTOCK_QUANTITY';
    description?: string;
    data?: RestockItem;
} | {
    code?: 'PAYMENT_NOT_REFUNDABLE';
    description?: string;
    data?: PaymentNotRefundableDetails;
} | {
    code?: 'EXTERNAL_REFUND_EXPECTED';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'PARTIAL_REFUND_FOR_MULTIPLE_LOCATIONS_NOT_ALLOWED';
    description?: string;
    data?: RestockItem;
};
/** @docsIgnore */
type AuthorizeChargeWithSavedPaymentMethodApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANCELED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_PAID';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'NO_SAVED_PAYMENT_METHOD';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_AMOUNT';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_CURRENCY';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type VoidAuthorizedPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GATEWAY_TRANSACTION_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_ALREADY_VOIDED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_ALREADY_CAPTURED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CaptureAuthorizedPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'INVALID_AMOUNT';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_ALREADY_VOIDED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_ALREADY_CAPTURED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_NOT_AUTHORIZED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_HAS_PENDING_CAPTURE';
    description?: string;
    data?: PaymentCapture;
};
/** @docsIgnore */
type GenerateReceiptsApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECEIPT_ALREADY_EXIST';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECEIPT_GENERATION_IN_PROGRESS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_PAYMENT_TYPE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_PAYMENT_STATUS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type RedeemGiftCardApplicationErrors = {
    code?: 'GIFT_CARD_ALREADY_APPLIED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CURRENCY_MISMATCH';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_EXPIRED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_DISABLED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INSUFFICIENT_FUNDS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CURRENCY_NOT_SUPPORTED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ALREADY_REDEEMED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANCELED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_PAID';
    description?: string;
    data?: Record<string, any>;
};
/**
 * Retrieves refund information about an order's payments, line items, shipping, and additional fees.
 *
 * The following information is returned:
 * - Whether a payment is refundable; previously refunded amounts; possible refund amounts for each payment.
 * - Refundable and previously refunded quantities for each line item, as well as shipping and additional fees.
 * @param orderId - Order ID.
 * @public
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_GET_ORDER_REFUNDABILITY
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.GetOrderRefundability
 */
declare function getOrderRefundability(orderId: string): Promise<NonNullablePaths<GetOrderRefundabilityResponse, `payments` | `payments.${number}.refundable` | `payments.${number}.manuallyRefundable.reason` | `payments.${number}.nonRefundable.reason` | `payments.${number}.payment.paymentId` | `payments.${number}.payment.offlinePayment` | `paymentsSummary.monetary.paid.amount` | `paymentsSummary.monetary.paid.formattedAmount` | `paymentsSummary.membership.paidLineItemIds` | `paymentsSummary.membership.refundedLineItemIds` | `paymentsSummary.membership.refundableLineItemIds` | `lineItems` | `lineItems.${number}.lineItemId` | `lineItems.${number}.originalQuantity` | `lineItems.${number}.refundedQuantity` | `lineItems.${number}.availableRefundQuantity` | `shipping.amount.amount` | `shipping.amount.formattedAmount` | `additionalFees` | `additionalFees.${number}.additionalFeeId` | `additionalFees.${number}.amount.amount` | `additionalFees.${number}.amount.formattedAmount`, 5>>;
/**
 * Calculates refund amounts for a given list of an order's line items, shipping, and additional fees.
 * @param orderId - Order ID.
 * @public
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CALCULATE_REFUND
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CalculateRefund
 */
declare function calculateRefund(orderId: string, options?: NonNullablePaths<CalculateRefundOptions, `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity`, 5>): Promise<NonNullablePaths<CalculateRefundResponse, `available` | `notAvailable.errors` | `notAvailable.errors.${number}.lineItem.lineItemId` | `notAvailable.errors.${number}.lineItem.quantity` | `notAvailable.errors.${number}.additionalFee.additionalFeeId` | `notAvailable.errors.${number}.additionalFee.amount.amount` | `notAvailable.errors.${number}.additionalFee.amount.formattedAmount` | `notAvailable.errors.${number}.error.applicationError.code` | `notAvailable.errors.${number}.error.applicationError.description` | `summary.total.amount` | `summary.total.formattedAmount` | `calculatedRefundItems.lineItems` | `calculatedRefundItems.lineItems.${number}.item.lineItemId` | `calculatedRefundItems.lineItems.${number}.item.quantity` | `calculatedRefundItems.lineItems.${number}.summary.total.amount` | `calculatedRefundItems.lineItems.${number}.summary.total.formattedAmount` | `calculatedRefundItems.additionalFees` | `calculatedRefundItems.additionalFees.${number}.additionalFee.additionalFeeId`, 7>>;
interface CalculateRefundOptions {
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
/**
 * Calls relevant payment providers and creates refund transactions for the requested payments.
 *
 * Refunds marked with `paymentRefunds.externalRefund = true` do not call payment providers and
 * only update the order's transactions records.
 * @param orderId - Order ID.
 * @public
 * @requiredField options.paymentRefunds
 * @requiredField options.paymentRefunds.paymentId
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField options.sideEffects.restock.lineItems.lineItemId
 * @requiredField options.sideEffects.restock.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_REFUND_PAYMENTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.RefundPayments
 */
declare function refundPayments(orderId: string, options?: NonNullablePaths<RefundPaymentsOptions, `paymentRefunds` | `paymentRefunds.${number}.paymentId` | `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity` | `sideEffects.restock.lineItems.${number}.lineItemId` | `sideEffects.restock.lineItems.${number}.quantity`, 6>): Promise<NonNullablePaths<RefundPaymentsResponse, `refund._id` | `refund.transactions` | `refund.transactions.${number}.paymentId` | `refund.transactions.${number}.amount.amount` | `refund.transactions.${number}.amount.formattedAmount` | `refund.transactions.${number}.refundStatus` | `refund.transactions.${number}.externalRefund` | `refund.details.items` | `refund.details.items.${number}.lineItemId` | `refund.details.items.${number}.quantity` | `refund.details.shippingIncluded` | `refund.details.lineItems` | `refund.details.lineItems.${number}.lineItemId` | `refund.details.lineItems.${number}.quantity` | `refund.details.additionalFees` | `refund.details.additionalFees.${number}.additionalFeeId` | `refund.summary.pending` | `refund.summary.breakdown.lineItems` | `refund.summary.breakdown.lineItems.${number}.lineItemId` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
    __applicationErrorsType?: RefundPaymentsApplicationErrors;
}>;
interface RefundPaymentsOptions {
    /**
     * List of payments and their amounts to refund.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /**
     * Customer-provided reason for the refund.
     * @maxLength 200
     */
    customerReason?: string | null;
}
/**
 * Authorizes a payment using an order's saved payment method.
 *
 * Use the `delayedCaptureSettings` field to specify whether the payment should also be captured/voided immediately or at a later time.
 * Alternatively, the payment can be manually captured or voided using the Capture Authorized Payments or Void Authorized Payments methods.
 * @param orderId - Order ID.
 *
 * The order must have a saved payment method associated.
 * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
 * If no saved payment exists, the call will fail.
 * @public
 * @requiredField options
 * @requiredField options.amount
 * @requiredField options.amount.amount
 * @requiredField options.currency
 * @requiredField options.delayedCaptureSettings
 * @requiredField options.delayedCaptureSettings.scheduledAction
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_AUTHORIZE_CHARGE_WITH_SAVED_PAYMENT_METHOD
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.AuthorizeChargeWithSavedPaymentMethod
 */
declare function authorizeChargeWithSavedPaymentMethod(orderId: string, options: NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodOptions, `amount` | `amount.amount` | `currency` | `delayedCaptureSettings` | `delayedCaptureSettings.scheduledAction`, 3>): Promise<NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodResponse, `payment.regularPaymentDetails.offlinePayment` | `payment.regularPaymentDetails.status` | `payment.regularPaymentDetails.savedPaymentMethod` | `payment.regularPaymentDetails.authorizationDetails.delayedCapture` | `payment.regularPaymentDetails.authorizationDetails.captures` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.status` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.amount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.formattedAmount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.failureDetails.failureCode` | `payment.regularPaymentDetails.authorizationDetails.void.status` | `payment.regularPaymentDetails.authorizationDetails.void.reason` | `payment.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `payment.regularPaymentDetails.chargebacks` | `payment.regularPaymentDetails.chargebacks.${number}._id` | `payment.regularPaymentDetails.chargebacks.${number}.status` | `payment.giftcardPaymentDetails.giftCardPaymentId` | `payment.giftcardPaymentDetails.appId` | `payment.giftcardPaymentDetails.voided` | `payment.refundDisabled` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 8> & {
    __applicationErrorsType?: AuthorizeChargeWithSavedPaymentMethodApplicationErrors;
}>;
interface AuthorizeChargeWithSavedPaymentMethodOptions {
    /** Amount to authorize. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
/**
 * Voids an order's authorized payments.
 * @param orderId - Order ID.
 * @public
 * @requiredField options
 * @requiredField options.paymentIds
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_VOID_AUTHORIZED_PAYMENTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.VoidAuthorizedPayments
 */
declare function voidAuthorizedPayments(orderId: string, options: NonNullablePaths<VoidAuthorizedPaymentsOptions, `paymentIds`, 2>): Promise<NonNullablePaths<VoidAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
    __applicationErrorsType?: VoidAuthorizedPaymentsApplicationErrors;
}>;
interface VoidAuthorizedPaymentsOptions {
    /**
     * IDs of the authorized payments to void.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
/**
 * Captures an order's authorized payments.
 * @param orderId - Order ID.
 * @public
 * @requiredField options
 * @requiredField options.payments
 * @requiredField options.payments.paymentId
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CAPTURE_AUTHORIZED_PAYMENTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CaptureAuthorizedPayments
 */
declare function captureAuthorizedPayments(orderId: string, options: NonNullablePaths<CaptureAuthorizedPaymentsOptions, `payments` | `payments.${number}.paymentId`, 4>): Promise<NonNullablePaths<CaptureAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
    __applicationErrorsType?: CaptureAuthorizedPaymentsApplicationErrors;
}>;
interface CaptureAuthorizedPaymentsOptions {
    /**
     * List payment IDs and amounts to capture.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
interface GenerateReceiptsOptions {
    /**
     * Payment IDs.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
interface RedeemGiftCardOptions {
    /**
     * Code of the gift card to redeem.
     * @minLength 8
     * @maxLength 20
     */
    giftCardCode: string;
    /** Amount to redeem from the gift card. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
}

export { type ActionEvent, ActionType, type ActionTypeWithLiterals, type AdditionalFeeRefund, type AdditionalFeeRefundability, type AggregatedRefundSummary, type ApplicationError, type AuthorizationActionFailureDetails, type AuthorizationCapture, AuthorizationCaptureStatus, type AuthorizationCaptureStatusWithLiterals, type AuthorizationDetails, type AuthorizationVoid, AuthorizationVoidStatus, type AuthorizationVoidStatusWithLiterals, type AuthorizeChargeWithSavedPaymentMethodApplicationErrors, type AuthorizeChargeWithSavedPaymentMethodOptions, type AuthorizeChargeWithSavedPaymentMethodRequest, type AuthorizeChargeWithSavedPaymentMethodResponse, type CalculateRefundOptions, type CalculateRefundRequest, type CalculateRefundResponse, type CalculateRefundResponseStatusOneOf, type CalculatedAdditionalFeeRefund, type CalculatedLineItemRefund, type CalculatedRefundItems, type CalculatedRefundNotAvailableStatus, type CalculatedRefundSummary, type CalculatedShippingRefund, type CalculationError, type CalculationErrorItemOneOf, type CaptureAuthorizedPaymentsApplicationErrors, type CaptureAuthorizedPaymentsOptions, type CaptureAuthorizedPaymentsRequest, type CaptureAuthorizedPaymentsResponse, type Chargeback, ChargebackStatus, type ChargebackStatusWithLiterals, type CreditCardPaymentMethodDetails, type DelayedCaptureSettings, type Details, type DetailsKindOneOf, type DomainEvent, type DomainEventBodyOneOf, type Duration, DurationUnit, type DurationUnitWithLiterals, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type ExternalReceiptInfo, type ExternalRefundInfo, ExternalRefundStatus, type ExternalRefundStatusWithLiterals, type FieldViolation, type GenerateReceiptsApplicationErrors, type GenerateReceiptsOptions, type GenerateReceiptsRequest, type GenerateReceiptsResponse, type GetOrderRefundabilityRequest, type GetOrderRefundabilityResponse, type GiftCardPaymentDetails, type LineItemRefund, type LineItemRefundSummary, type LineItemRefundability, type ManuallyRefundablePaymentStatus, ManuallyRefundableReason, type ManuallyRefundableReasonWithLiterals, type MembershipName, type MembershipPaymentDetails, MembershipPaymentStatus, type MembershipPaymentStatusWithLiterals, type MembershipPaymentSummary, type MonetaryPaymentSummary, type NonRefundablePaymentStatus, NonRefundableReason, type NonRefundableReasonWithLiterals, type NotificationSideEffects, type OrderBilling, type OrderTransactions, type Payment, type PaymentCapture, type PaymentInfo, type PaymentInfoPaymentMethodDetailsOneOf, type PaymentInfoSummaryOneOf, type PaymentNotRefundableDetails, type PaymentPaymentDetailsOneOf, type PaymentReceiptInfoOneOf, type PaymentRefund, type PaymentRefundability, type PaymentRefundabilityStatusOneOf, type PaymentsSummary, type Price, Reason, type ReasonWithLiterals, type ReceiptInfo, type RedeemGiftCardApplicationErrors, type RedeemGiftCardOptions, type RedeemGiftCardRequest, type RedeemGiftCardResponse, type Refund, type RefundDetails, type RefundItem, type RefundItems, type RefundItemsBreakdown, type RefundPaymentsApplicationErrors, type RefundPaymentsOptions, type RefundPaymentsRequest, type RefundPaymentsResponse, type RefundSideEffects, RefundStatus, type RefundStatusInfo, type RefundStatusWithLiterals, type RefundTransaction, type RegularPaymentDetails, type RegularPaymentDetailsPaymentMethodDetailsOneOf, type RestockItem, type RestockSideEffects, type RestoreInfo, RuleType, type RuleTypeWithLiterals, ScheduledAction, type ScheduledActionWithLiterals, type ShippingRefund, type ShippingRefundability, type SystemError, TransactionStatus, type TransactionStatusWithLiterals, type V1AdditionalFeeRefund, type V1AggregatedRefundSummary, type V1LineItemRefund, type V1ScheduledAction, type V1ShippingRefund, type ValidationError, type VoidAuthorizedPaymentsApplicationErrors, type VoidAuthorizedPaymentsOptions, type VoidAuthorizedPaymentsRequest, type VoidAuthorizedPaymentsResponse, type WixReceiptInfo, authorizeChargeWithSavedPaymentMethod, calculateRefund, captureAuthorizedPayments, getOrderRefundability, refundPayments, voidAuthorizedPayments };
