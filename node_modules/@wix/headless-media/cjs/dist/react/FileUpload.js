import { useService } from "@wix/services-manager-react";
import { FileUploadServiceDefinition, } from "../services/index.js";
/**
 * FileSelector - Handles file selection via drag & drop or file input
 */
export const FileSelector = (props) => {
    const service = useService(FileUploadServiceDefinition);
    const selectedFile = service.selectedFile.get();
    const previewUrl = service.previewUrl.get();
    const dragOver = service.dragOver.get();
    const handleDragOver = (event) => {
        event.preventDefault();
        service.setDragOver(true);
    };
    const handleDragLeave = (event) => {
        event.preventDefault();
        service.setDragOver(false);
    };
    const handleDrop = (event) => {
        event.preventDefault();
        service.setDragOver(false);
        const files = event.dataTransfer?.files;
        if (files && files.length > 0) {
            service.selectFile(files[0]);
        }
    };
    const handleFileSelect = (event) => {
        const files = event.target.files;
        if (files && files.length > 0) {
            service.selectFile(files[0]);
        }
    };
    const canPreview = selectedFile ? service.canPreview(selectedFile) : false;
    return props.children({
        selectedFile,
        previewUrl,
        dragOver,
        selectFile: service.selectFile,
        clearFile: service.clearFile,
        handleDragOver,
        handleDragLeave,
        handleDrop,
        handleFileSelect,
        canPreview,
    });
};
/**
 * UploadProgress - Shows upload status and progress
 */
export const UploadProgress = (props) => {
    const service = useService(FileUploadServiceDefinition);
    const uploadState = service.uploadState.get();
    return props.children({
        uploadState,
        isLoading: uploadState.type === "loading",
        isSuccess: uploadState.type === "success",
        isError: uploadState.type === "error",
        hasError: uploadState.type === "error",
        hasMessage: uploadState.message !== "",
    });
};
/**
 * UploadTrigger - Handles file upload action
 */
export const UploadTrigger = (props) => {
    const service = useService(FileUploadServiceDefinition);
    const selectedFile = service.selectedFile.get();
    const uploadState = service.uploadState.get();
    const canUpload = selectedFile !== null && uploadState.type !== "loading";
    const isUploading = uploadState.type === "loading";
    return props.children({
        uploadFile: service.uploadFile,
        canUpload,
        isUploading,
    });
};
/**
 * FilePreview - Displays preview information for the selected file
 */
export const FilePreview = (props) => {
    const service = useService(FileUploadServiceDefinition);
    const selectedFile = service.selectedFile.get();
    const previewUrl = service.previewUrl.get();
    const canPreview = selectedFile ? service.canPreview(selectedFile) : false;
    const hasPreview = previewUrl !== null;
    const formatFileSize = (bytes) => {
        if (bytes === 0)
            return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    return props.children({
        selectedFile,
        previewUrl,
        hasPreview,
        canPreview,
        fileName: selectedFile?.name || "",
        fileSize: selectedFile?.size || 0,
        formattedFileSize: selectedFile ? formatFileSize(selectedFile.size) : "",
        fileType: selectedFile?.type || "",
    });
};
/**
 * ValidationStatus - Shows file validation status and rules
 */
export const ValidationStatus = (props) => {
    const service = useService(FileUploadServiceDefinition);
    const selectedFile = service.selectedFile.get();
    const fileToValidate = props.file || selectedFile;
    const validationResult = fileToValidate
        ? service.validateFile(fileToValidate)
        : { isValid: true, error: undefined };
    return props.children({
        isValid: validationResult.isValid,
        error: validationResult.error,
        validationRules: service.validationRules,
    });
};
