import { SearchSpec, Search as Search$1, NonNullablePaths } from '@wix/sdk-types';

interface AbandonedCheckout {
    /**
     * Abandoned checkout ID.
     * @format GUID
     */
    _id?: string;
    /** Date and time the abandoned checkout was created. */
    _createdDate?: Date | null;
    /** Date and time the abandoned checkout was updated. */
    _updatedDate?: Date | null;
    /**
     * The associated checkout ID.
     * @format GUID
     */
    checkoutId?: string | null;
    /**
     * The associated cart ID.
     * @format GUID
     */
    cartId?: string | null;
    /** Status of the abandoned checkout. */
    status?: StatusWithLiterals;
    /**
     * Language for communication with the buyer. Defaults to the site language.
     * For a site that supports multiple languages, this is the language the buyer selected.
     */
    buyerLanguage?: string | null;
    /** Buyer information. */
    buyerInfo?: V1BuyerInfo;
    /** Contact details. */
    contactDetails?: FullAddressContactDetails;
    /**
     * The store's currency.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Currency the buyer used in checkout.
     * @format CURRENCY
     */
    conversionCurrency?: string | null;
    /** Total price after discounts, gift cards, and tax. */
    totalPrice?: MultiCurrencyPrice;
    /**
     * List of all automation activities performed by [Wix Automations](https://dev.wix.com/docs/rest/business-management/automations/introduction) regarding the abandoned checkout.
     * Wix Automations updates the `activities` field for each activity in the automation flow. Only relevant if you've set up [automations in the Dashboard](https://support.wix.com/en/article/wix-automations-creating-a-new-automation). Read more about `activities` in the [introduction](https://www.wix.com/velo/reference/wix-ecom-backend/abandonedcheckout/introduction).
     */
    activities?: Activity[];
    /** Date and time the abandoned checkout was recovered. */
    checkoutRecoveredDate?: Date | null;
    /**
     * Checkout URL.
     * @format WEB_URL
     */
    checkoutUrl?: string;
    /** Subtotal price of all line items, before discounts and before tax. */
    subtotalPrice?: MultiCurrencyPrice;
}
declare enum ActivityType {
    /** Not implemented. */
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    /** Scheduled. */
    SCHEDULED = "SCHEDULED",
    /** Email sent. */
    EMAIL_SENT = "EMAIL_SENT",
    /** Email not sent. */
    EMAIL_NOT_SENT = "EMAIL_NOT_SENT",
    /** Notification sent. */
    NOTIFICATION_SENT = "NOTIFICATION_SENT",
    /** Task created. */
    TASK_CREATED = "TASK_CREATED"
}
/** @enumType */
type ActivityTypeWithLiterals = ActivityType | 'UNKNOWN_TYPE' | 'SCHEDULED' | 'EMAIL_SENT' | 'EMAIL_NOT_SENT' | 'NOTIFICATION_SENT' | 'TASK_CREATED';
/** Status of the abandoned checkout. */
declare enum Status {
    /** Abandoned. */
    ABANDONED = "ABANDONED",
    /** Recovered. */
    RECOVERED = "RECOVERED"
}
/** @enumType */
type StatusWithLiterals = Status | 'ABANDONED' | 'RECOVERED';
/** Buyer information. */
interface V1BuyerInfo extends V1BuyerInfoIdOneOf {
    /**
     * Visitor ID (if the site visitor is **not** a site member).
     * @format GUID
     */
    visitorId?: string;
    /**
     * Member ID (if the site visitor is a site member).
     * @format GUID
     */
    memberId?: string;
    /**
     * User ID (if the site visitor is a site owner or collaborator).
     * @format GUID
     */
    userId?: string;
    /**
     * Contact ID. For more information, see the [Contacts API](https://www.wix.com/velo/reference/wix-crm-v2/contacts).
     * @format GUID
     * @readonly
     */
    contactId?: string | null;
    /**
     * Buyer email address.
     * Max: `50`
     * @maxLength 50
     * @format EMAIL
     */
    email?: string | null;
}
/** @oneof */
interface V1BuyerInfoIdOneOf {
    /**
     * Visitor ID (if the site visitor is **not** a site member).
     * @format GUID
     */
    visitorId?: string;
    /**
     * Member ID (if the site visitor is a site member).
     * @format GUID
     */
    memberId?: string;
    /**
     * User ID (if the site visitor is a site owner or collaborator).
     * @format GUID
     */
    userId?: string;
}
/** Full contact details for an address */
interface FullAddressContactDetails {
    /**
     * First name.
     * Max length: `100`
     * @maxLength 100
     */
    firstName?: string | null;
    /**
     * Last name.
     * Max length: `100`
     * @maxLength 100
     */
    lastName?: string | null;
    /**
     * Phone number.
     * @format PHONE
     */
    phone?: string | null;
    /**
     * Company name.
     * Max length: `50`
     * @maxLength 1000
     */
    company?: string | null;
    /** Tax information (for Brazil only). If ID is provided, `vatId.type` must also be set, `UNSPECIFIED` is not allowed. */
    vatId?: VatId;
}
interface VatId {
    /** Customer's tax ID. */
    _id?: string;
    /**
     * Tax type.
     *
     * Supported values:
     * + `CPF`: for individual tax payers
     * + `CNPJ`: for corporations
     */
    type?: VatTypeWithLiterals;
}
/** tax info types */
declare enum VatType {
    UNSPECIFIED = "UNSPECIFIED",
    /** CPF - for individual tax payers. */
    CPF = "CPF",
    /** CNPJ - for corporations */
    CNPJ = "CNPJ"
}
/** @enumType */
type VatTypeWithLiterals = VatType | 'UNSPECIFIED' | 'CPF' | 'CNPJ';
interface MultiCurrencyPrice {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Converted amount.
     * @readonly
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    convertedAmount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
    /**
     * Converted amount formatted with currency symbol.
     * @readonly
     */
    formattedConvertedAmount?: string;
}
interface Activity {
    /** Date and time the automation activity was created. */
    _createdDate?: Date | null;
    /**
     * Automation activity type.
     *
     * Supported properties: `UNKNOWN_TYPE`, `SCHEDULED`, `EMAIL_SENT`, `EMAIL_NOT_SENT`, `NOTIFICATION_SENT`, `TASK_CREATED`
     */
    type?: ActivityTypeWithLiterals;
}
interface CartAbandonedEvent {
    /** @format GUID */
    cartId?: string;
    /**
     * Time the cart was created
     * @readonly
     */
    creationTime?: Date | null;
    /**
     * Time the cart was abandoned
     * @readonly
     */
    abandonTime?: Date | null;
    /** Buyer information */
    buyerInfo?: BuyerInfo;
    /** Amount of items in cart */
    itemsCount?: number;
    /** Coupon ID (if relevant) */
    couponId?: string;
    /** Subtotal of all line items in cart, not before shipping and taxes */
    totals?: Totals;
    /**
     * Checkout URL - checkout with the abandoned cart details
     * @format WEB_URL
     */
    checkoutUrl?: string;
}
interface BuyerInfo {
    /**
     * Wix customer ID
     * @format GUID
     */
    _id?: string;
    /** Customer information */
    identityType?: IdentityWithLiterals;
    /**
     * Customer's email address
     * @maxLength 50
     * @format EMAIL
     */
    email?: string | null;
    /**
     * Customer's phone number
     * @format PHONE
     */
    phone?: string | null;
    /** Customer's first name */
    firstName?: string | null;
    /** Customer's last name */
    lastName?: string | null;
}
declare enum Identity {
    /** Customer is the site owner */
    ADMIN = "ADMIN",
    /** Customer is logged in */
    MEMBER = "MEMBER",
    /** Customer is not logged in */
    VISITOR = "VISITOR",
    /** Contact was created for the customer */
    CONTACT = "CONTACT"
}
/** @enumType */
type IdentityWithLiterals = Identity | 'ADMIN' | 'MEMBER' | 'VISITOR' | 'CONTACT';
interface Totals {
    /**
     * Subtotal of all line items in cart, without shipping and taxes
     * @max 999999999.99
     */
    subtotal?: number | null;
    /**
     * Total cart price
     * @max 999999999.99
     */
    total?: number | null;
    /** Formatted total cart price includes currency symbol */
    formattedTotal?: string;
}
interface CartRecoveredEvent {
    /** @format GUID */
    cartId?: string;
    /**
     * Time the cart was recovered
     * @readonly
     */
    recoveredTime?: Date | null;
    /**
     * Time the cart was created
     * @readonly
     */
    creationTime?: Date | null;
    /**
     * Time the cart was abandoned
     * @readonly
     */
    abandonedTime?: Date | null;
}
/** Triggered when an abandoned checkout is recovered (the customer completes the checkout). */
interface AbandonedCheckoutRecovered {
    /** The abandoned checkout that was recovered. */
    abandonedCheckout?: AbandonedCheckout;
}
interface GetAbandonedCheckoutRequest {
    /**
     * Abandoned checkout ID.
     * @format GUID
     */
    abandonedCheckoutId: string;
}
interface GetAbandonedCheckoutResponse {
    /** The requested abandoned checkout. */
    abandonedCheckout?: AbandonedCheckout;
}
interface DeleteAbandonedCheckoutRequest {
    /**
     * Id of the abandoned checkout to delete
     * @format GUID
     */
    abandonedCheckoutId: string;
}
interface DeleteAbandonedCheckoutResponse {
}
interface QueryAbandonedCheckoutsRequest {
    /** Query options. */
    query: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryAbandonedCheckoutsResponse {
    /**
     * __Deprecated.__ Use `abandonedCheckouts` instead.
     * @deprecated
     */
    results?: AbandonedCheckout[];
    /** List of abandoned checkouts. */
    abandonedCheckouts?: AbandonedCheckout[];
    /** Details on the paged set of results returned. */
    metadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface SearchAbandonedCheckoutsRequest {
    /** Search options. */
    search?: Search;
}
interface Search extends SearchPagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: CommonPaging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
    cursorPaging?: CommonCursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 4
     */
    sort?: CommonSorting[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
/** @oneof */
interface SearchPagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: CommonPaging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
    cursorPaging?: CommonCursorPaging;
}
interface CommonSorting {
    /**
     * Name of the field to sort by.
     * @maxLength 40
     */
    fieldName?: string;
    /** Sort order. */
    order?: CommonSortOrderWithLiterals;
}
declare enum CommonSortOrder {
    /** Ascending order. */
    ASC = "ASC",
    /** Descending order. */
    DESC = "DESC"
}
/** @enumType */
type CommonSortOrderWithLiterals = CommonSortOrder | 'ASC' | 'DESC';
interface SearchDetails {
    /** Search mode. Defines the search logic for combining multiple terms in the `expression`. */
    mode?: ModeWithLiterals;
    /**
     * Search term or expression.
     * @maxLength 100
     */
    expression?: string | null;
    /**
     * Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
     * @maxLength 100
     * @maxSize 20
     */
    fields?: string[];
    /** Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions. */
    fuzzy?: boolean;
}
declare enum Mode {
    /** At least one of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
/** @enumType */
type ModeWithLiterals = Mode | 'OR' | 'AND';
interface CommonPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CommonCursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface SearchAbandonedCheckoutsResponse {
    /** List of abandoned checkouts. */
    abandonedCheckouts?: AbandonedCheckout[];
    /** Paging metadata. Contains cursor which can be used in next query. */
    pagingMetadata?: CommonPagingMetadataV2;
}
interface CommonPagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: CommonCursors;
}
interface CommonCursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface AddAbandonedCheckoutActivityRequest {
    /**
     * Id of the abandoned checkout to update
     * @format GUID
     */
    abandonedCheckoutId: string | null;
    /** The type of the activity to add */
    activityType?: ActivityTypeWithLiterals;
}
interface AddAbandonedCheckoutActivityResponse {
    /** The updated abandoned checkout with the added activity */
    abandonedCheckout?: AbandonedCheckout;
}
interface Task {
    key?: TaskKey;
    executeAt?: Date | null;
    payload?: string | null;
}
interface TaskKey {
    appId?: string;
    instanceId?: string;
    subjectId?: string | null;
}
interface TaskAction extends TaskActionActionOneOf {
    complete?: Complete;
    cancel?: Cancel;
    reschedule?: Reschedule;
}
/** @oneof */
interface TaskActionActionOneOf {
    complete?: Complete;
    cancel?: Cancel;
    reschedule?: Reschedule;
}
interface Complete {
}
interface Cancel {
}
interface Reschedule {
    executeAt?: Date | null;
    payload?: string | null;
}
interface RedirectToCheckoutRequest {
    /**
     * ID of the abandoned checkout.
     * @format GUID
     */
    abandonedCheckoutId: string;
    /**
     * Metasite ID of the site associated with the abandoned checkout.
     * @format GUID
     */
    metasiteId: string;
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface AbandonedCheckoutCreatedEnvelope {
    entity: AbandonedCheckout;
    metadata: EventMetadata;
}
/**
 * Triggered when an abandoned checkout is created.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.ABANDONED_CHECKOUT_READ
 * @webhook
 * @eventType wix.ecom.v1.abandoned_checkout_created
 * @slug created
 */
declare function onAbandonedCheckoutCreated(handler: (event: AbandonedCheckoutCreatedEnvelope) => void | Promise<void>): void;
interface AbandonedCheckoutDeletedEnvelope {
    metadata: EventMetadata;
}
/**
 * Triggerred when an abandoned checkout is deleted.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.ABANDONED_CHECKOUT_READ
 * @webhook
 * @eventType wix.ecom.v1.abandoned_checkout_deleted
 * @slug deleted
 */
declare function onAbandonedCheckoutDeleted(handler: (event: AbandonedCheckoutDeletedEnvelope) => void | Promise<void>): void;
interface AbandonedCheckoutRecoveredEnvelope {
    data: AbandonedCheckoutRecovered;
    metadata: EventMetadata;
}
/**
 * Triggered when an abandoned checkout is recovered.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.ABANDONED_CHECKOUT_READ
 * @webhook
 * @eventType wix.ecom.v1.abandoned_checkout_recovered
 * @slug recovered
 */
declare function onAbandonedCheckoutRecovered(handler: (event: AbandonedCheckoutRecoveredEnvelope) => void | Promise<void>): void;
interface AbandonedCheckoutUpdatedEnvelope {
    entity: AbandonedCheckout;
    metadata: EventMetadata;
}
/**
 * Triggered when an abandoned checkout is updated.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.ABANDONED_CHECKOUT_READ
 * @webhook
 * @eventType wix.ecom.v1.abandoned_checkout_updated
 * @slug updated
 */
declare function onAbandonedCheckoutUpdated(handler: (event: AbandonedCheckoutUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves an abandoned checkout.
 * @param abandonedCheckoutId - Abandoned checkout ID.
 * @public
 * @requiredField abandonedCheckoutId
 * @permissionId ECOM.ABANDONED_CHECKOUT_READ
 * @applicableIdentity APP
 * @returns The requested abandoned checkout.
 * @fqn wix.ecom.abandoned_checkout.api.v1.AbandonedCheckoutService.GetAbandonedCheckout
 */
declare function getAbandonedCheckout(abandonedCheckoutId: string): Promise<NonNullablePaths<AbandonedCheckout, `_id` | `status` | `buyerInfo.visitorId` | `buyerInfo.memberId` | `buyerInfo.userId` | `contactDetails.vatId._id` | `contactDetails.vatId.type` | `currency` | `totalPrice.amount` | `totalPrice.convertedAmount` | `totalPrice.formattedAmount` | `totalPrice.formattedConvertedAmount` | `activities` | `activities.${number}.type` | `checkoutUrl`, 4>>;
/**
 * Deletes an abandoned checkout.
 * @param abandonedCheckoutId - Id of the abandoned checkout to delete
 * @public
 * @requiredField abandonedCheckoutId
 * @permissionId ECOM.ABANDONED_CHECKOUT_DELETE
 * @applicableIdentity APP
 * @fqn wix.ecom.abandoned_checkout.api.v1.AbandonedCheckoutService.DeleteAbandonedCheckout
 */
declare function deleteAbandonedCheckout(abandonedCheckoutId: string): Promise<void>;
/**
 * Creates a query to retrieve a list of abandoned checkouts.
 *
 * The `queryAbandonedCheckouts()` function builds a query to retrieve a list of abandoned checkouts and returns a `ResultsQueryBuilder` object.
 *
 * The returned object contains the query definition, which is typically used to run the query using the `find()` function.
 *
 * You can refine the query by chaining `ResultsQueryBuilder` functions onto the query. `ResultsQueryBuilder` functions enable you to sort, filter, and control the results `queryAbandonedCheckouts()` returns.
 * @public
 * @permissionId ECOM.ABANDONED_CHECKOUT_READ
 * @applicableIdentity APP
 * @fqn wix.ecom.abandoned_checkout.api.v1.AbandonedCheckoutService.QueryAbandonedCheckouts
 */
declare function queryAbandonedCheckouts(): AbandonedCheckoutsQueryBuilder;
interface QueryCursorResult {
    cursors: CommonCursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface AbandonedCheckoutsQueryResult extends QueryCursorResult {
    items: AbandonedCheckout[];
    query: AbandonedCheckoutsQueryBuilder;
    next: () => Promise<AbandonedCheckoutsQueryResult>;
    prev: () => Promise<AbandonedCheckoutsQueryResult>;
}
interface AbandonedCheckoutsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: '_id' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: string) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any[]) => AbandonedCheckoutsQueryBuilder;
    in: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: any) => AbandonedCheckoutsQueryBuilder;
    exists: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email', value: boolean) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email'>) => AbandonedCheckoutsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | '_createdDate' | '_updatedDate' | 'status' | 'buyerInfo.visitorId' | 'buyerInfo.memberId' | 'buyerInfo.userId' | 'buyerInfo.contactId' | 'buyerInfo.email'>) => AbandonedCheckoutsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => AbandonedCheckoutsQueryBuilder;
    /** @param cursor - A pointer to specific record */
    skipTo: (cursor: string) => AbandonedCheckoutsQueryBuilder;
    find: () => Promise<AbandonedCheckoutsQueryResult>;
}
interface AbandonedCheckoutSearchSpec extends SearchSpec {
    searchable: [
        'buyerInfo.email',
        'contactDetails.firstName',
        'contactDetails.lastName'
    ];
    paging: 'cursor';
    wql: [
        {
            operators: ['$hasAll', '$hasSome'];
            fields: ['activities.type'];
            sort: 'NONE';
        },
        {
            operators: '*';
            fields: ['contactDetails.firstName', 'contactDetails.lastName'];
            sort: 'NONE';
        },
        {
            operators: '*';
            fields: ['_createdDate', '_updatedDate'];
            sort: 'BOTH';
        },
        {
            operators: ['$eq', '$in', '$ne', '$nin'];
            fields: [
                '_id',
                'buyerInfo.contactId',
                'buyerInfo.email',
                'buyerInfo.memberId',
                'buyerInfo.userId',
                'buyerInfo.visitorId',
                'status'
            ];
            sort: 'NONE';
        }
    ];
}
type CommonSearchWithEntityContext = Search$1<AbandonedCheckout, AbandonedCheckoutSearchSpec>;
type AbandonedCheckoutSearch = {
    /**
    Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort.
    */
    cursorPaging?: {
        /**
      Maximum number of items to return in the results.
      @max: 100
      */
        limit?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['limit'] | null;
        /**
      Pointer to the next or previous page in the list of results.
    
      Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
      Not relevant for the first request.
      */
        cursor?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['cursor'] | null;
    };
    /**
    Filter object.
  
    Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
    */
    filter?: CommonSearchWithEntityContext['filter'] | null;
    /**
    Sort object.
  
    Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
    @maxSize: 4
    */
    sort?: {
        /**
      Name of the field to sort by.
      @maxLength: 40
      */
        fieldName?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['fieldName'];
        /**
      Sort order.
      */
        order?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['order'];
    }[];
    /**
    Free text to match in searchable fields.
    */
    search?: {
        /**
      Search mode. Defines the search logic for combining multiple terms in the `expression`.
      */
        mode?: NonNullable<CommonSearchWithEntityContext['search']>['mode'];
        /**
      Search term or expression.
      @maxLength: 100
      */
        expression?: NonNullable<CommonSearchWithEntityContext['search']>['expression'] | null;
        /**
      Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
      @maxLength: 100,
      @maxSize: 20
      */
        fields?: NonNullable<CommonSearchWithEntityContext['search']>['fields'];
        /**
      Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions.
      */
        fuzzy?: NonNullable<CommonSearchWithEntityContext['search']>['fuzzy'];
    };
};
interface AddAbandonedCheckoutActivityOptions {
    /** The type of the activity to add */
    activityType?: ActivityTypeWithLiterals;
}
/**
 * Redirects an abandoned checkout to its checkout page.
 * @param abandonedCheckoutId - ID of the abandoned checkout.
 * @param metasiteId - Metasite ID of the site associated with the abandoned checkout.
 * @public
 * @requiredField abandonedCheckoutId
 * @requiredField metasiteId
 * @fqn wix.ecom.abandoned_checkout.api.v1.AbandonedCheckoutService.RedirectToCheckout
 */
declare function redirectToCheckout(abandonedCheckoutId: string, metasiteId: string): Promise<NonNullablePaths<RawHttpResponse, `body` | `headers` | `headers.${number}.key` | `headers.${number}.value`, 4>>;

export { type TaskKey as $, type AbandonedCheckout as A, type BuyerInfo as B, CommonSortOrder as C, type DeleteAbandonedCheckoutRequest as D, type SearchAbandonedCheckoutsRequest as E, type FullAddressContactDetails as F, type GetAbandonedCheckoutRequest as G, type Search as H, Identity as I, type SearchPagingMethodOneOf as J, type CommonSorting as K, type SearchDetails as L, Mode as M, type CommonPaging as N, type CommonCursorPaging as O, type Paging as P, type QueryAbandonedCheckoutsRequest as Q, type RawHttpResponse as R, type SearchAbandonedCheckoutsResponse as S, type Totals as T, type CommonPagingMetadataV2 as U, VatType as V, WebhookIdentityType as W, type CommonCursors as X, type AddAbandonedCheckoutActivityRequest as Y, type AddAbandonedCheckoutActivityResponse as Z, type Task as _, type AbandonedCheckoutsQueryBuilder as a, type TaskAction as a0, type TaskActionActionOneOf as a1, type Complete as a2, type Cancel as a3, type Reschedule as a4, type RedirectToCheckoutRequest as a5, type HeadersEntry as a6, type DomainEvent as a7, type DomainEventBodyOneOf as a8, type EntityCreatedEvent as a9, getAbandonedCheckout as aA, deleteAbandonedCheckout as aB, queryAbandonedCheckouts as aC, redirectToCheckout as aD, type RestoreInfo as aa, type EntityUpdatedEvent as ab, type EntityDeletedEvent as ac, type ActionEvent as ad, type Empty as ae, type MessageEnvelope as af, type IdentificationData as ag, type IdentificationDataIdOneOf as ah, type BaseEventMetadata as ai, type EventMetadata as aj, type AbandonedCheckoutsQueryResult as ak, type AbandonedCheckoutSearchSpec as al, type AddAbandonedCheckoutActivityOptions as am, type ActivityTypeWithLiterals as an, type StatusWithLiterals as ao, type VatTypeWithLiterals as ap, type IdentityWithLiterals as aq, type SortOrderWithLiterals as ar, type CommonSortOrderWithLiterals as as, type ModeWithLiterals as at, type WebhookIdentityTypeWithLiterals as au, type CommonSearchWithEntityContext as av, onAbandonedCheckoutCreated as aw, onAbandonedCheckoutDeleted as ax, onAbandonedCheckoutRecovered as ay, onAbandonedCheckoutUpdated as az, type AbandonedCheckoutSearch as b, type AbandonedCheckoutCreatedEnvelope as c, type AbandonedCheckoutDeletedEnvelope as d, type AbandonedCheckoutRecoveredEnvelope as e, type AbandonedCheckoutUpdatedEnvelope as f, ActivityType as g, Status as h, SortOrder as i, type V1BuyerInfo as j, type V1BuyerInfoIdOneOf as k, type VatId as l, type MultiCurrencyPrice as m, type Activity as n, type CartAbandonedEvent as o, type CartRecoveredEvent as p, type AbandonedCheckoutRecovered as q, type GetAbandonedCheckoutResponse as r, type DeleteAbandonedCheckoutResponse as s, type QueryV2 as t, type QueryV2PagingMethodOneOf as u, type Sorting as v, type CursorPaging as w, type QueryAbandonedCheckoutsResponse as x, type PagingMetadataV2 as y, type Cursors as z };
