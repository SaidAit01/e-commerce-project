{"version":3,"names":[],"sources":["../../src/types.ts"],"sourcesContent":["import * as React from 'react';\nimport type {\n  AlignType as IAlignType,\n  FittingType as IFittingType,\n  UpscaleMethod,\n  ImageTransformOptions,\n  ImagePlaceholderTransformTarget,\n  Encoding,\n} from '@wix/image-kit';\n\nexport type FittingType = IFittingType;\nexport type AlignType = IAlignType;\n\ntype UnitLength = {\n  value: number;\n  type: 'px' | 'em' | 'rem' | 'vh' | 'vw' | 'vmin' | 'vmax';\n};\n\ntype ImageSharpeningQuality = {\n  quality?: number;\n  unsharpMask?: {\n    radius: number;\n    amount: number;\n    threshold: number;\n  };\n};\n\ntype ImagePlaceholderDataSrc = {\n  id: string;\n  width: number;\n  height: number;\n  crop: Crop;\n  focalPoint?: FocalPoint;\n  name: string;\n};\n\nexport type ImageAttributesData = {\n  uri?: string;\n  css: {\n    img: Record<string, number | string>;\n    container?: Record<string, number | string>;\n  };\n  attr: {\n    img: Record<string, number | string>;\n    container: Record<string, number | string>;\n  };\n  transformed: boolean;\n  srcset?: {\n    dpr: string[];\n  };\n};\n\nexport type ImagePlaceholderData = {\n  fittingType: FittingType;\n  src: ImagePlaceholderDataSrc;\n  target: ImagePlaceholderTransformTarget;\n  options: Partial<ImageTransformOptions>;\n};\n\nexport type PlaceholderTransition = 'blur';\n\nexport type SourceSet = {\n  mediaQuery: string;\n  displayMode: FittingType;\n  crop?: Crop;\n  focalPoint?: FocalPoint;\n  scrollEffect?: 'parallax' | 'fixed' | 'ImageParallax' | 'ImageReveal';\n};\n\nexport type ImageInfo = {\n  containerId?: string;\n  alignType?: AlignType;\n  skipMeasure?: boolean;\n  displayMode: FittingType;\n  targetWidth?: number;\n  targetHeight?: number;\n  targetScale?: number;\n  isLQIP?: boolean;\n  isSEOBot?: boolean;\n  lqipTransition?: PlaceholderTransition;\n  imageData: {\n    width: number;\n    height: number;\n    uri: string;\n    name: string;\n    displayMode: FittingType;\n    quality?: ImageSharpeningQuality;\n    devicePixelRatio?: number;\n    focalPoint?: FocalPoint;\n    crop?: Crop;\n    upscaleMethod?: string;\n    scrollEffect?: 'parallax' | 'fixed';\n    hasAnimation?: boolean;\n  };\n  sourceSets?: SourceSet[];\n  hasAnimation?: boolean;\n  encoding?: Encoding;\n};\n\nexport type ImagePlaceholderProps = {\n  /**\n   * Utility for getting URI and CSS for rendering an image placeholder (LQIP)\n   * @param {Object} data\n   * @returns {Object}\n   */\n  getPlaceholder?: (data: ImagePlaceholderData) => ImageAttributesData;\n  /**\n   * Width of the target element the image will be rendered into\n   */\n  containerWidth?: number;\n  /**\n   * Height of the target element the image will be rendered into\n   */\n  containerHeight?: number;\n};\n\nexport type BaseImageProps = ImagePlaceholderProps & {\n  id?: string;\n  /**\n   * The id of component's parent\n   * Necessary for background effects\n   */\n  containerId?: string;\n  /**\n   * Image uri\n   */\n  uri: string;\n  /**\n   * Image name\n   */\n  name?: string;\n  /**\n   * Original image width\n   */\n  width: number;\n  /**\n   * Original image height\n   */\n  height: number;\n  /**\n   * Image display mode\n   */\n  displayMode: FittingType;\n  /**\n   * Indicates whether image has a scroll effect (BackgroundReveal, BackgroundParallax, BackgroundParallaxZoom etc.)\n   */\n  hasBgScrollEffect?: 'true' | '';\n  /**\n   * Name of background scroll effect\n   */\n  bgEffectName?: string;\n  /**\n   * Holds image quality data\n   */\n  quality?: ImageSharpeningQuality;\n};\n\nexport type ImagePlatformProps = BaseImageProps & {\n  /**\n   * Image alternate text\n   */\n  alt: string;\n  /**\n   * The pixel ratio of the device\n   */\n  devicePixelRatio?: number;\n  /**\n   * Alignment of the image\n   */\n  alignType?: AlignType;\n  /**\n   * Image focalPoint\n   */\n  focalPoint?: FocalPoint;\n  /**\n   * Image title text\n   */\n  title?: string;\n  /**\n   * Image crop\n   */\n  crop?: Crop;\n  /**\n   * Image upscale method\n   */\n  upscaleMethod?: UpscaleMethod;\n};\n\nexport type FocalPoint = {\n  x: number;\n  y: number;\n};\n\nexport type Crop = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  svgId?: string;\n  flip?: 'vertical' | 'horizontal' | 'both' | 'none';\n  rotate?: number;\n};\n\nexport type ImageProps = ImagePlatformProps & {\n  targetWidth?: number;\n  targetHeight?: number;\n  targetScale?: number;\n  className?: string;\n  role?: string;\n  crop?: any;\n  bgEffectName?: string;\n  upscaleMethod?: UpscaleMethod;\n  imageStyles?: { [key: string]: string } | {};\n  onLoad?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\n  onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\n  shouldUseLQIP?: boolean;\n  getPlaceholder?: (data: any) => any;\n  containerWidth?: number;\n  containerHeight?: number;\n  isInFirstFold?: boolean;\n  placeholderTransition?: PlaceholderTransition;\n  socialAttrs?: SocialAttributes;\n  isSEOBot?: boolean;\n  skipMeasure?: boolean;\n  filterEffectSvgString?: string;\n  filterEffectSvgUrl?: string;\n  hasAnimation?: boolean;\n  encoding?: Encoding;\n};\n\nexport type WixImageExternalServices = {\n  mutationService?: any;\n  isExperimentOpen?: (experimentName: string) => boolean;\n  getMediaDimensionsByEffect?: any;\n  disableImagesLazyLoading?: boolean;\n  getScreenHeightOverride?: () => number;\n};\n\nexport type WixImageServices = WixImageExternalServices & {\n  imageLoader: any;\n  resizeService?: ResizeObserver;\n  intersectionService?: IntersectionObserver;\n};\n\nexport type WixImageMeasures = {\n  width?: number;\n  height?: number;\n  screenHeight?: number;\n  imgSrc?: string | null;\n  boundingRect?: DOMRect;\n  mediaHeightOverrideType?: 'viewport' | 'fixed' | '';\n  sourceSetsTargetHeights?: { [key: string]: number };\n  srcset?: string;\n  top?: number;\n  left?: number;\n};\n\nexport type WixImageXMeasures = WixImageMeasures & {\n  documentScroll: number;\n};\n\nexport type WixImageDomNodes = Record<\n  string,\n  HTMLElement | HTMLImageElement | null\n>;\n\nexport type SocialAttributes = {\n  'data-pin-nopin'?: boolean | undefined;\n  'data-pin-url'?: string;\n  'data-pin-media'?: string;\n};\n\nexport type ImagePresets = {\n  [key: string]: {\n    uri: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type EnvConsts = {\n  disableImagesLazyLoading?: boolean;\n  staticMediaUrl: string;\n  mediaRootUrl: string;\n  isViewerMode: boolean;\n  experiments?: Record<string, string | boolean>;\n  devicePixelRatio?: number;\n};\n\nexport type WowImage = Element & {\n  reLayout: () => void;\n  observeIntersect: () => void;\n  unobserveIntersect: () => void;\n  observeResize: () => void;\n  unobserveResize: () => void;\n};\n\n// TODO(ameerabuf) - is this enough?\nexport type MediaSizeQuery = {\n  minWidth?: number;\n  maxWidth?: number;\n  minHeight?: number;\n  maxHeight?: number;\n};\n\n/* image's content data */\nexport type ImageMedia = {\n  /* URI to fetch image from. for external content use a URL. */\n  uri: string;\n  /* Human-readable image filename. */\n  name?: string;\n  /* full width of original image in pixels. */\n  width: number;\n  /* full height of original image in pixels. */\n  height: number;\n  /* whether the image is of animated format (animated-WebP/AVIF/GIF). */\n  animated?: boolean;\n  /* crop data for the image. TODO(ameerabuf) - currently implemented in percentages, maybe use absolute pixxels? */\n  crop?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  quality?: number;\n};\n\n/* data required for rendering the inner source HTML elements in ImageNg */\nexport type ImageSource = {\n  /* image's content data */\n  image: ImageMedia;\n  /* data for media attribute to render. currently supports only min/max-width/height. */\n  media?: MediaSizeQuery;\n  /* data for sizes attribute to render. when the layout of the containing element is known, this data should\n     reflect its width in the relevant breakpoints. */\n  sizes: {\n    /* the media query to test for using this size. relevant only if within the bounds of the outer media attribute\n       there is some change in expected layout - if layout is similar, only a single size with no media should be provided. */\n    media?: MediaSizeQuery;\n    /* expected rendered width of the containing element in css length units. percentages are NOT supported. */\n    size: UnitLength;\n  }[];\n  /* list of possible resolutions to fetch (given by the width in pixels). Use for network performance optimization.\n     TODO(ameerabuf) - this modeling assumes that a targetSize together with ImageMedia is enough to generate\n                       full URL of the image with the target resolution, which is false for external URLs. */\n  targetSizes: number[];\n};\n\n/* props for ImageNg - the only-responsive image infra component. */\nexport type ImageNGProps = {\n  /* id to render on root picture element. */\n  id: string;\n  /* alt to render on img element. ignored if decorative is set to true. */\n  alt?: string;\n  /* data for HTML source elements. Implements art-direction and responsiveness. assumes the sources are sorted\n     according to their desired DOM-order (decided by the desired media logic -\n     https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/picture#:~:text=%3Cpicture%3E.-,The%20media%20attribute,-The%20media%20attribute). */\n  sources: ImageSource[];\n  /* fetching priority. controls whether to use the browser's lazy-loading or high-priority fetching implementations.\n     for best performance, set 'high' priority fir images above the fold and 'low' priority otherwise. */\n  priority: 'high' | 'low';\n  /* whether the image is purely decorative. if true, renders 'aria-hidden: true' empty alt string on img element. */\n  decorative?: boolean;\n  /* role to render on img element. */\n  role?: 'img' | 'none' | 'presentation';\n  /* dataset to render on root element. to use for any external mechanism implementation that requires rendering\n     special data attributes. the keys are expected to be camelCased and are converted to kebab-case with 'data-'\n     prefix when rendered. */\n  dataset?: { [key: string]: string };\n};\n"],"mappings":"","ignoreList":[]}