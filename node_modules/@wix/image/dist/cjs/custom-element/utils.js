"use strict";

exports.__esModule = true;
exports.setStyle = exports.isTransformedWEBP = exports.imageIsAnimated = exports.getScreenHeight = exports.getMediaUrlByContext = exports.getMediaSizeQueryString = exports.getImageSrc = exports.getImageComputedProperties = void 0;
var _imageKit = require("@wix/image-kit");
var _utils = require("../utils");
const CSS_NUMERIC_VALUES = {
  columnCount: 1,
  columns: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  zIndex: 1,
  zoom: 1
};
const pick = (obj, props) => {
  const propsArr = Array.isArray(props) ? props : [props];
  return propsArr.reduce((subObj, prop) => {
    const val = obj[prop];
    return val !== undefined ? Object.assign(subObj, {
      [prop]: val
    }) : subObj;
  }, {});
};
const addDefaultUnitIfNeeded = (prop, value) => typeof value === 'number' && !CSS_NUMERIC_VALUES[prop] ? `${value}px` : value.toString();
const setStyle = (node, styleProperties) => node && styleProperties && Object.keys(styleProperties).forEach(prop => {
  const styleProp = prop;
  const propValue = styleProperties[styleProp];
  if (propValue !== undefined) {
    node.style[styleProp] = addDefaultUnitIfNeeded(styleProp, propValue);
  } else {
    node.style.removeProperty(styleProp);
  }
});
exports.setStyle = setStyle;
const getScreenHeight = heightOverride => heightOverride || document.documentElement.clientHeight || window.innerHeight || 0;
exports.getScreenHeight = getScreenHeight;
const getImageComputedProperties = (extendedImageInfo, envConsts, htmlTag) => {
  // todo: CLNT-5323 , wixapp sildergallery proxy is generating image data without uri
  if (!extendedImageInfo.targetWidth || !extendedImageInfo.targetHeight || !extendedImageInfo.imageData.uri) {
    return {
      uri: '',
      css: {},
      transformed: false
    };
  }
  const {
    imageData
  } = extendedImageInfo;
  const fittingType = extendedImageInfo.displayMode || _imageKit.fittingTypes.SCALE_TO_FILL;
  const imageOptions = Object.assign(pick(imageData, ['upscaleMethod']), pick(extendedImageInfo, ['filters', 'encoding']), extendedImageInfo.quality || imageData.quality, {
    hasAnimation: (extendedImageInfo == null ? void 0 : extendedImageInfo.hasAnimation) || (imageData == null ? void 0 : imageData.hasAnimation)
  });
  const devicePixelRatioFromData = extendedImageInfo.imageData.devicePixelRatio || envConsts.devicePixelRatio;
  const devicePixelRatio = getDevicePixelRatio(devicePixelRatioFromData);
  const src = Object.assign(pick(imageData, ['width', 'height', 'crop', 'name', 'focalPoint']), {
    id: imageData.uri
  });
  const target = {
    width: extendedImageInfo.targetWidth,
    height: extendedImageInfo.targetHeight,
    htmlTag: htmlTag || 'img',
    pixelAspectRatio: devicePixelRatio,
    alignment: extendedImageInfo.alignType || _imageKit.alignTypes.CENTER
  };
  const imageComputedProperties = (0, _imageKit.getData)(fittingType, src, target, imageOptions);
  imageComputedProperties.uri = getMediaUrlByContext(imageComputedProperties.uri, envConsts.staticMediaUrl, envConsts.mediaRootUrl);
  return imageComputedProperties;
};
exports.getImageComputedProperties = getImageComputedProperties;
const getMediaUrlByContext = (imageUri, staticMediaUrl, mediaRootUrl) => {
  const isExternalUrl = /(^https?)|(^data)|(^blob)|(^\/\/)/.test(imageUri);
  if (isExternalUrl) {
    return imageUri;
  }
  let path = `${staticMediaUrl}/`;
  if (imageUri) {
    var _exec;
    if (/^micons\//.test(imageUri)) {
      path = mediaRootUrl;
    } else if (((_exec = /[^.]+$/.exec(imageUri)) == null ? void 0 : _exec[0]) === 'ico') {
      // if the image is an icon then it's taken from a slightly different place
      path = path.replace('media', 'ficons');
    }
  }
  return path + imageUri;
};
exports.getMediaUrlByContext = getMediaUrlByContext;
const getDevicePixelRatio = devicePixelRatio => {
  // we should be able to force devicePixelRatio from url by using the query param -
  const queryParams = window.location.search.split('&').map(query => query.split('='));
  const devicePixelRatioQueryParam = queryParams.find(query => {
    var _query$;
    return (_query$ = query[0]) == null ? void 0 : _query$.toLowerCase().includes('devicepixelratio');
  });
  const devicePixelRatioValueForceFromUrl = devicePixelRatioQueryParam != null && devicePixelRatioQueryParam[1] ? Number(devicePixelRatioQueryParam[1]) : null;
  return devicePixelRatioValueForceFromUrl || devicePixelRatio || 1;
};
const getImageSrc = imageNode => imageNode.getAttribute('src');
exports.getImageSrc = getImageSrc;
const isTransformedWEBP = (imageNode, imageUri) => {
  const src = getImageSrc(imageNode) || '';
  const isTransformed = !!src.match(/.webp\/v1\//);
  return (0, _imageKit.isWEBP)(imageUri) && isTransformed;
};
exports.isTransformedWEBP = isTransformedWEBP;
const imageIsAnimated = (uri, hasAnimation) => (0, _imageKit.getFileExtension)(uri) === _imageKit.fileType.GIF || (0, _imageKit.getFileExtension)(uri) === _imageKit.fileType.WEBP && hasAnimation;
exports.imageIsAnimated = imageIsAnimated;
const getMediaSizeQueryString = media => {
  return Object.entries(media).filter(([_, value]) => value || value === 0).map(([key, value]) => `(${(0, _utils.camelToKebab)(key)}: ${value}px)`).join(' and ');
};
exports.getMediaSizeQueryString = getMediaSizeQueryString;
//# sourceMappingURL=utils.js.map