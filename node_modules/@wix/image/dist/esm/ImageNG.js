import * as React from 'react';
import { getData } from '@wix/image-kit';
import { getMediaUrlByContext, getMediaSizeQueryString, } from './custom-element/utils';
import { camelToKebab } from './utils';
import styles from './imageNG.module.scss';
// TODO(ameerabuf) - in original comp these prefixes could be overriden by EnvConsts
const STATIC_MEDIA_URL = 'https://static.wixstatic.com/media/';
const MEDIA_ROOT_URL = 'https://static.wixstatic.com/';
function getURL(image, targetSize) {
    if (!image.height || !image.width) {
        return '';
    }
    let inverseAspectRatio = image.height / image.width;
    // TODO(ameerabuf) - are those the same? seemed to be used as the same in other places..
    const pixelAspectRatio = 1;
    const devicePixelRatio = 1;
    const src = Object.fromEntries(['width', 'height', 'name']
        .filter((key) => image[key])
        .map((key) => [key, image[key]]));
    if (image.crop) {
        const cropX = image.crop.x || 0;
        const cropY = image.crop.y || 0;
        const cropW = Math.min(image.crop.width || image.width, image.width - cropX);
        const cropH = Math.min(image.crop.height || image.height, image.height - cropY);
        inverseAspectRatio = cropH / cropW;
        src.crop = {
            x: cropX,
            y: cropY,
            width: cropW,
            height: cropH,
        };
    }
    src.id = image.uri;
    const target = {
        width: targetSize,
        height: targetSize * inverseAspectRatio,
        pixelAspectRatio,
        alignment: 'center',
        htmlTag: 'img',
    };
    const options = {
        // TODO(ameerabuf) - implement filter and upscale?
        // filters?: ImageTransformFiltersOption;
        // upscaleMethod?: UpscaleMethod;
        quality: image.quality,
        hasAnimation: !!image.animated,
        devicePixelRatio,
    };
    const { uri } = getData('fill', src, target, options);
    return uri && getMediaUrlByContext(uri, STATIC_MEDIA_URL, MEDIA_ROOT_URL);
}
const ImageNG = (props) => {
    const { id, alt, sources, priority, decorative, role, dataset } = props;
    if (!sources.length) {
        return null;
    }
    const sourcesAttributes = sources.map(({ image, media, sizes, targetSizes }) => ({
        sizes: sizes
            .map((s) => `${s.media ? getMediaSizeQueryString(s.media) + ' ' : ''}${s.size.value}${s.size.type}`)
            .join(', '),
        srcset: targetSizes.map((s) => `${getURL(image, s)} ${s}w`).join(', '),
        ...(media && { media: getMediaSizeQueryString(media) }),
        width: Math.min(image.crop?.width || image.width, image.width - (image.crop?.x || 0)),
        height: Math.min(image.crop?.height || image.height, image.height - (image.crop?.y || 0)),
    }));
    const defaultSource = sources[sources.length - 1];
    const { image } = defaultSource;
    const fullSizeSrc = getURL(image, image.width);
    const dataAttrs = dataset
        ? Object.fromEntries(Object.entries(dataset).map(([key, val]) => [
            `data-${camelToKebab(key)}`,
            val,
        ]))
        : {};
    return (React.createElement("picture", { id: id, className: `${styles.image}`, ...dataAttrs },
        sourcesAttributes.map(({ sizes, srcset, media, width, height }) => (React.createElement("source", { key: `${id}-${media}`, sizes: sizes, srcSet: srcset, media: media, width: width, height: height }))),
        React.createElement("style", null, [...sourcesAttributes]
            .reverse()
            .map(({ media, width, height, }) => `${media ? `@media ${media} {` : ''}#${id}{--aspect-ratio: ${width / height};}${media ? '}' : ''}`)
            .join(' ')),
        React.createElement("img", { ...(priority === 'high'
                ? { fetchpriority: 'high' }
                : { loading: 'lazy' }), ...(decorative && { 'aria-hidden': true }), src: fullSizeSrc, alt: decorative ? '' : alt, role: role, width: image.width, height: image.height })));
};
export { ImageNG };
//# sourceMappingURL=ImageNG.js.map