(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define("image", ["React"], factory);
	else if(typeof exports === 'object')
		exports["image"] = factory(require("React"));
	else
		root["image"] = factory(root["React"]);
})((typeof self !== 'undefined' ? self : this), (__WEBPACK_EXTERNAL_MODULE__883__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 709:
/*!************************************************!*\
  !*** ../../../node_modules/fastdom/fastdom.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(function(win) {

/**
 * FastDom
 *
 * Eliminates layout thrashing
 * by batching DOM read/write
 * interactions.
 *
 * @author Wilson Page <wilsonpage@me.com>
 * @author Kornel Lesinski <kornel.lesinski@ft.com>
 */

'use strict';

/**
 * Mini logger
 *
 * @return {Function}
 */
var debug =  false ? 0 : function() {};

/**
 * Normalized rAF
 *
 * @type {Function}
 */
var raf = win.requestAnimationFrame
  || win.webkitRequestAnimationFrame
  || win.mozRequestAnimationFrame
  || win.msRequestAnimationFrame
  || function(cb) { return setTimeout(cb, 16); };

/**
 * Initialize a `FastDom`.
 *
 * @constructor
 */
function FastDom() {
  var self = this;
  self.reads = [];
  self.writes = [];
  self.raf = raf.bind(win); // test hook
  debug('initialized', self);
}

FastDom.prototype = {
  constructor: FastDom,

  /**
   * We run this inside a try catch
   * so that if any jobs error, we
   * are able to recover and continue
   * to flush the batch until it's empty.
   *
   * @param {Array} tasks
   */
  runTasks: function(tasks) {
    debug('run tasks');
    var task; while (task = tasks.shift()) task();
  },

  /**
   * Adds a job to the read batch and
   * schedules a new frame if need be.
   *
   * @param  {Function} fn
   * @param  {Object} ctx the context to be bound to `fn` (optional).
   * @public
   */
  measure: function(fn, ctx) {
    debug('measure');
    var task = !ctx ? fn : fn.bind(ctx);
    this.reads.push(task);
    scheduleFlush(this);
    return task;
  },

  /**
   * Adds a job to the
   * write batch and schedules
   * a new frame if need be.
   *
   * @param  {Function} fn
   * @param  {Object} ctx the context to be bound to `fn` (optional).
   * @public
   */
  mutate: function(fn, ctx) {
    debug('mutate');
    var task = !ctx ? fn : fn.bind(ctx);
    this.writes.push(task);
    scheduleFlush(this);
    return task;
  },

  /**
   * Clears a scheduled 'read' or 'write' task.
   *
   * @param {Object} task
   * @return {Boolean} success
   * @public
   */
  clear: function(task) {
    debug('clear', task);
    return remove(this.reads, task) || remove(this.writes, task);
  },

  /**
   * Extend this FastDom with some
   * custom functionality.
   *
   * Because fastdom must *always* be a
   * singleton, we're actually extending
   * the fastdom instance. This means tasks
   * scheduled by an extension still enter
   * fastdom's global task queue.
   *
   * The 'super' instance can be accessed
   * from `this.fastdom`.
   *
   * @example
   *
   * var myFastdom = fastdom.extend({
   *   initialize: function() {
   *     // runs on creation
   *   },
   *
   *   // override a method
   *   measure: function(fn) {
   *     // do extra stuff ...
   *
   *     // then call the original
   *     return this.fastdom.measure(fn);
   *   },
   *
   *   ...
   * });
   *
   * @param  {Object} props  properties to mixin
   * @return {FastDom}
   */
  extend: function(props) {
    debug('extend', props);
    if (typeof props != 'object') throw new Error('expected object');

    var child = Object.create(this);
    mixin(child, props);
    child.fastdom = this;

    // run optional creation hook
    if (child.initialize) child.initialize();

    return child;
  },

  // override this with a function
  // to prevent Errors in console
  // when tasks throw
  catch: null
};

/**
 * Schedules a new read/write
 * batch if one isn't pending.
 *
 * @private
 */
function scheduleFlush(fastdom) {
  if (!fastdom.scheduled) {
    fastdom.scheduled = true;
    fastdom.raf(flush.bind(null, fastdom));
    debug('flush scheduled');
  }
}

/**
 * Runs queued `read` and `write` tasks.
 *
 * Errors are caught and thrown by default.
 * If a `.catch` function has been defined
 * it is called instead.
 *
 * @private
 */
function flush(fastdom) {
  debug('flush');

  var writes = fastdom.writes;
  var reads = fastdom.reads;
  var error;

  try {
    debug('flushing reads', reads.length);
    fastdom.runTasks(reads);
    debug('flushing writes', writes.length);
    fastdom.runTasks(writes);
  } catch (e) { error = e; }

  fastdom.scheduled = false;

  // If the batch errored we may still have tasks queued
  if (reads.length || writes.length) scheduleFlush(fastdom);

  if (error) {
    debug('task errored', error.message);
    if (fastdom.catch) fastdom.catch(error);
    else throw error;
  }
}

/**
 * Remove an item from an Array.
 *
 * @param  {Array} array
 * @param  {*} item
 * @return {Boolean}
 */
function remove(array, item) {
  var index = array.indexOf(item);
  return !!~index && !!array.splice(index, 1);
}

/**
 * Mixin own properties of source
 * object into the target.
 *
 * @param  {Object} target
 * @param  {Object} source
 */
function mixin(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) target[key] = source[key];
  }
}

// There should never be more than
// one instance of `FastDom` in an app
var exports = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line

// Expose to CJS & AMD
if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return exports; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}

})( typeof window !== 'undefined' ? window : typeof this != 'undefined' ? this : globalThis);


/***/ }),

/***/ 883:
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__883__;

/***/ }),

/***/ 929:
/*!**********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ 76);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 414:
/*!***************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/extends.js ***!
  \***************************************************************/
/***/ ((module) => {

function _extends() {
  return module.exports = _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 921:
/*!*******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 998)["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 76:
/*!*********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 998)["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ 921);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 998:
/*!**************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/typeof.js ***!
  \**************************************************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!*******************************!*\
  !*** ./index.ts + 33 modules ***!
  \*******************************/
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Image: () => (/* reexport */ Image),
  ImageNG: () => (/* reexport */ ImageNG),
  imageKit: () => (/* reexport */ max_namespaceObject),
  initCustomElement: () => (/* reexport */ initCustomElement)
});

// NAMESPACE OBJECT: ../../image-kit/dist/esm/api/max/index.js
var max_namespaceObject = {};
__webpack_require__.r(max_namespaceObject);
__webpack_require__.d(max_namespaceObject, {
  STATIC_MEDIA_URL: () => (STATIC_MEDIA_URL),
  alignTypes: () => (alignTypes),
  fileType: () => (fileType),
  fittingTypes: () => (fittingTypes),
  getData: () => (getData),
  getFileExtension: () => (getFileExtension),
  getPlaceholder: () => (getPlaceholder),
  getResponsiveImageProps: () => (getResponsiveImageProps),
  htmlTag: () => (htmlTag),
  isWEBP: () => (imageServiceUtils_isWEBP),
  populateGlobalFeatureSupport: () => (populateGlobalFeatureSupport),
  sdk: () => (sdk),
  upscaleMethods: () => (upscaleMethods)
});

// EXTERNAL MODULE: ../../../node_modules/@babel/runtime/helpers/extends.js
var helpers_extends = __webpack_require__(414);
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);
// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(883);
;// ./Image.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Image_module = ({"image":"dSF_1i"});
;// ../../image-kit/dist/esm/helpers/imageServiceConstants.js
/**
 * image service api version
 */
const API_VERSION = 'v1';
/**
the maximum retina factor
 */
const MAX_DEVICE_PIXEL_RATIO = 2;
/**
 site BG legacy max width x height
 */
const DSKTP_MAX_BG_SITE_LEGACY_WIDTH = 1920;
const DSKTP_MAX_BG_SITE_LEGACY_HEIGHT = 1920;
const MOBILE_MAX_BG_SITE_LEGACY_WIDTH = 1000;
const MOBILE_MAX_BG_SITE_LEGACY_HEIGHT = 1000;
/**
 * Enum string values of requested image fitting types
 * Note: TILE_HORIZONTAL, TILE_VERTICAL, FIT_AND_TILE are supported for legacy purposes but are not exposed
 * in the documentation because they should not be exposed for new features
 */
const fittingTypes = {
  SCALE_TO_FILL: 'fill',
  SCALE_TO_FIT: 'fit',
  STRETCH: 'stretch',
  ORIGINAL_SIZE: 'original_size',
  TILE: 'tile',
  TILE_HORIZONTAL: 'tile_horizontal',
  TILE_VERTICAL: 'tile_vertical',
  FIT_AND_TILE: 'fit_and_tile',
  LEGACY_STRIP_TILE: 'legacy_strip_tile',
  LEGACY_STRIP_TILE_HORIZONTAL: 'legacy_strip_tile_horizontal',
  LEGACY_STRIP_TILE_VERTICAL: 'legacy_strip_tile_vertical',
  LEGACY_STRIP_SCALE_TO_FILL: 'legacy_strip_fill',
  LEGACY_STRIP_SCALE_TO_FIT: 'legacy_strip_fit',
  LEGACY_STRIP_FIT_AND_TILE: 'legacy_strip_fit_and_tile',
  LEGACY_STRIP_ORIGINAL_SIZE: 'legacy_strip_original_size',
  LEGACY_ORIGINAL_SIZE: 'actual_size',
  LEGACY_FIT_WIDTH: 'fitWidth',
  LEGACY_FIT_HEIGHT: 'fitHeight',
  LEGACY_FULL: 'full',
  LEGACY_BG_FIT_AND_TILE: 'legacy_tile',
  LEGACY_BG_FIT_AND_TILE_HORIZONTAL: 'legacy_tile_horizontal',
  LEGACY_BG_FIT_AND_TILE_VERTICAL: 'legacy_tile_vertical',
  LEGACY_BG_NORMAL: 'legacy_normal'
};
/**
 * Enum string values of image transform types as passed to the image service api
 */
const transformTypes = {
  FIT: 'fit',
  FILL: 'fill',
  FILL_FOCAL: 'fill_focal',
  CROP: 'crop',
  LEGACY_CROP: 'legacy_crop',
  LEGACY_FILL: 'legacy_fill'
};
/**
 * Enum string values of requested image align types
 * @type {{CENTER: string, RIGHT: string, LEFT: string, TOP: string, BOTTOM: string, TOP_RIGHT: string, TOP_LEFT: string, BOTTOM_RIGHT: string, BOTTOM_LEFT: string}}
 */
const alignTypes = {
  CENTER: 'center',
  TOP: 'top',
  TOP_LEFT: 'top_left',
  TOP_RIGHT: 'top_right',
  BOTTOM: 'bottom',
  BOTTOM_LEFT: 'bottom_left',
  BOTTOM_RIGHT: 'bottom_right',
  LEFT: 'left',
  RIGHT: 'right'
};
/**
 * Enum 9Grid alignment to focal point
 */
const ALIGN_TYPE_TO_FOCAL_POINT = {
  [alignTypes.CENTER]: {
    x: 0.5,
    y: 0.5
  },
  [alignTypes.TOP_LEFT]: {
    x: 0,
    y: 0
  },
  [alignTypes.TOP_RIGHT]: {
    x: 1.0,
    y: 0
  },
  [alignTypes.TOP]: {
    x: 0.5,
    y: 0
  },
  [alignTypes.BOTTOM_LEFT]: {
    x: 0,
    y: 1.0
  },
  [alignTypes.BOTTOM_RIGHT]: {
    x: 1.0,
    y: 1.0
  },
  [alignTypes.BOTTOM]: {
    x: 0.5,
    y: 1.0
  },
  [alignTypes.RIGHT]: {
    x: 1.0,
    y: 0.5
  },
  [alignTypes.LEFT]: {
    x: 0,
    y: 0.5
  }
};
/**
 * Enum string values of image align types as passed to the image service
 */
const alignTypesMap = {
  center: 'c',
  top: 't',
  top_left: 'tl',
  top_right: 'tr',
  bottom: 'b',
  bottom_left: 'bl',
  bottom_right: 'br',
  left: 'l',
  right: 'r'
};
/**
 * Enum string values of html tag used to construct the css or svg attributes
 *  @type {{BG: string, IMG: string, SVG: string}}
 */
const htmlTag = {
  BG: 'bg',
  IMG: 'img',
  SVG: 'svg'
};
/**
 * Enum string values of upscale method
 *  @type {{DEFAULT: string, SUPER: string}}
 */
const upscaleMethods = {
  AUTO: 'auto',
  CLASSIC: 'classic',
  SUPER: 'super'
};
/**
 *  api values of upscale method
 *  @type {{default: number, super: number}}
 */
const upscaleMethodsValues = {
  classic: 1,
  super: 2
};
/**
 * default unsharp mask values
 *  @type {{radius: number, amount: number, threshold: number}}
 */
const defaultUSM = {
  radius: '0.66',
  amount: '1.00',
  threshold: '0.01'
};
/**
 * default empty data
 */
const emptyData = {
  uri: '',
  css: {
    img: {},
    container: {}
  },
  attr: {
    img: {},
    container: {}
  },
  transformed: false
};
const MAX_TRANSFORMED_IMAGE_WIDTH = 5000;
const MAX_TRANSFORMED_IMAGE_HEIGHT = 5000;
const SAFE_TRANSFORMED_AREA = MAX_TRANSFORMED_IMAGE_WIDTH * MAX_TRANSFORMED_IMAGE_HEIGHT;
/**
 * super res machine learning upscale factor models -
 * @type {number[]}
 */
const SUPER_UPSCALE_MODELS = [1.5, 2, 4];
/**
 * image qualities
 */
const imageScaleDefaults = {
  HIGH: {
    size: 1400 * 1400,
    quality: 90,
    maxUpscale: 1
  },
  MEDIUM: {
    size: 600 * 600,
    quality: 85,
    maxUpscale: 1
  },
  LOW: {
    size: 400 * 400,
    quality: 80,
    maxUpscale: 1.2
  },
  TINY: {
    size: 0,
    quality: 80,
    maxUpscale: 1.4
  }
};
/**
 * image quality
 * @type {{HIGH: string, MEDIUM: string, LOW: string, TINY: string}}
 */
const imageQuality = {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW',
  TINY: 'TINY'
};
/**
 * image filters
 * @type {{CONTRAST: string, BRIGHTNESS: string, SATURATION: string, HUE: string, BLUR: string}}
 */
const imageFilters = {
  CONTRAST: 'contrast',
  BRIGHTNESS: 'brightness',
  SATURATION: 'saturation',
  HUE: 'hue',
  BLUR: 'blur'
};
const fileType = {
  JPG: 'jpg',
  JPEG: 'jpeg',
  JPE: 'jpe',
  PNG: 'png',
  WEBP: 'webp',
  WIX_ICO_MP: 'wix_ico_mp',
  WIX_MP: 'wix_mp',
  GIF: 'gif',
  SVG: 'svg',
  AVIF: 'avif',
  UNRECOGNIZED: 'unrecognized'
};
const encodingTypes = {
  AVIF: 'AVIF',
  PAVIF: 'PAVIF'
};
const supportedExtensions = [fileType.JPG, fileType.JPEG, fileType.JPE, fileType.PNG, fileType.GIF, fileType.WEBP];

;// ../../image-kit/dist/esm/helpers/utils.js
/**
 * Simple templates.
 * Receives a string with es6 ${...} style template arguments and returns a transformed string.
 * @param string
 * @returns {Function}
 */
function template(strings) {
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }
  return function () {
    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      values[_key2] = arguments[_key2];
    }
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach(function (key, i) {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join('');
  };
}
/**
 * Get the last element in an array
 * @param array
 * @returns {*}
 */
function last(array) {
  return array[array.length - 1];
}

;// ../../image-kit/dist/esm/helpers/imageServiceUtils.js


const SUPPORTED_IMAGE_EXTENSIONS = [fileType.PNG, fileType.JPEG, fileType.JPG, fileType.JPE, fileType.WIX_ICO_MP, fileType.WIX_MP, fileType.WEBP, fileType.AVIF];
const JPG_EXTENSIONS = [fileType.JPEG, fileType.JPG, fileType.JPE];
/**
 * checks if image type is supported
 * @param {string}     uri      image source uri
 *
 * @returns {boolean}
 */
function isImageTypeSupported(uri) {
  return SUPPORTED_IMAGE_EXTENSIONS.includes(getFileExtension(uri));
}
/**
 * check request integrity
 * @param {FittingType}             fittingType         imageService.fittingTypes
 * @param {ImageTransformSource}    src
 * @param {ImageTransformTarget}    target
 *
 * @returns {boolean}
 */
function isValidRequest(fittingType, src, target) {
  return target && src && !isUrlEmptyOrNone(src.id) && Object.values(fittingTypes).includes(fittingType);
}
/**
 * returns true unless image is animated webp and allowAnimatedTransform is false
 */
function canTransformIfAnimatedImage(uri, hasAnimation, allowAnimatedTransform) {
  if (allowAnimatedTransform === void 0) {
    allowAnimatedTransform = false;
  }
  const isAvifWebpFormat = imageServiceUtils_isWEBP(uri) || isAVIF(uri);
  return !(isAvifWebpFormat && hasAnimation && !allowAnimatedTransform);
}
/**
 * returns true if image is a gif and allowAnimatedTransform is true
 */
function isTransformableGIF(uri, allowAnimatedTransform) {
  if (allowAnimatedTransform === void 0) {
    allowAnimatedTransform = false;
  }
  return isGIF(uri) && allowAnimatedTransform;
}
/**
 * check if image transform is supported for source image
 */
function isImageTransformApplicable(uri, hasAnimation, allowAnimatedTransform) {
  return canTransformIfAnimatedImage(uri, hasAnimation, allowAnimatedTransform) && (isImageTypeSupported(uri) || isTransformableGIF(uri, allowAnimatedTransform)) && !isExternalUrl(uri);
}
/**
 * returns true if image is of JPG type
 * @param {string}  uri
 *
 * @returns {boolean}
 */
function isJPG(uri) {
  return JPG_EXTENSIONS.includes(getFileExtension(uri));
}
/**
 * returns true if image is of PNG type
 * @param {string}  uri
 *
 * @returns {boolean}
 */
function isPNG(uri) {
  return getFileExtension(uri) === fileType.PNG;
}
/**
 * returns true if image is of webP type
 * @param {string}  uri
 *
 * @returns {boolean}
 */
function imageServiceUtils_isWEBP(uri) {
  return getFileExtension(uri) === fileType.WEBP;
}
/**
 * returns true if image is of GIF type
 * @param {string}  uri
 *
 * @returns {boolean}
 */
function isGIF(uri) {
  return getFileExtension(uri) === fileType.GIF;
}
/**
 * returns true if image is of webP type
 * @param {string}  uri
 *
 * @returns {boolean}
 */
function isAVIF(uri) {
  return getFileExtension(uri) === fileType.AVIF;
}
/**
 * returns true if the url starts with http, https, // or data
 * @param {string}  url
 *
 * @returns {boolean}
 */
function isExternalUrl(url) {
  return /(^https?)|(^data)|(^\/\/)/.test(url);
}
/**
 * returns true if the url empty or none string
 * @param {string}  url
 *
 * @returns {boolean}
 */
function isUrlEmptyOrNone(url) {
  return !url || !url.trim() || url.toLowerCase() === 'none';
}
/**
 * returns search bot true or false as indicated in options
 * @param {ImageTransformOptions}   options
 *
 * @returns {boolean}
 */
function isSEOBot(options) {
  return (options == null ? void 0 : options.isSEOBot) ?? false;
}
// https://jira.wixpress.com/browse/WEED-12667
// const illegalChars = ['/', '\\', '#', '^', '?', '{', '}', '<', '>', '|', '`', '“', ':', '"'].map(encodeURIComponent)
const ILLEGAL_CHARS = ['/', '\\', '?', '<', '>', '|', '“', ':', '"'].map(encodeURIComponent);
const URL_SAFE_ILLEGAL_CHARS = ['\\.', '\\*'];
const ILLEGAL_CHARS_REPLACEMENT = '_';
/**
 * returns source image file name (no extension)
 * @param {string}     uri      image source uri
 * @param {string}     [name]   optional image source name
 *
 * @returns {string}
 */
function getFileName(uri, name) {
  const beforeLeadingSlashRegexp = /\/(.*?)$/;
  const fileExtensionRegexp = /\.([^.]*)$/;
  const illegalCharsRegex = new RegExp(`(${ILLEGAL_CHARS.concat(URL_SAFE_ILLEGAL_CHARS).join('|')})`, 'g');
  // if name is a non empty string, remove only supported extension if exists and url encode the string
  if (name && name.length) {
    let fileName = name;
    const extension = name.match(fileExtensionRegexp);
    if (extension && SUPPORTED_IMAGE_EXTENSIONS.includes(extension[1])) {
      fileName = name.replace(fileExtensionRegexp, '');
    }
    return encodeURIComponent(fileName).replace(illegalCharsRegex, ILLEGAL_CHARS_REPLACEMENT);
  }
  // else, trim any preceding media structure from the uri string (like "media/" etc.) and remove extension
  const trimmed = uri.match(beforeLeadingSlashRegexp);
  const fileName = trimmed ? trimmed[1] : uri;
  return fileName.replace(fileExtensionRegexp, '');
}
/**
 * returns source image file name (no extension)
 * @param {string}     uri      image source uri
 *
 * @returns {FileType}
 */
function getFileType(uri) {
  if (isJPG(uri)) {
    return fileType.JPG;
  } else if (isPNG(uri)) {
    return fileType.PNG;
  } else if (imageServiceUtils_isWEBP(uri)) {
    return fileType.WEBP;
  } else if (isGIF(uri)) {
    return fileType.GIF;
  } else if (isAVIF(uri)) {
    return fileType.AVIF;
  }
  return fileType.UNRECOGNIZED;
}
/**
 * returns source image file extension
 * @param {string}     uri      image source uri
 *
 * @returns {string}
 */
function getFileExtension(uri) {
  const splitURI = /[.]([^.]+)$/.exec(uri);
  return (splitURI && /[.]([^.]+)$/.exec(uri)[1] || '').toLowerCase();
}
/**
 * returns scale factor needed if FIT fitting
 * @param {number}  sWidth
 * @param {number}  sHeight
 * @param {number}  dWidth
 * @param {number}  dHeight
 *
 * @returns {number}
 */
function getFitScaleFactor(sWidth, sHeight, dWidth, dHeight) {
  return Math.min(dWidth / sWidth, dHeight / sHeight);
}
/**
 * returns scale factor needed if FILL fitting
 * @param {number}  sWidth
 * @param {number}  sHeight
 * @param {number}  dWidth
 * @param {number}  dHeight
 *
 * @returns {number}
 */
function getFillScaleFactor(sWidth, sHeight, dWidth, dHeight) {
  return Math.max(dWidth / sWidth, dHeight / sHeight);
}
/**
 * returns scale factor source target
 * @param {number}  sWidth
 * @param {number}  sHeight
 * @param {number}  dWidth
 * @param {number}  dHeight
 * @param {string}  transformType
 *
 * @returns {number}
 */
function getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType) {
  let scaleFactor;
  if (transformType === transformTypes.FILL) {
    scaleFactor = getFillScaleFactor(sWidth, sHeight, dWidth, dHeight);
  } else if (transformType === transformTypes.FIT) {
    scaleFactor = getFitScaleFactor(sWidth, sHeight, dWidth, dHeight);
  } else {
    scaleFactor = 1;
  }
  return scaleFactor;
}
/**
 * get calculated scale factor , width and height while considering wixmp image transform dimension limits
 * @param sWidth
 * @param sHeight
 * @param dWidth
 * @param dHeight
 * @param transformType
 * @returns {{scaleFactor: *, width: *, height: *}}
 */
function getSafeTransformData(sWidth, sHeight, dWidth, dHeight, transformType) {
  let scaleFactor;
  // defaults for FILL transform type
  let width = dWidth;
  let height = dHeight;
  // calculate safe image transformed area
  scaleFactor = getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType);
  if (transformType === transformTypes.FIT) {
    width = sWidth * scaleFactor;
    height = sHeight * scaleFactor;
  }
  // adjust target width & height & scaleFactor
  if (width && height && width * height > SAFE_TRANSFORMED_AREA) {
    const dimensionScaleFactor = Math.sqrt(SAFE_TRANSFORMED_AREA / (width * height));
    width *= dimensionScaleFactor;
    height *= dimensionScaleFactor;
    // get the new scale factor
    scaleFactor = getScaleFactor(sWidth, sHeight, width, height, transformType);
  }
  return {
    scaleFactor,
    width,
    height
  };
}
/**
 * returns the destination rectangle
 * @param {number}                  sWidth
 * @param {number}                  sHeight
 * @param {TransformType}           transformType
 * @param {ImageTransformTarget}    target
 * @param {number}                  dpr - device pixel ratio
 * @param {UpscaleMethod}           upscaleMethod
 *
 * @returns {ImageTransformData & {upscaleMethodValue: number}}
 */
function getTransformData(sWidth, sHeight, transformType, target, dpr, upscaleMethod) {
  // use target dimension is src not provided
  sWidth = sWidth || target.width;
  sHeight = sHeight || target.height;
  // adjust image transform values considering server side transform limitations and performance
  const {
    scaleFactor,
    width,
    height
  } = getSafeTransformData(sWidth, sHeight, target.width * dpr, target.height * dpr, transformType);
  // adjust image transform values to optimizing upsacle quality and payload
  return getOptimizedTransformData(sWidth, sHeight, width, height, upscaleMethod, scaleFactor, transformType);
}
/**
 * converts 9 grid alignment to Focal point position
 * @param {string}  [alignment]
 *
 * @returns {x:number,y:number}
 */
function getFocalPointFrom9GridAlignment(alignment) {
  if (alignment === void 0) {
    alignment = alignTypes.CENTER;
  }
  return ALIGN_TYPE_TO_FOCAL_POINT[alignment];
}
/**
 * returns overlapping rectangle where sRect
 * id aligned (according to alignment) within dRect
 * @param {{ width: number; height: number }} sRect rect 1
 * @param {{ width: number, height: number }} dRect rect 2
 * @param {{x: number, y: number}|undefined}  sFP   source image focal point
 * @param {string}                            alignment
 *
 * @returns {{x: number, y: number, width: number, height: number}}
 */
function getAlignedRect(sRect, dRect, sFP, alignment) {
  const fp = getFocalPoint(sFP) || getFocalPointFrom9GridAlignment(alignment);
  const x = Math.max(0, Math.min(sRect.width - dRect.width, fp.x * sRect.width - dRect.width / 2));
  const y = Math.max(0, Math.min(sRect.height - dRect.height, fp.y * sRect.height - dRect.height / 2));
  // rect
  return {
    x,
    y,
    width: Math.min(sRect.width, dRect.width),
    height: Math.min(sRect.height, dRect.height)
  };
}
/**
 * returns overlapping rectangle between sRect and dRect
 * @param {object}      sRect         rect 1
 * @param {object}      dRect         rect 2
 *
 * @returns {{x:number,y:number,width:number, height:number} || null}
 */
function getOverlappingRect(sRect, dRect) {
  const width = Math.max(0, Math.min(sRect.width, dRect.x + dRect.width) - Math.max(0, dRect.x));
  const height = Math.max(0, Math.min(sRect.height, dRect.y + dRect.height) - Math.max(0, dRect.y));
  const isValidRect = width && height && (sRect.width !== width || sRect.height !== height);
  // return overlapping sRect/dRect rectangle(x, y, width, height)
  return isValidRect ? {
    x: Math.max(0, dRect.x),
    y: Math.max(0, dRect.y),
    width,
    height
  } : null;
}
/**
 * returns pixel aspect ratio value
 * @param {ImageTransformTarget}    target
 *
 * @returns {number}
 */
function getDevicePixelRatio(target) {
  return Math.min(target.pixelAspectRatio || 1, MAX_DEVICE_PIXEL_RATIO);
}
/**
 * returns target alignment value
 * @param {ImageTransformTarget}    target
 *
 * @returns {string}
 */
function getAlignment(target) {
  return target.alignment && alignTypesMap[target.alignment] || alignTypesMap[alignTypes.CENTER];
}
/**
 * returns the focal point value, if no focal point passed use alignment
 * @param {{x: number, y: number}|undefined} focalPoint
 */
function getFocalPoint(focalPoint) {
  let fp;
  if (focalPoint && typeof focalPoint.x === 'number' && !isNaN(focalPoint.x) && typeof focalPoint.y === 'number' && !isNaN(focalPoint.y)) {
    fp = {
      x: roundToFixed(Math.max(0, Math.min(100, focalPoint.x)) / 100, 2),
      y: roundToFixed(Math.max(0, Math.min(100, focalPoint.y)) / 100, 2)
    };
  }
  return fp;
}
/**
 * returns preferred image quality value
 * @param {number}    imageWidth
 * @param {number}    imageHeight
 *
 * @returns {number}
 */
function getPreferredImageQuality(imageWidth, imageHeight) {
  return imageScaleDefaults[getImageQualityKey(imageWidth, imageHeight)].quality;
}
/**
 * returns the scale descriptor of CLASSIC upscale method
 * @param sWidth
 * @param sHeight
 * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}
 */
function getClassicScaleData(sWidth, sHeight) {
  const imageKey = getImageQualityKey(sWidth, sHeight);
  return {
    optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,
    upscaleMethodValue: upscaleMethodsValues.classic,
    forceUSM: false
  };
}
/**
 * returns the scale descriptor of AUTO upscale method
 * @param sWidth
 * @param sHeight
 * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}
 */
function getAutoScaleData(sWidth, sHeight) {
  const imageKey = getImageQualityKey(sWidth, sHeight);
  return {
    optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,
    upscaleMethodValue: upscaleMethodsValues.classic,
    forceUSM: false
  };
}
/**
 * returns the scale descriptor of SUPER upscale method
 * @param scaleFactor
 * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}
 */
function getSuperScaleData(scaleFactor) {
  return {
    optimizedScaleFactor: last(SUPER_UPSCALE_MODELS),
    upscaleMethodValue: upscaleMethodsValues.super,
    forceUSM: !(SUPER_UPSCALE_MODELS.includes(scaleFactor) || scaleFactor > last(SUPER_UPSCALE_MODELS))
  };
}
/**
 * returns upscale descriptor object
 * @param {number}    sWidth
 * @param {number}    sHeight
 * @param {string}    upscaleMethod
 * @param {number}    scaleFactor
 *
 * @returns  {{maxScale: number, upscaleMethodValue: number, forceUSM: boolean}}
 */
function getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod) {
  if (upscaleMethod === 'auto') {
    return getAutoScaleData(sWidth, sHeight);
  } else if (upscaleMethod === 'super') {
    return getSuperScaleData(scaleFactor);
  }
  // assuming 'classic' method
  return getClassicScaleData(sWidth, sHeight);
}
/**
 * returns optimized upscale data, considering requested upscale method , optimize upscale for best quality and bandwidth
 * @param {number}    sWidth
 * @param {number}    sHeight
 * @param {number}    tWidth
 * @param {number}    tHeight
 * @param {UpscaleMethod}    upscaleMethod
 * @param {number}    scaleFactor
 * @param {TransformType}    transformType
 *
 * @returns  {ImageTransformData}
 */
function getOptimizedTransformData(sWidth, sHeight, tWidth, tHeight, upscaleMethod, scaleFactor, transformType) {
  const {
    optimizedScaleFactor,
    upscaleMethodValue,
    forceUSM
  } = getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod);
  let width = tWidth;
  let height = tHeight;
  if (scaleFactor <= optimizedScaleFactor) {
    // target upscale within limits or downscale
    return {
      width,
      height,
      scaleFactor,
      upscaleMethodValue,
      forceUSM,
      cssUpscaleNeeded: false
    };
  }
  // limited upscale
  switch (transformType) {
    case transformTypes.FILL:
      width = tWidth * (optimizedScaleFactor / scaleFactor);
      height = tHeight * (optimizedScaleFactor / scaleFactor);
      break;
    case transformTypes.FIT:
      width = sWidth * optimizedScaleFactor;
      height = sHeight * optimizedScaleFactor;
      break;
    default:
      break;
  }
  // adjust transform values
  return {
    width,
    height,
    scaleFactor: optimizedScaleFactor,
    upscaleMethodValue,
    forceUSM,
    cssUpscaleNeeded: true
  };
}
/**
 * returns image quality key
 * @param {number}    imageWidth
 * @param {number}    imageHeight
 *
 * @returns {ImageQuality}
 */
function getImageQualityKey(imageWidth, imageHeight) {
  const size = imageWidth * imageHeight;
  if (size > imageScaleDefaults[imageQuality.HIGH].size) {
    return imageQuality.HIGH;
  } else if (size > imageScaleDefaults[imageQuality.MEDIUM].size) {
    return imageQuality.MEDIUM;
  } else if (size > imageScaleDefaults[imageQuality.LOW].size) {
    return imageQuality.LOW;
  }
  return imageQuality.TINY;
}
/**
 * return the actual rounded dimension of a scaled rectangle
 * @param sWidth
 * @param sHeight
 * @param tWidth
 * @param tHeight
 * @param transformType
 * @returns {{width: number, height: number}}
 */
function getDimension(sWidth, sHeight, tWidth, tHeight, transformType) {
  const scaleFactor = getScaleFactor(sWidth, sHeight, tWidth, tHeight, transformType);
  return {
    width: Math.round(sWidth * scaleFactor),
    height: Math.round(sHeight * scaleFactor)
  };
}
/**
 * rounds number n digit precision and converts to string
 * @param {number}      value
 * @param {number}      precision
 *
 * @returns {string}
 */
function roundToFixed(value, precision) {
  const truncatePrecision = Math.pow(10, precision || 0);
  return (value * truncatePrecision / truncatePrecision).toFixed(precision);
}
/**
 * get normalize scale method
 * @param {ImageTransformOptions} [options]
 * @returns {UpscaleMethod}
 */
function getUpscaleString(options) {
  if (!options || !options.upscaleMethod) {
    return upscaleMethods.AUTO;
  }
  return upscaleMethods[options.upscaleMethod.toUpperCase()] || upscaleMethods.AUTO;
}
function imageIsAnimated(uri, hasAnimation) {
  const isAvifWebpFormat = imageServiceUtils_isWEBP(uri) || isAVIF(uri);
  return getFileExtension(uri) === fileType.GIF || isAvifWebpFormat && hasAnimation;
}

;// ../../image-kit/dist/esm/helpers/imageServiceFeatureSupportObject.js
const globalFeaturesSupportObj = {
  /**
   * @type {object<boolean>}
   */
  isMobile: false
};
const getFeature = function (feature) {
  return globalFeaturesSupportObj[feature];
};
const setFeature = function (feature, value) {
  globalFeaturesSupportObj[feature] = value;
};

;// ../../image-kit/dist/esm/helpers/populateFeatureSupport.js

/**
 * Populate the global feature support object with browser specific values
 */
function populateGlobalFeatureSupport() {
  if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {
    const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 767px)').matches;
    const isMobileAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    // set is mobile
    setFeature('isMobile', isSmallScreen && isMobileAgent);
  }
}

;// ../../image-kit/dist/esm/engines/attributes/backgroundAttributes.js

/**
 * returns BG tag CSS data
 * @param {ImageTransformObject}    transformsObj    transform parts object
 * @param {ImageTransformTarget}    target
 *
 * @returns {BackgroundImageAttributes}
 */
function getCSS(transformsObj, target) {
  const attributes = {
    css: {
      container: {}
    }
  };
  const {
    css
  } = attributes;
  const {
    fittingType
  } = transformsObj;
  // set fitting
  switch (fittingType) {
    case fittingTypes.ORIGINAL_SIZE:
    case fittingTypes.LEGACY_ORIGINAL_SIZE:
    case fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'no-repeat';
      break;
    case fittingTypes.SCALE_TO_FIT:
    case fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:
      css.container.backgroundSize = 'contain';
      css.container.backgroundRepeat = 'no-repeat';
      break;
    case fittingTypes.STRETCH:
      css.container.backgroundSize = '100% 100%';
      css.container.backgroundRepeat = 'no-repeat';
      break;
    case fittingTypes.SCALE_TO_FILL:
    case fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:
      css.container.backgroundSize = 'cover';
      css.container.backgroundRepeat = 'no-repeat';
      break;
    case fittingTypes.TILE_HORIZONTAL:
    case fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat-x';
      break;
    case fittingTypes.TILE_VERTICAL:
    case fittingTypes.LEGACY_STRIP_TILE_VERTICAL:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat-y';
      break;
    case fittingTypes.TILE:
    case fittingTypes.LEGACY_STRIP_TILE:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat';
      break;
    case fittingTypes.LEGACY_STRIP_FIT_AND_TILE:
      css.container.backgroundSize = 'contain';
      css.container.backgroundRepeat = 'repeat';
      break;
    case fittingTypes.FIT_AND_TILE:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat';
      break;
    // Legacy old editor bg types.
    case fittingTypes.LEGACY_BG_FIT_AND_TILE:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat';
      break;
    case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat-x';
      break;
    case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'repeat-y';
      break;
    case fittingTypes.LEGACY_BG_NORMAL:
      css.container.backgroundSize = 'auto';
      css.container.backgroundRepeat = 'no-repeat';
      break;
  }
  // set alignment
  switch (target.alignment) {
    case alignTypes.CENTER:
      css.container.backgroundPosition = 'center center'; // 50% 50%
      break;
    case alignTypes.LEFT:
      css.container.backgroundPosition = 'left center'; // 0% 50%
      break;
    case alignTypes.RIGHT:
      css.container.backgroundPosition = 'right center'; // 100% 50%
      break;
    case alignTypes.TOP:
      css.container.backgroundPosition = 'center top'; // 50% 0%
      break;
    case alignTypes.BOTTOM:
      css.container.backgroundPosition = 'center bottom'; // 50% 100%
      break;
    case alignTypes.TOP_RIGHT:
      css.container.backgroundPosition = 'right top'; // 100% 0%
      break;
    case alignTypes.TOP_LEFT:
      css.container.backgroundPosition = 'left top'; // 0% 0%
      break;
    case alignTypes.BOTTOM_RIGHT:
      css.container.backgroundPosition = 'right bottom'; // 100% 100%
      break;
    case alignTypes.BOTTOM_LEFT:
      css.container.backgroundPosition = 'left bottom'; // 0% 100%
      break;
  }
  // return background CSS
  return attributes;
}

;// ../../image-kit/dist/esm/engines/attributes/imgAttributes.js

/**
 * align type to position
 * @param verticalMiddle
 * @param horizontalMiddle
 * @param target
 * @returns {{}}
 */
function alignTypeToPosition(verticalMiddle, horizontalMiddle, target) {
  return {
    [alignTypes.TOP_LEFT]: {
      top: 0,
      left: 0
    },
    [alignTypes.TOP_RIGHT]: {
      top: 0,
      right: 0
    },
    [alignTypes.TOP]: {
      top: 0,
      left: horizontalMiddle
    },
    [alignTypes.BOTTOM_LEFT]: {
      bottom: 0,
      left: 0
    },
    [alignTypes.BOTTOM_RIGHT]: {
      bottom: 0,
      right: 0
    },
    [alignTypes.BOTTOM]: {
      bottom: 0,
      left: horizontalMiddle
    },
    [alignTypes.RIGHT]: {
      top: verticalMiddle,
      right: 0
    },
    [alignTypes.LEFT]: {
      top: verticalMiddle,
      left: 0
    },
    [alignTypes.CENTER]: {
      width: target.width,
      height: target.height,
      objectFit: 'none'
    }
  };
}
const alignTypeToPositionStr = {
  [alignTypes.CENTER]: 'center',
  [alignTypes.TOP]: 'top',
  [alignTypes.TOP_LEFT]: 'top left',
  [alignTypes.TOP_RIGHT]: 'top right',
  [alignTypes.BOTTOM]: 'bottom',
  [alignTypes.BOTTOM_LEFT]: 'bottom left',
  [alignTypes.BOTTOM_RIGHT]: 'bottom right',
  [alignTypes.LEFT]: 'left',
  [alignTypes.RIGHT]: 'right'
};
const aligmentDefaults = {
  position: 'absolute',
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
};
/**
 * returns image tag CSS data
 * @param {ImageTransformObject}    transformsObj    transform parts object
 * @param {ImageTransformTarget}    target
 *
 * @returns {ImageAttributes}
 */
function imgAttributes_getCSS(transformsObj, target) {
  const attributes = {
    css: {
      container: {},
      img: {}
    }
  };
  const {
    css
  } = attributes;
  const {
    fittingType
  } = transformsObj;
  const alignType = target.alignment;
  css.container.position = 'relative';
  switch (fittingType) {
    case fittingTypes.ORIGINAL_SIZE:
    case fittingTypes.LEGACY_ORIGINAL_SIZE:
      if (transformsObj.parts && transformsObj.parts.length) {
        css.img.width = transformsObj.parts[0].width;
        css.img.height = transformsObj.parts[0].height;
      } else {
        css.img.width = transformsObj.src.width;
        css.img.height = transformsObj.src.height;
      }
      break;
    case fittingTypes.SCALE_TO_FIT:
    case fittingTypes.LEGACY_FIT_WIDTH:
    case fittingTypes.LEGACY_FIT_HEIGHT:
    case fittingTypes.LEGACY_FULL:
      css.img.width = target.width;
      css.img.height = target.height;
      css.img.objectFit = 'contain';
      css.img.objectPosition = alignTypeToPositionStr[alignType] || 'unset';
      break;
    // BG_NORMAL is a sitebackground legacy for original size fitting type.
    // target width and height were modified in transform.js
    case fittingTypes.LEGACY_BG_NORMAL:
      css.img.width = '100%';
      css.img.height = '100%';
      css.img.objectFit = 'none';
      css.img.objectPosition = alignTypeToPositionStr[alignType] || 'unset';
      break;
    case fittingTypes.STRETCH:
      css.img.width = target.width;
      css.img.height = target.height;
      css.img.objectFit = 'fill';
      break;
    case fittingTypes.SCALE_TO_FILL:
      css.img.width = target.width;
      css.img.height = target.height;
      css.img.objectFit = 'cover';
      break;
  }
  // set alignment in a private case where the image src is smaller than the image container,
  if (typeof css.img.width === 'number' && typeof css.img.height === 'number' && (css.img.width !== target.width || css.img.height !== target.height)) {
    const verticalMiddle = Math.round((target.height - css.img.height) / 2);
    const horizontalMiddle = Math.round((target.width - css.img.width) / 2);
    Object.assign(css.img, aligmentDefaults, alignTypeToPosition(verticalMiddle, horizontalMiddle, target)[alignType]);
  }
  return attributes;
}

;// ../../image-kit/dist/esm/engines/attributes/SVGAttributes.js


/* eslint-disable indent */
/**
 * get CSS or SVG attributes to be used in the browser
 * @param {ImageTransformObject}  transformsObj  transform parts object
 * @param {ImageTransformTarget}  target
 *
 * @returns {SVGImageAttributes}
 */
function getSvgAttr(transformsObj, target) {
  const attributes = {
    css: {
      container: {}
    },
    attr: {
      container: {},
      img: {}
    }
  };
  const {
    css,
    attr
  } = attributes;
  const {
    fittingType
  } = transformsObj;
  const alignType = target.alignment;
  const {
    width: sourceWidth,
    height: sourceHeight
  } = transformsObj.src;
  let imageScale;
  css.container.position = 'relative';
  // populate SVG attributes object
  // eslint-disable-line indent
  switch (fittingType) {
    case fittingTypes.ORIGINAL_SIZE:
    case fittingTypes.LEGACY_ORIGINAL_SIZE:
    case fittingTypes.TILE:
      if (transformsObj.parts && transformsObj.parts.length) {
        attr.img.width = transformsObj.parts[0].width;
        attr.img.height = transformsObj.parts[0].height;
      } else {
        attr.img.width = sourceWidth;
        attr.img.height = sourceHeight;
      }
      attr.img.preserveAspectRatio = 'xMidYMid slice';
      break;
    case fittingTypes.SCALE_TO_FIT:
    case fittingTypes.LEGACY_FIT_WIDTH:
    case fittingTypes.LEGACY_FIT_HEIGHT:
    case fittingTypes.LEGACY_FULL:
      attr.img.width = '100%';
      attr.img.height = '100%';
      attr.img.transform = '';
      attr.img.preserveAspectRatio = '';
      break;
    case fittingTypes.STRETCH:
      attr.img.width = target.width;
      attr.img.height = target.height;
      attr.img.x = 0;
      attr.img.y = 0;
      attr.img.transform = '';
      attr.img.preserveAspectRatio = 'none';
      break;
    case fittingTypes.SCALE_TO_FILL:
      if (!isImageTransformApplicable(transformsObj.src.id)) {
        imageScale = getDimension(sourceWidth, sourceHeight, target.width, target.height, transformTypes.FILL);
        attr.img.width = imageScale.width;
        attr.img.height = imageScale.height;
      } else {
        attr.img.width = target.width;
        attr.img.height = target.height;
      }
      attr.img.x = 0;
      attr.img.y = 0;
      attr.img.transform = '';
      attr.img.preserveAspectRatio = 'xMidYMid slice';
      break;
  }
  // set alignment for cases where the requested src is smaller or bigger than the target element,
  if (typeof attr.img.width === 'number' && typeof attr.img.height === 'number' && (attr.img.width !== target.width || attr.img.height !== target.height)) {
    // x and y to use in svg <pattern> element
    let x = 0;
    let y = 0;
    let right;
    let bottom;
    if (fittingType === fittingTypes.TILE) {
      right = target.width % attr.img.width;
      bottom = target.height % attr.img.height;
    } else {
      right = target.width - attr.img.width;
      bottom = target.height - attr.img.height;
    }
    const center = Math.round(right / 2);
    const middle = Math.round(bottom / 2);
    switch (alignType) {
      case alignTypes.TOP_LEFT:
        x = 0;
        y = 0;
        break;
      case alignTypes.TOP:
        x = center;
        y = 0;
        break;
      case alignTypes.TOP_RIGHT:
        x = right;
        y = 0;
        break;
      case alignTypes.LEFT:
        x = 0;
        y = middle;
        break;
      case alignTypes.CENTER:
        x = center;
        y = middle;
        break;
      case alignTypes.RIGHT:
        x = right;
        y = middle;
        break;
      case alignTypes.BOTTOM_LEFT:
        x = 0;
        y = bottom;
        break;
      case alignTypes.BOTTOM:
        x = center;
        y = bottom;
        break;
      case alignTypes.BOTTOM_RIGHT:
        x = right;
        y = bottom;
        break;
    }
    attr.img.x = x;
    attr.img.y = y;
  }
  attr.container.width = target.width;
  attr.container.height = target.height;
  attr.container.viewBox = [0, 0, target.width, target.height].join(' ');
  // return attributes object
  return attributes;
}
/* eslint-enable indent */

;// ../../image-kit/dist/esm/engines/attributes.js




/**
 * get CSS or SVG attributes to be used in the browser
 * @param {ImageTransformObject}    transformsObj    transform parts object
 * @param {ImageTransformTarget}    target
 *
 * @returns object
 */
function getAttributes(transformsObj, target) {
  let attributesGetter;
  if (target.htmlTag === htmlTag.BG) {
    attributesGetter = getCSS;
  } else if (target.htmlTag === htmlTag.SVG) {
    attributesGetter = getSvgAttr;
  } else {
    attributesGetter = imgAttributes_getCSS;
  }
  return attributesGetter(transformsObj, target);
}

;// ../../image-kit/dist/esm/helpers/browserFeatureSupport.js

/**
 * get a browser detection if running on mobile device
 *
 * @returns {boolean}
 */
function isMobile() {
  return getFeature('isMobile');
}

;// ../../image-kit/dist/esm/helpers/imageTransformParts.js


/**
 * request analysis, returns parsed transforms object
 * @param {object}                  transformsObj
 * @param {ImageTransformSource}    src
 * @param {ImageTransformTarget}    target
 */
function setTransformParts(transformsObj, src, target) {
  let rect;
  // crop source image if needed
  // set crop part and adjust source dimensions
  if (src.crop) {
    rect = getOverlappingRect(src, src.crop);
    if (rect) {
      transformsObj.src.width = rect.width;
      transformsObj.src.height = rect.height;
      transformsObj.src.isCropped = true;
      transformsObj.parts.push(getCropPart(rect));
    }
  }
  // set additional transform part
  switch (transformsObj.fittingType) {
    case fittingTypes.SCALE_TO_FIT:
    case fittingTypes.LEGACY_FIT_WIDTH:
    case fittingTypes.LEGACY_FIT_HEIGHT:
    case fittingTypes.LEGACY_FULL:
    case fittingTypes.FIT_AND_TILE:
    case fittingTypes.LEGACY_BG_FIT_AND_TILE:
    case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:
    case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:
    case fittingTypes.LEGACY_BG_NORMAL:
      // fit
      transformsObj.parts.push(getFitPart(transformsObj, target));
      break;
    case fittingTypes.SCALE_TO_FILL:
      // fill
      transformsObj.parts.push(getFillPart(transformsObj, target));
      break;
    case fittingTypes.STRETCH:
      // stretch
      transformsObj.parts.push(getStretchPart(transformsObj, target));
      break;
    case fittingTypes.TILE_HORIZONTAL:
    case fittingTypes.TILE_VERTICAL:
    case fittingTypes.TILE:
    case fittingTypes.LEGACY_ORIGINAL_SIZE:
    case fittingTypes.ORIGINAL_SIZE:
      // use crop transform
      // if crop of source image was requested adjust cropping rectangle
      rect = getAlignedRect(transformsObj.src, target, transformsObj.focalPoint, target.alignment);
      if (transformsObj.src.isCropped) {
        Object.assign(transformsObj.parts[0], rect);
        // update source width & height accordingly
        transformsObj.src.width = rect.width;
        transformsObj.src.height = rect.height;
      } else {
        transformsObj.parts.push(getCropPart(rect));
      }
      break;
    // ---------------------------------------------------------------------------------------
    // handles a legacy bug on bgImageStrip, background html tag
    // component Full Width Strip stored incorrect image source width and height
    // ---------------------------------------------------------------------------------------
    case fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:
    case fittingTypes.LEGACY_STRIP_TILE_VERTICAL:
    case fittingTypes.LEGACY_STRIP_TILE:
    case fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:
      // crop request of source image is not supported
      // use legacy crop
      transformsObj.parts.push(getLegacyCropPart(target));
      break;
    case fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:
    case fittingTypes.LEGACY_STRIP_FIT_AND_TILE:
      // legacy fit
      transformsObj.parts.push(getLegacyFitPart(target));
      break;
    case fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:
      // legacy fill
      transformsObj.parts.push(getLegacyFillPart(target));
      break;
  }
}
/**
 * returns fit part of the image transform uri
 * @param {object}                  transformsObj
 * @param {ImageTransformTarget}    target
 *
 * @returns {TransformFitPart}
 */
function getFitPart(transformsObj, target) {
  // calculate the transformed image size needed
  const transformedData = getTransformData(transformsObj.src.width, transformsObj.src.height, transformTypes.FIT, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);
  const isMissingSrcDimensions = !transformsObj.src.width || !transformsObj.src.height;
  const transformType = isMissingSrcDimensions ? transformTypes.FIT : transformTypes.FILL;
  // return fit transform data
  return {
    transformType,
    width: Math.round(transformedData.width),
    height: Math.round(transformedData.height),
    alignment: alignTypesMap.center,
    upscale: transformedData.scaleFactor > 1,
    forceUSM: transformedData.forceUSM,
    scaleFactor: transformedData.scaleFactor,
    cssUpscaleNeeded: transformedData.cssUpscaleNeeded,
    upscaleMethodValue: transformedData.upscaleMethodValue
  };
}
/**
 * returns fill part of the image transform uri
 * @param {ImageTransformObject} transformsObj
 * @param {ImageTransformTarget} target
 *
 * @returns {TransformFillPart}
 */
function getFillPart(transformsObj, target) {
  // calculate the transformed image size needed
  const transformedData = getTransformData(transformsObj.src.width, transformsObj.src.height, transformTypes.FILL, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);
  const focalPoint = getFocalPoint(transformsObj.focalPoint);
  const transformType = focalPoint ? transformTypes.FILL_FOCAL : transformTypes.FILL;
  return {
    transformType,
    width: Math.round(transformedData.width),
    height: Math.round(transformedData.height),
    alignment: getAlignment(target),
    focalPointX: focalPoint && focalPoint.x,
    focalPointY: focalPoint && focalPoint.y,
    upscale: transformedData.scaleFactor > 1,
    forceUSM: transformedData.forceUSM,
    scaleFactor: transformedData.scaleFactor,
    cssUpscaleNeeded: transformedData.cssUpscaleNeeded,
    upscaleMethodValue: transformedData.upscaleMethodValue
  };
}
/**
 * returns fill part of the image transform uri
 * @param {ImageTransformObject} transformsObj
 * @param {ImageTransformTarget} target
 *
 * @returns {TransformFitPart}
 */
function getStretchPart(transformsObj, target) {
  // stretch data
  const scaleFactor = getScaleFactor(transformsObj.src.width, transformsObj.src.height, target.width, target.height, transformTypes.FILL);
  const clonedTarget = {
    ...target
  };
  clonedTarget.width = transformsObj.src.width * scaleFactor;
  clonedTarget.height = transformsObj.src.height * scaleFactor;
  // return stretch part
  return getFitPart(transformsObj, clonedTarget);
}
/**
 * returns crop part of the image transform uri
 * @param {{x: number, y: number, width: number, height: number}}  rect     x, y, width, height
 *
 * @returns {TransformCropPart}
 */
function getCropPart(rect) {
  return {
    transformType: transformTypes.CROP,
    x: Math.round(rect.x),
    y: Math.round(rect.y),
    width: Math.round(rect.width),
    height: Math.round(rect.height),
    upscale: false,
    forceUSM: false,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}
// ---------------------------------------------------------------------------------------
// handles a legacy bug on bgImageStrip, background html tag
// component Full Width Strip stored incorrect image source width and height
// ---------------------------------------------------------------------------------------
/**
 * returns fit part of the image transform uri
 * @param {ImageTransformTarget}    target
 *
 * @returns {TransformLegacyFitPart}
 */
function getLegacyFitPart(target) {
  return {
    transformType: transformTypes.FIT,
    width: Math.round(target.width),
    height: Math.round(target.height),
    upscale: false,
    forceUSM: true,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}
/**
 * returns fill part of the image transform uri
 * @param {ImageTransformTarget}    target
 *
 * @returns {TransformLegacyFillPart}
 */
function getLegacyFillPart(target) {
  return {
    transformType: transformTypes.LEGACY_FILL,
    width: Math.round(target.width),
    height: Math.round(target.height),
    alignment: getAlignment(target),
    upscale: false,
    forceUSM: true,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}
/**
 * returns legacy crop part of the image transform uri
 * @param {ImageTransformTarget}     target
 *
 * @returns {TransformLegacyCropPart}
 */
function getLegacyCropPart(target) {
  return {
    transformType: transformTypes.LEGACY_CROP,
    width: Math.round(target.width),
    height: Math.round(target.height),
    alignment: getAlignment(target),
    upscale: false,
    forceUSM: false,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}

;// ../../image-kit/dist/esm/helpers/imageTransformOptions.js



/**
 * returns image filters part of the image transform uri
 * @param {ImageTransformObject}    transformsObj    transform parts object
 * @param {ImageTransformOptions}   [options]
 */
function setTransformOptions(transformsObj, options) {
  var _options;
  options = options || {};
  // options - general
  transformsObj.quality = getQuality(transformsObj, options);
  transformsObj.progressive = getProgressive(options);
  transformsObj.watermark = getWatermark(options);
  transformsObj.autoEncode = options.autoEncode ?? true;
  transformsObj.encoding = (_options = options) == null ? void 0 : _options.encoding;
  // options - filters & adjustments
  transformsObj.unsharpMask = getUnsharpMask(transformsObj, options);
  transformsObj.filters = getFilters(options);
}
/**
 *
 * @param {ImageTransformOptions}   options
 * @returns {string}
 */
function getWatermark(options) {
  return options.watermark;
}
/**
 * returns progressive if required
 * @param {ImageTransformOptions}   options
 *
 * @returns {boolean}
 */
function getProgressive(options) {
  return options.progressive !== false;
}
/**
 * returns image filters part of the image transform uri
 * @param {ImageTransformObject}    transformsObj    transform parts object
 * @param {ImageTransformOptions}   options
 *
 * @returns {number}
 */
function getQuality(transformsObj, options) {
  const isPNG = transformsObj.fileType === fileType.PNG;
  const isJPG = transformsObj.fileType === fileType.JPG;
  const isWEBP = transformsObj.fileType === fileType.WEBP;
  const isAVIF = transformsObj.fileType === fileType.AVIF;
  const isQualitySupported = isJPG || isPNG || isWEBP || isAVIF;
  if (isQualitySupported) {
    const transformData = last(transformsObj.parts);
    const defaultQuality = getPreferredImageQuality(transformData.width, transformData.height);
    let quality = options.quality && options.quality >= 5 && options.quality <= 90 ? options.quality : defaultQuality;
    // increase quality by 5 for webp images
    quality = isPNG ? quality + 5 : quality;
    return quality;
  }
  // quality not supported
  return 0;
}
/**
 * returns the desired transformed image filters
 * @param {ImageTransformOptions}   options
 *
 * @returns {object}
 */
function getFilters(options) {
  const filterOptions = options.filters || {};
  const filters = {};
  // contrast
  if (isValidImageFilter(filterOptions[imageFilters.CONTRAST], -100, 100)) {
    filters[imageFilters.CONTRAST] = filterOptions[imageFilters.CONTRAST];
  }
  // brightness
  if (isValidImageFilter(filterOptions[imageFilters.BRIGHTNESS], -100, 100)) {
    filters[imageFilters.BRIGHTNESS] = filterOptions[imageFilters.BRIGHTNESS];
  }
  // saturation
  if (isValidImageFilter(filterOptions[imageFilters.SATURATION], -100, 100)) {
    filters[imageFilters.SATURATION] = filterOptions[imageFilters.SATURATION];
  }
  // hue
  if (isValidImageFilter(filterOptions[imageFilters.HUE], -180, 180)) {
    filters[imageFilters.HUE] = filterOptions[imageFilters.HUE];
  }
  // blur
  if (isValidImageFilter(filterOptions[imageFilters.BLUR], 0, 100)) {
    filters[imageFilters.BLUR] = filterOptions[imageFilters.BLUR];
  }
  return filters;
}
/**
 * indicates if requested filter value is valid
 * @param {number|undefined}  filterValue     filter's value
 * @param {number}  minValue        min range
 * @param {number}  maxValue        max range
 *
 * @returns {boolean}
 */
function isValidImageFilter(filterValue, minValue, maxValue) {
  // check if filter name and filter values range valid
  return typeof filterValue === 'number' && !isNaN(filterValue) && filterValue !== 0 && filterValue >= minValue && filterValue <= maxValue;
}
/**
 * returns the desired transformed image unSharpMask values
 * @param {ImageTransformObject}    transformsObj    transform parts object
 * @param {ImageTransformOptions}   options
 *
 * @returns {object}
 */
function getUnsharpMask(transformsObj, options) {
  // If options.unsharpMask is a valid value, use it
  if (isUSMValid(options.unsharpMask)) {
    var _options$unsharpMask, _options$unsharpMask2, _options$unsharpMask3;
    // If we got usm, change values to have trailing zeros (.00), else return undefined
    return {
      radius: roundToFixed((_options$unsharpMask = options.unsharpMask) == null ? void 0 : _options$unsharpMask.radius, 2),
      amount: roundToFixed((_options$unsharpMask2 = options.unsharpMask) == null ? void 0 : _options$unsharpMask2.amount, 2),
      threshold: roundToFixed((_options$unsharpMask3 = options.unsharpMask) == null ? void 0 : _options$unsharpMask3.threshold, 2)
    };
    // if options.unsharpMask is not all zeros and not valid and usm should be used, use default
  } else if (!isZeroUSM(options.unsharpMask) && isUSMNeeded(transformsObj)) {
    return defaultUSM;
  }
  return;
}
/**
 * indicates if usm is needed
 * @param {ImageTransformObject}      transformsObj   transform parts object
 *
 * @returns {boolean}
 */
function isUSMNeeded(transformsObj) {
  // ---------------------------------------------------------------------------------------
  // do not apply usm if transformed image width & height is same as source image or larger
  // and no force usm is desired
  // and transform type is not fit
  // ---------------------------------------------------------------------------------------
  const transformPart = last(transformsObj.parts);
  const upscale = transformPart.scaleFactor >= 1;
  // return if usm is needed
  return !upscale || transformPart.forceUSM || transformPart.transformType === transformTypes.FIT;
}
/**
 * indicates if all usm values are presented and in range
 * @param {OptionUnsharpMask|undefined}  usm     unsharp mask
 *
 * @returns {boolean}
 */
function isUSMValid(usm) {
  usm = usm || {};
  const radius = typeof usm.radius === 'number' && !isNaN(usm.radius) && usm.radius >= 0.1 && usm.radius <= 500;
  const amount = typeof usm.amount === 'number' && !isNaN(usm.amount) && usm.amount >= 0 && usm.amount <= 10;
  const threshold = typeof usm.threshold === 'number' && !isNaN(usm.threshold) && usm.threshold >= 0 && usm.threshold <= 255;
  // return is a valid USM data
  return radius && amount && threshold;
}
/**
 * indicates if all usm values are presented and are zero. an explicit request to not apply usm
 * @param {OptionUnsharpMask|undefined}  usm     unsharp mask
 *
 * @returns {boolean}
 */
function isZeroUSM(usm) {
  usm = usm || {};
  return typeof usm.radius === 'number' && !isNaN(usm.radius) && usm.radius === 0 && typeof usm.amount === 'number' && !isNaN(usm.amount) && usm.amount === 0 && typeof usm.threshold === 'number' && !isNaN(usm.threshold) && usm.threshold === 0;
}

;// ../../image-kit/dist/esm/api/transform.js





/**
 * returns image transform data
 *
 * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src                 source image
 * @param {ImageTransformTarget}    target              target component
 * @param {ImageTransformOptions}   [options]           transform options
 *
 * @returns {ImageTransformObject}
 */
function getTransform(fittingType, src, target, options) {
  const _isSEOBot = isSEOBot(options);
  const fileType = getFileType(src.id);
  const fileName = getFileName(src.id, src.name);
  const devicePixelRatio = _isSEOBot ? 1 : getDevicePixelRatio(target);
  const fileExtension = getFileExtension(src.id);
  const preferredExtension = fileExtension;
  const canTransformImage = isImageTransformApplicable(src.id, options == null ? void 0 : options.hasAnimation, options == null ? void 0 : options.allowAnimatedTransform);
  const transformsObj = {
    fileName,
    fileExtension,
    fileType,
    fittingType,
    preferredExtension,
    src: {
      id: src.id,
      width: src.width,
      height: src.height,
      isCropped: false,
      isAnimated: imageIsAnimated(src.id, options == null ? void 0 : options.hasAnimation)
    },
    focalPoint: {
      x: src.focalPoint && src.focalPoint.x,
      y: src.focalPoint && src.focalPoint.y
    },
    parts: [],
    // options - general
    devicePixelRatio,
    quality: 0,
    upscaleMethod: getUpscaleString(options),
    progressive: true,
    watermark: '',
    unsharpMask: {},
    filters: {},
    transformed: canTransformImage
  };
  if (canTransformImage) {
    setTransformParts(transformsObj, src, target);
    setTransformOptions(transformsObj, options);
  }
  return transformsObj;
}
/**
 * returns target data
 * handle legacy BG site if needed
 *
 * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src                 source image
 * @param {ImageTransformTarget}    target              target component
 *
 * @returns {Object}
 */
function getTarget(fittingType, src, target) {
  const targetObj = {
    ...target
  };
  const _isMobile = isMobile();
  // handle site BG legacy fitting types (desktop & mobile)
  switch (fittingType) {
    case fittingTypes.LEGACY_BG_FIT_AND_TILE:
    case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:
    case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:
    case fittingTypes.LEGACY_BG_NORMAL:
      const maxBGSiteLegacyWidth = _isMobile ? MOBILE_MAX_BG_SITE_LEGACY_WIDTH : DSKTP_MAX_BG_SITE_LEGACY_WIDTH;
      const maxBGSiteLegacyHeight = _isMobile ? MOBILE_MAX_BG_SITE_LEGACY_HEIGHT : DSKTP_MAX_BG_SITE_LEGACY_HEIGHT;
      targetObj.width = Math.min(maxBGSiteLegacyWidth, src.width);
      targetObj.height = Math.min(maxBGSiteLegacyHeight, Math.round(targetObj.width / (src.width / src.height)));
      // for legacy types force htmlTag='bg' and devicePixelRatio=1
      targetObj.pixelAspectRatio = 1;
  }
  return targetObj;
}

;// ../../image-kit/dist/esm/engines/transforms.js


// transform templates
const fitTemplate = template`fit/w_${'width'},h_${'height'}`;
const fillTemplate = template`fill/w_${'width'},h_${'height'},al_${'alignment'}`;
const fillFocalTemplate = template`fill/w_${'width'},h_${'height'},fp_${'focalPointX'}_${'focalPointY'}`;
const cropTemplate = template`crop/x_${'x'},y_${'y'},w_${'width'},h_${'height'}`;
// legacy templates
const legacyCropTemplate = template`crop/w_${'width'},h_${'height'},al_${'alignment'}`;
const legacyFillTemplate = template`fill/w_${'width'},h_${'height'},al_${'alignment'}`;
// upscale template
const upscaleTemplate = template`,lg_${'upscaleMethodValue'}`;
// options templates
const qualityTemplate = template`,q_${'quality'}`;
const qualityAutoTemplate = template`,quality_auto`;
const unSharpMaskTemplate = template`,usm_${'radius'}_${'amount'}_${'threshold'}`;
const nonProgressiveTemplate = template`,bl`;
const watermarkTemplate = template`,wm_${'watermark'}`;
const filterTemplatesMap = {
  [imageFilters.CONTRAST]: template`,con_${'contrast'}`,
  [imageFilters.BRIGHTNESS]: template`,br_${'brightness'}`,
  [imageFilters.SATURATION]: template`,sat_${'saturation'}`,
  [imageFilters.HUE]: template`,hue_${'hue'}`,
  [imageFilters.BLUR]: template`,blur_${'blur'}`
};
const autoEncodeTemplate = template`,enc_auto`;
const AVIFEncodeTemplate = template`,enc_avif`;
const pAVIFEncodeTemplate = template`,enc_pavif`;
const animatedTransformTemplate = template`,pstr`;
/**
 * returns image transform uri
 * @param {object}  transformsObj
 *
 * @returns {string}
 */
function getImageURI(transformsObj) {
  var _transformsObj$src;
  // construct image transforms
  const transformsObjStrArr = [];
  // construct transform
  transformsObj.parts.forEach(transformPart => {
    switch (transformPart.transformType) {
      case transformTypes.CROP:
        transformsObjStrArr.push(cropTemplate(transformPart));
        break;
      case transformTypes.LEGACY_CROP:
        transformsObjStrArr.push(legacyCropTemplate(transformPart));
        break;
      case transformTypes.LEGACY_FILL:
        let legacyFillStr = legacyFillTemplate(transformPart);
        if (transformPart.upscale) {
          legacyFillStr += upscaleTemplate(transformPart);
        }
        transformsObjStrArr.push(legacyFillStr);
        break;
      case transformTypes.FIT:
        let fitStr = fitTemplate(transformPart);
        if (transformPart.upscale) {
          fitStr += upscaleTemplate(transformPart);
        }
        transformsObjStrArr.push(fitStr);
        break;
      case transformTypes.FILL:
        let fillStr = fillTemplate(transformPart);
        if (transformPart.upscale) {
          fillStr += upscaleTemplate(transformPart);
        }
        transformsObjStrArr.push(fillStr);
        break;
      case transformTypes.FILL_FOCAL:
        let fillFocalStr = fillFocalTemplate(transformPart);
        if (transformPart.upscale) {
          fillFocalStr += upscaleTemplate(transformPart);
        }
        transformsObjStrArr.push(fillFocalStr);
        break;
    }
  });
  let transformsStr = transformsObjStrArr.join('/');
  // construct transform options
  // quality
  if (transformsObj.quality) {
    transformsStr += qualityTemplate(transformsObj);
  }
  // un-sharp mask
  if (transformsObj.unsharpMask) {
    transformsStr += unSharpMaskTemplate(transformsObj.unsharpMask);
  }
  // progressive
  if (!transformsObj.progressive) {
    transformsStr += nonProgressiveTemplate(transformsObj);
  }
  // watermark
  if (transformsObj.watermark) {
    transformsStr += watermarkTemplate(transformsObj);
  }
  // filters
  if (transformsObj.filters) {
    transformsStr += Object.keys(transformsObj.filters).map(filterName => filterTemplatesMap[filterName](transformsObj.filters)).join('');
  }
  // encoding
  if (transformsObj.fileType !== fileType.GIF) {
    if (transformsObj.encoding === encodingTypes.AVIF) {
      transformsStr += AVIFEncodeTemplate(transformsObj);
      transformsStr += qualityAutoTemplate(transformsObj);
    } else if (transformsObj.encoding === encodingTypes.PAVIF) {
      transformsStr += pAVIFEncodeTemplate(transformsObj);
      transformsStr += qualityAutoTemplate(transformsObj);
    } else if (transformsObj.autoEncode) {
      transformsStr += autoEncodeTemplate(transformsObj);
    }
  }
  // animated image poster transform
  if ((_transformsObj$src = transformsObj.src) != null && _transformsObj$src.isAnimated && transformsObj.transformed) {
    transformsStr += animatedTransformTemplate(transformsObj);
  }
  // image url string
  return `${transformsObj.src.id}/${API_VERSION}/${transformsStr}/${transformsObj.fileName}.${transformsObj.preferredExtension}`;
}

;// ../../image-kit/dist/esm/api/uri.js



/**
 * returns image transform uri
 *
 * @param {string}                  fittingType         imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src                 source image
 * @param {ImageTransformTarget}    target              target component
 * @param {ImageTransformOptions}   options             transform options
 * @param {Object}                  [transformObj]      transform data object to use
 *
 * @returns {string}
 */
function getURI(fittingType, src, target, options, transformObj) {
  var _options, _options2;
  if (options === void 0) {
    options = {};
  }
  // check if image transformation is applicable (e.g. .gif, .wix_mp)
  if (isImageTransformApplicable(src.id, (_options = options) == null ? void 0 : _options.hasAnimation, (_options2 = options) == null ? void 0 : _options2.allowAnimatedTransform)) {
    if (imageServiceUtils_isWEBP(src.id) || isAVIF(src.id)) {
      // exclude alignment, focalPoint and crop from webp and avif transformation in order not to break webp or avif images before transformation was enabled
      const {
        alignment,
        ...transformTarget
      } = target;
      src.focalPoint = {
        x: undefined,
        y: undefined
      };
      src == null || delete src.crop;
      transformObj = getTransform(fittingType, src, transformTarget, options);
    } else {
      transformObj = transformObj || getTransform(fittingType, src, target, options);
    }
    // set the uri property
    return getImageURI(transformObj);
  }
  return src.id;
}

;// ../../image-kit/dist/esm/api/srcset.js

function getSrcset(fittingType, src, target, options, data) {
  const dpr = target.pixelAspectRatio || 1;
  return {
    dpr: [`${dpr === 1 ? data.uri : getURI(fittingType, src, {
      ...target,
      pixelAspectRatio: 1
    }, options)} 1x`, `${dpr === 2 ? data.uri : getURI(fittingType, src, {
      ...target,
      pixelAspectRatio: 2
    }, options)} 2x`]
  };
}

;// ../../image-kit/dist/esm/helpers/imagePlaceholderUtils.js


const ALIGN_TYPE_TO_POSITION = {
  [alignTypes.CENTER]: '50% 50%',
  [alignTypes.TOP_LEFT]: '0% 0%',
  [alignTypes.TOP_RIGHT]: '100% 0%',
  [alignTypes.TOP]: '50% 0%',
  [alignTypes.BOTTOM_LEFT]: '0% 100%',
  [alignTypes.BOTTOM_RIGHT]: '100% 100%',
  [alignTypes.BOTTOM]: '50% 100%',
  [alignTypes.RIGHT]: '100% 50%',
  [alignTypes.LEFT]: '0% 50%'
};
const POSITION_TO_ALIGN_TYPE = Object.entries(ALIGN_TYPE_TO_POSITION).reduce((acc, _ref) => {
  let [align, position] = _ref;
  acc[position] = align;
  return acc;
}, {});
const TILE_FITTING_TYPES = [fittingTypes.TILE, fittingTypes.TILE_HORIZONTAL, fittingTypes.TILE_VERTICAL, fittingTypes.LEGACY_BG_FIT_AND_TILE, fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL, fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL];
const NON_SCALING_FITTING_TYPES = [fittingTypes.LEGACY_ORIGINAL_SIZE, fittingTypes.ORIGINAL_SIZE, fittingTypes.LEGACY_BG_NORMAL];
function getIsFakeTile(fittingType, src, _ref2) {
  let {
    width: targetWidth,
    height: targetHeight
  } = _ref2;
  return fittingType === fittingTypes.TILE && src.width > targetWidth && src.height > targetHeight;
}
/**
 *
 * @param {FittingType}             fittingType      imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src              source image
 * @param {Dimensions}              target           target container dimensions
 * @param {boolean}                 [isSEOBot=false] whether it is a render for a bot request
 * @returns {Dimensions} scaled dimensions
 */
function getScaledDimensions(fittingType, src, _ref3, isSEOBot) {
  let {
    width,
    height
  } = _ref3;
  if (isSEOBot === void 0) {
    isSEOBot = false;
  }
  if (isSEOBot) {
    return {
      width,
      height
    };
  }
  const isScalable = !NON_SCALING_FITTING_TYPES.includes(fittingType);
  const isFakeTile = getIsFakeTile(fittingType, src, {
    width,
    height
  });
  const isTile = !isFakeTile && TILE_FITTING_TYPES.includes(fittingType);
  const _width = isTile ? src.width : width;
  const _height = isTile ? src.height : height;
  const scaleFactor = isScalable ? getScaleFactorByWidth(_width, isPNG(src.id)) : 1;
  return {
    width: isFakeTile ? 1920 : _width * scaleFactor,
    height: _height * scaleFactor
  };
}
/**
 *
 * @param {FittingType} fittingType  imageServicesTypes.fittingTypes
 * @param {boolean} isFakeTile
 * @returns {string} fittingType
 */
function getConvertedFitting(fittingType, isFakeTile) {
  const isTile = TILE_FITTING_TYPES.includes(fittingType) && !isFakeTile;
  const isFill = fittingType === fittingTypes.SCALE_TO_FILL;
  return isFill || isTile ? fittingTypes.SCALE_TO_FIT : fittingType;
}
/**
 *
 * @param {ImageTransformSource}    src                 source image
 * @param {number || ''}            width
 * @param {number || ''}            height
 * @returns {Dimensions}    width, height
 */
function validateTargetDimensions(src, _ref4) {
  let {
    width,
    height
  } = _ref4;
  if (!width || !height) {
    const _width = width || Math.min(980, src.width);
    const heightRatio = _width / src.width;
    return {
      width: _width,
      height: height || src.height * heightRatio
    };
  }
  return {
    width,
    height
  };
}
/**
 *
 * @param {number} width
 * @param {boolean} isHighQuality
 * @return {number}
 */
function getScaleFactorByWidth(width, isHighQuality) {
  if (width > 900) {
    return isHighQuality ? 0.05 : 0.15;
  } else if (width > 500) {
    return isHighQuality ? 0.1 : 0.18;
  } else if (width > 200) {
    return 0.25;
  }
  return 1;
}
/**
 *
 * @param {number} width
 * @param {FittingType} fittingType imageServicesTypes.fittingTypes
 * @param {boolean} isSEOBot
 * @return {number}
 */
function getBlurValue(width, fittingType, isSEOBot) {
  if (isSEOBot) {
    return 0;
  }
  if (TILE_FITTING_TYPES.includes(fittingType)) {
    return 1;
  }
  if (width > 200) {
    return 2;
  }
  return 3;
}
/**
 *
 * @param {FittingType}                       fittingType
 * @param {ImageTransformSource}              src                  source image
 * @param {{width?: number; height?: number}} target               target element
 * @param {string}                            [alignment='center']
 * @returns {{img}, {container}}
 */
function getCSSOverrides(fittingType, src, target, alignment) {
  if (alignment === void 0) {
    alignment = 'center';
  }
  const returnValue = {
    img: {},
    container: {}
  };
  if (fittingType === fittingTypes.SCALE_TO_FILL) {
    const alignTypeFromFocalPoint = src.focalPoint && convertFocalPointToAlignType(src.focalPoint);
    const alignType = alignTypeFromFocalPoint || alignment;
    if (src.focalPoint && !alignTypeFromFocalPoint) {
      returnValue.img = {
        objectPosition: convertFillFocalToPosition(src, target, src.focalPoint)
      };
    } else {
      returnValue.img = {
        objectPosition: ALIGN_TYPE_TO_POSITION[alignType]
      };
    }
  } else if ([fittingTypes.LEGACY_ORIGINAL_SIZE, fittingTypes.ORIGINAL_SIZE].includes(fittingType)) {
    returnValue.img = {
      objectFit: 'none',
      top: 'auto',
      left: 'auto',
      right: 'auto',
      bottom: 'auto'
    };
  } else if (TILE_FITTING_TYPES.includes(fittingType)) {
    returnValue.container = {
      backgroundSize: `${src.width}px ${src.height}px`
    };
  }
  return returnValue;
}
/**
 * Try to convert focal point value to 9 grid alignment value
 *
 * @param {Point}    focalPoint
 * @returns {AlignType} align type
 */
function convertFocalPointToAlignType(focalPoint) {
  const position = `${focalPoint.x}% ${focalPoint.y}%`;
  return POSITION_TO_ALIGN_TYPE[position] || '';
}
/**
 *
 * @param {Dimensions} src source dimensions
 * @param {width?: number; height?: number} target target dimensions
 * @param {Point} focalPoint x/y as 0-100 percentages
 * @returns {string} in 'x% y%' format
 */
function convertFillFocalToPosition(src, target, focalPoint) {
  const {
    width: sW,
    height: sH
  } = src;
  const {
    width: tW,
    height: tH
  } = target;
  const {
    x: fpX,
    y: fpY
  } = focalPoint;
  if (!tW || !tH) {
    return `${fpX}% ${fpY}%`;
  }
  const fillScaleFactor = Math.max(tW / sW, tH / sH);
  const imgScaledW = sW * fillScaleFactor;
  const imgScaledH = sH * fillScaleFactor;
  const x = Math.max(0, Math.min(imgScaledW - tW, imgScaledW * (fpX / 100) - tW / 2));
  const y = Math.max(0, Math.min(imgScaledH - tH, imgScaledH * (fpY / 100) - tH / 2));
  const posX = x && Math.floor(x / (imgScaledW - tW) * 100);
  const posY = y && Math.floor(y / (imgScaledH - tH) * 100);
  return `${posX}% ${posY}%`;
}

;// ../../image-kit/dist/esm/api/max/api.js







const PLACEHOLDER_IMG_CSS_OVERRIDES = {
  width: '100%',
  height: '100%'
};
/**
 * returns image _placeholder_ transform uri and the
 * needed css for alignment and positioning
 *
 * @param {FittingType}             fittingType imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src         image
 * @param {ImagePlaceholderTransformTarget}    target      target dimensions
 * @param {ImageTransformOptions} [options]   environment / transformation  options
 *
 * @returns {ImageDataAttributes}
 */
function getPlaceholder(fittingType, src, target, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    autoEncode = true,
    isSEOBot,
    shouldLoadHQImage,
    hasAnimation,
    allowAnimatedTransform,
    encoding
  } = options;
  if (!isValidRequest(fittingType, src, target)) {
    return emptyData;
  }
  const IS_IN_PLACEHOLDER_FLOW = typeof allowAnimatedTransform === 'undefined' ? true : allowAnimatedTransform;
  const canTransformImage = isImageTransformApplicable(src.id, hasAnimation, IS_IN_PLACEHOLDER_FLOW);
  if (!canTransformImage || shouldLoadHQImage) {
    /* Either:
     * 1. Transform isn't applicable so target is original size applied with fluid CSS
     * 2. User asked for an HQ image, so they must have supplied target size (width/height)
     */
    return getData(fittingType, src, target, {
      ...options,
      autoEncode,
      useSrcset: canTransformImage
    });
  }
  // If there aren't dimensions, we make them up
  const newTarget = {
    ...target,
    ...validateTargetDimensions(src, target)
  };
  const {
    alignment,
    htmlTag
  } = newTarget;
  const isFakeTile = getIsFakeTile(fittingType, src, newTarget);
  const scaledDimensions = getScaledDimensions(fittingType, src, newTarget, isSEOBot);
  const blur = getBlurValue(newTarget.width, fittingType, isSEOBot);
  const convertedFittingType = getConvertedFitting(fittingType, isFakeTile);
  const overrideCSS = getCSSOverrides(fittingType, src, target, alignment);
  const {
    uri
  } = getData(convertedFittingType, src, {
    ...scaledDimensions,
    alignment,
    htmlTag
  }, {
    autoEncode,
    filters: blur ? {
      blur
    } : {},
    hasAnimation,
    allowAnimatedTransform: IS_IN_PLACEHOLDER_FLOW,
    encoding
  });
  const {
    attr = {},
    css
  } = getData(fittingType, src, {
    ...newTarget,
    alignment,
    htmlTag
  }, {});
  css.img = css.img || {};
  css.container = css.container || {};
  Object.assign(css.img, overrideCSS.img, PLACEHOLDER_IMG_CSS_OVERRIDES);
  Object.assign(css.container, overrideCSS.container);
  return {
    uri,
    css,
    attr,
    transformed: true
  };
}
/**
 * returns image transform uri and the
 * needed css for alignment and positioning
 *
 * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src                 source image
 * @param {ImageTransformTarget}    target              target component
 * @param {ImageTransformOptions}   [options]          transform options
 *
 * @returns {ImageDataAttributes}
 */
function getData(fittingType, src, target, options) {
  let data = {};
  // check if valid request
  if (isValidRequest(fittingType, src, target)) {
    // handle site BG legacy fitting types if needed
    const targetObj = getTarget(fittingType, src, target);
    // parse request and create working OBJ
    const transformObj = getTransform(fittingType, src, targetObj, options);
    data.uri = getURI(fittingType, src, targetObj, options, transformObj);
    if (options != null && options.useSrcset) {
      data.srcset = getSrcset(fittingType, src, targetObj, options, data);
    }
    // set the CSS or the SVG property
    Object.assign(data, getAttributes(transformObj, targetObj), {
      transformed: transformObj.transformed
    });
  } else {
    // empty data
    data = emptyData;
  }
  // return data to be used in html
  return data;
}

;// ../../image-kit/dist/esm/api/uri/index.js





/**
 * returns image transform uri
 *
 * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes
 * @param {ImageTransformSource}    src                 source image
 * @param {ImageTransformTarget}    target              target component
 * @param {ImageTransformOptions}   [options]           transform options
 *
 * @returns {{uri: string}}
 */
function uri_getData(fittingType, src, target, options) {
  // check if valid request
  if (isValidRequest(fittingType, src, target)) {
    // handle site BG legacy fitting types
    const targetObj = getTarget(fittingType, src, target);
    // parse request and create working OBJ
    const transformObj = getTransform(fittingType, src, targetObj, options);
    return {
      uri: getURI(fittingType, src, targetObj, options || {}, transformObj)
    };
  }
  return {
    uri: ''
  };
}

;// ../../image-kit/dist/esm/sdk/api.js


const wixStatic = 'https://static.wixstatic.com/';
const wixStaticWithMedia = 'https://static.wixstatic.com/media/';
const HAS_MEDIA_PREFIX_RE = /^media\//i;
const devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
const getWixStaticURL = uri => HAS_MEDIA_PREFIX_RE.test(uri) ? `${wixStatic}${uri}` : `${wixStaticWithMedia}${uri}`;
const getURL = (uri, options) => {
  const baseHostURL = options && options.baseHostURL;
  return baseHostURL ? `${baseHostURL}${uri}` : getWixStaticURL(uri);
};
function getScaleToFitImageURL(relativeUrl, sourceWidth, sourceHeight, targetWidth, targetHeight, options) {
  const data = uri_getData(fittingTypes.SCALE_TO_FIT, {
    id: relativeUrl,
    width: sourceWidth,
    height: sourceHeight,
    name: options && options.name
  }, {
    width: targetWidth,
    height: targetHeight,
    htmlTag: htmlTag.IMG,
    alignment: alignTypes.CENTER,
    pixelAspectRatio: (options == null ? void 0 : options.devicePixelRatio) ?? devicePixelRatio
  }, options);
  return getURL(data.uri, options);
}
function getScaleToFillImageURL(relativeUrl, sourceWidth, sourceHeight, targetWidth, targetHeight, options) {
  const data = uri_getData(fittingTypes.SCALE_TO_FILL, {
    id: relativeUrl,
    width: sourceWidth,
    height: sourceHeight,
    name: options && options.name,
    focalPoint: {
      x: options && options.focalPoint && options.focalPoint.x,
      y: options && options.focalPoint && options.focalPoint.y
    }
  }, {
    width: targetWidth,
    height: targetHeight,
    htmlTag: htmlTag.IMG,
    alignment: alignTypes.CENTER,
    pixelAspectRatio: (options == null ? void 0 : options.devicePixelRatio) ?? devicePixelRatio
  }, options);
  return getURL(data.uri, options);
}
function getCropImageURL(relativeUrl, sourceWidth, sourceHeight, cropX, cropY, cropWidth, cropHeight, targetWidth, targetHeight, options) {
  const data = uri_getData(fittingTypes.SCALE_TO_FILL, {
    id: relativeUrl,
    width: sourceWidth,
    height: sourceHeight,
    name: options && options.name,
    crop: {
      x: cropX,
      y: cropY,
      width: cropWidth,
      height: cropHeight
    }
  }, {
    width: targetWidth,
    height: targetHeight,
    htmlTag: htmlTag.IMG,
    alignment: alignTypes.CENTER,
    pixelAspectRatio: (options == null ? void 0 : options.devicePixelRatio) ?? devicePixelRatio
  }, options);
  return getURL(data.uri, options);
}

;// ../../image-kit/dist/esm/sdk/index.js

populateGlobalFeatureSupport();

;// ../../image-kit/dist/esm/helpers/responsiveImageUtils.js

const responsiveImageUtils_alignTypes = {
  CENTER: 'center',
  TOP: 'top',
  TOP_LEFT: 'top_left',
  TOP_RIGHT: 'top_right',
  BOTTOM: 'bottom',
  BOTTOM_LEFT: 'bottom_left',
  BOTTOM_RIGHT: 'bottom_right',
  LEFT: 'left',
  RIGHT: 'right'
};
const getCropDataWithAlign = function (targetAspectRatio, originalAspectRatio, originalHeight, originalWidth, targetHeight, lowerWidth, bpWidth, alignType) {
  if (alignType === void 0) {
    alignType = responsiveImageUtils_alignTypes.CENTER;
  }
  if (targetAspectRatio > originalAspectRatio) {
    // Image needs vertical cropping
    const width = originalWidth;
    const height = Math.round(originalWidth / (lowerWidth / targetHeight));
    let y = Math.round(originalHeight / 2 - height / 2);
    const x = 0;
    if (alignType.includes('top')) {
      y = 0;
    } else if (alignType.includes('bottom')) {
      y = originalHeight - height;
    }
    return {
      width,
      height,
      x,
      y
    };
  } else {
    // Image needs horizontal cropping
    const width = Math.round(originalHeight / (targetHeight / bpWidth));
    const height = originalHeight;
    let x = Math.round(originalWidth / 2 - width / 2);
    const y = 0;
    if (alignType.includes('left')) {
      x = 0;
    } else if (alignType.includes('right')) {
      x = originalWidth - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
};
const WIDTHS = [1920, 1536, 1366, 1280, 980];
const getSources = (widthProportion, originalWidth, originalHeight, targetHeight, targetWidth, uri, quality, name, alignType, hasAnimation, upscaleMethod, focalPoint, crop, encoding, siteMargin, displayMode) => {
  const hasOriginalSizeDisplayMode = displayMode === 'original_size';
  const originalAspectRatio = originalWidth / originalHeight;
  return WIDTHS.map((width, index) => {
    const isLowestBreakpoint = width === 980;
    const getWidth = w => {
      if (isLowestBreakpoint) {
        return targetWidth;
      }
      return (w - 2 * (siteMargin || 0)) * (widthProportion / 100);
    };
    const lowerBpWidth = getWidth(WIDTHS[index + 1]);
    const currentBpWidth = getWidth(width);
    const targetAspectRatio = lowerBpWidth / targetHeight;
    const useManualCrop = !(hasOriginalSizeDisplayMode || isLowestBreakpoint);
    const manualCrop = useManualCrop && getCropDataWithAlign(targetAspectRatio, originalAspectRatio, originalHeight, originalWidth, targetHeight, lowerBpWidth, currentBpWidth, alignType);
    const {
      srcset,
      fallbackSrc,
      css
    } = getResponsiveImageProps({
      displayMode: hasOriginalSizeDisplayMode ? 'original_size' : isLowestBreakpoint ? 'fill' : 'fit',
      uri,
      width: originalWidth,
      height: originalHeight,
      crop: crop || manualCrop,
      name,
      focalPoint,
      alignType,
      quality,
      upscaleMethod,
      hasAnimation,
      encoding
    }, currentBpWidth, targetHeight);
    if (hasOriginalSizeDisplayMode && css) {
      css.img.objectFit = 'cover';
    }
    return {
      srcset: srcset || '',
      sizes: isLowestBreakpoint ? `${widthProportion}vw` : `${currentBpWidth}px`,
      media: `(max-width: ${width}px)`,
      fallbackSrc,
      imgStyle: css == null ? void 0 : css.img
    };
  });
};
const getResponsiveImageProps = (imageProps, targetWidth, targetHeight) => {
  const {
    displayMode,
    uri,
    width,
    height,
    name,
    crop,
    focalPoint,
    alignType,
    quality,
    upscaleMethod,
    hasAnimation,
    allowAnimatedTransform,
    encoding,
    siteMargin,
    widthProportion
  } = imageProps;
  if (!widthProportion) {
    var _srcset$dpr;
    const {
      srcset,
      css,
      uri: src
    } = getData(displayMode, {
      id: uri,
      width,
      height,
      name,
      crop,
      focalPoint
    }, {
      width: targetWidth,
      height: targetHeight,
      alignment: alignType
    }, {
      focalPoint,
      name,
      quality: quality == null ? void 0 : quality.quality,
      upscaleMethod,
      hasAnimation,
      allowAnimatedTransform,
      useSrcset: true,
      encoding
    });
    const srcsetWithPrefix = srcset == null || (_srcset$dpr = srcset.dpr) == null ? void 0 : _srcset$dpr.map(s => /^[a-z]+:/.test(s) ? s : `${STATIC_MEDIA_URL}${s}`);
    const fallbackSrc = `${STATIC_MEDIA_URL}${src}`;
    const srcsetString = (srcsetWithPrefix == null ? void 0 : srcsetWithPrefix.join(', ')) || '';
    return {
      fallbackSrc,
      srcset: srcsetString,
      css
    };
  } else {
    const sources = getSources(widthProportion, width, height, targetHeight, targetWidth, uri, quality, name, alignType, hasAnimation, upscaleMethod, focalPoint, crop, encoding, siteMargin, displayMode).filter(Boolean).reverse();
    return {
      fallbackSrc: sources[0].fallbackSrc,
      sources,
      css: sources[0].imgStyle
    };
  }
};
;// ../../image-kit/dist/esm/api/max/index.js






populateGlobalFeatureSupport();
const sdk = {
  getScaleToFitImageURL: getScaleToFitImageURL,
  getScaleToFillImageURL: getScaleToFillImageURL,
  getCropImageURL: getCropImageURL
};

const STATIC_MEDIA_URL = wixStaticWithMedia;

;// ./Image.tsx
const{STATIC_MEDIA_URL: Image_STATIC_MEDIA_URL}=max_namespaceObject;const fetchLQIP=_ref=>{let{fittingType,src,target,options}=_ref;const placeholder=getPlaceholder(fittingType,src,target,{...options,autoEncode:true});if(placeholder!=null&&placeholder.uri&&!/^[a-z]+:/.test(placeholder.uri)){placeholder.uri=`${Image_STATIC_MEDIA_URL}${placeholder.uri}`;}return placeholder;};const SCHEME_RE=/^[a-z]+:/;const Image=props=>{var _ssrResult$css,_srcset$dpr;const{id,containerId,uri,alt,name='',role,width,height,displayMode,devicePixelRatio,quality,alignType,bgEffectName='',focalPoint,upscaleMethod,className='',crop,imageStyles={},targetWidth,targetHeight,targetScale,onLoad=()=>{},onError=()=>{},shouldUseLQIP,containerWidth,containerHeight,getPlaceholder,isInFirstFold,placeholderTransition,socialAttrs,isSEOBot,skipMeasure,hasAnimation,encoding}=props;const imageRef=external_React_.useRef(null);// fix containerId and id to support hoverBox component
let hasSsrSrc='';const hasBlurTransition=placeholderTransition==='blur';const ssrImageData=external_React_.useRef(null);if(!ssrImageData.current){if(getPlaceholder||shouldUseLQIP||isInFirstFold||isSEOBot){const options={upscaleMethod,...(quality?quality:{}),shouldLoadHQImage:isInFirstFold,isSEOBot,hasAnimation,encoding};ssrImageData.current=(getPlaceholder||fetchLQIP)({fittingType:displayMode,src:{id:uri,width,height,crop,name,focalPoint},target:{width:containerWidth,height:containerHeight,alignment:alignType,htmlTag:'img'},options});hasSsrSrc=!ssrImageData.current.transformed||isInFirstFold||isSEOBot?'':'true';}else{// to keep an empty placeholder data
ssrImageData.current={uri:undefined,// to remove src attribute completely
css:{img:{}},attr:{img:{},container:{}},transformed:false};}}const isLQIP=!isSEOBot&&(getPlaceholder||shouldUseLQIP)&&!isInFirstFold&&ssrImageData.current.transformed;const imageInfo=external_React_.useMemo(()=>JSON.stringify({containerId,...(containerId&&{containerId}),...(alignType&&{alignType}),...(skipMeasure&&{skipMeasure:true}),displayMode,...(containerWidth&&{targetWidth:containerWidth}),...(containerHeight&&{targetHeight:containerHeight}),...(targetWidth&&{targetWidth}),...(targetHeight&&{targetHeight}),...(targetScale&&{targetScale}),isLQIP,isSEOBot,lqipTransition:placeholderTransition,encoding,imageData:{width,height,uri,name,displayMode,hasAnimation,...(quality&&{quality}),...(devicePixelRatio&&{devicePixelRatio}),...(focalPoint&&{focalPoint}),...(crop&&{crop}),...(upscaleMethod&&{upscaleMethod})}}),[containerId,alignType,skipMeasure,displayMode,containerWidth,containerHeight,targetWidth,targetHeight,targetScale,isLQIP,isSEOBot,placeholderTransition,encoding,width,height,uri,name,hasAnimation,quality,devicePixelRatio,focalPoint,crop,upscaleMethod]);const ssrResult=ssrImageData.current;const src=ssrResult==null?void 0:ssrResult.uri;const srcset=ssrResult==null?void 0:ssrResult.srcset;const placeholderStyle=(_ssrResult$css=ssrResult.css)==null?void 0:_ssrResult$css.img;const classNames=`${Image_module.image} ${className}`;external_React_.useEffect(()=>{// When image comes from cache onLoad not trigger on native HTML element
const imgElement=imageRef.current;if(onLoad&&imgElement!=null&&imgElement.currentSrc&&imgElement!=null&&imgElement.complete){onLoad({target:imgElement});}// eslint-disable-next-line react-hooks/exhaustive-deps
},[]);const maxWidth=ssrResult&&!(ssrResult!=null&&ssrResult.transformed)?`max(${width}px, 100%)`:targetWidth?`${targetWidth}px`:null;return/*#__PURE__*/external_React_.createElement("wow-image",{id:id,class:classNames,"data-image-info":imageInfo// TODO: get the correct id to place here
,"data-motion-part":`BG_IMG ${containerId}`,"data-bg-effect-name":bgEffectName,"data-has-ssr-src":hasSsrSrc,"data-animate-blur":!isSEOBot&&isLQIP&&hasBlurTransition?'':undefined,style:maxWidth?{'--wix-img-max-width':maxWidth}:{}},/*#__PURE__*/external_React_.createElement("img",extends_default()({src:src,ref:imageRef,alt:alt||'',role:role,style:{...placeholderStyle,...imageStyles},onLoad:onLoad,onError:onError,width:containerWidth?containerWidth:undefined,height:containerHeight?containerHeight:undefined},socialAttrs,{srcSet:isInFirstFold?srcset==null||(_srcset$dpr=srcset.dpr)==null?void 0:_srcset$dpr.map(s=>SCHEME_RE.test(s)?s:`${Image_STATIC_MEDIA_URL}${s}`).join(', '):undefined// @ts-expect-error fetchpriority type should work in react > 18.3 https://github.com/facebook/react/pull/25927
,fetchpriority:isInFirstFold?'high':undefined,loading:isInFirstFold===false?'lazy':undefined// The src attribute triggers a mismatch warning because wow-image updates its src outside of the React lifecycle. This causes React to retain the old value in the virtual DOM, which could potentially lead to a bug where the old value is re-rendered during updates. However, we’re confident that this issue is not reproducing in current (16-18) React versions
,suppressHydrationWarning:true})));};
;// ./utils.ts
const camelToKebab=str=>str.replace(/[A-Z]+(?![^A-Z])|[A-Z]/g,(a,b)=>(b?'-':'')+a.toLowerCase());
;// ./custom-element/utils.ts
const CSS_NUMERIC_VALUES={columnCount:1,columns:1,fontWeight:1,lineHeight:1,opacity:1,zIndex:1,zoom:1};const pick=(obj,props)=>{const propsArr=Array.isArray(props)?props:[props];return propsArr.reduce((subObj,prop)=>{const val=obj[prop];return val!==undefined?Object.assign(subObj,{[prop]:val}):subObj;},{});};const addDefaultUnitIfNeeded=(prop,value)=>typeof value==='number'&&!CSS_NUMERIC_VALUES[prop]?`${value}px`:value.toString();const setStyle=(node,styleProperties)=>node&&styleProperties&&Object.keys(styleProperties).forEach(prop=>{const styleProp=prop;const propValue=styleProperties[styleProp];if(propValue!==undefined){node.style[styleProp]=addDefaultUnitIfNeeded(styleProp,propValue);}else{node.style.removeProperty(styleProp);}});const getScreenHeight=heightOverride=>heightOverride||document.documentElement.clientHeight||window.innerHeight||0;const getImageComputedProperties=(extendedImageInfo,envConsts,htmlTag)=>{// todo: CLNT-5323 , wixapp sildergallery proxy is generating image data without uri
if(!extendedImageInfo.targetWidth||!extendedImageInfo.targetHeight||!extendedImageInfo.imageData.uri){return{uri:'',css:{},transformed:false};}const{imageData}=extendedImageInfo;const fittingType=extendedImageInfo.displayMode||fittingTypes.SCALE_TO_FILL;const imageOptions=Object.assign(pick(imageData,['upscaleMethod']),pick(extendedImageInfo,['filters','encoding']),extendedImageInfo.quality||imageData.quality,{hasAnimation:(extendedImageInfo==null?void 0:extendedImageInfo.hasAnimation)||(imageData==null?void 0:imageData.hasAnimation)});const devicePixelRatioFromData=extendedImageInfo.imageData.devicePixelRatio||envConsts.devicePixelRatio;const devicePixelRatio=utils_getDevicePixelRatio(devicePixelRatioFromData);const src=Object.assign(pick(imageData,['width','height','crop','name','focalPoint']),{id:imageData.uri});const target={width:extendedImageInfo.targetWidth,height:extendedImageInfo.targetHeight,htmlTag:htmlTag||'img',pixelAspectRatio:devicePixelRatio,alignment:extendedImageInfo.alignType||alignTypes.CENTER};const imageComputedProperties=getData(fittingType,src,target,imageOptions);imageComputedProperties.uri=getMediaUrlByContext(imageComputedProperties.uri,envConsts.staticMediaUrl,envConsts.mediaRootUrl);return imageComputedProperties;};const getMediaUrlByContext=(imageUri,staticMediaUrl,mediaRootUrl)=>{const isExternalUrl=/(^https?)|(^data)|(^blob)|(^\/\/)/.test(imageUri);if(isExternalUrl){return imageUri;}let path=`${staticMediaUrl}/`;if(imageUri){var _exec;if(/^micons\//.test(imageUri)){path=mediaRootUrl;}else if(((_exec=/[^.]+$/.exec(imageUri))==null?void 0:_exec[0])==='ico'){// if the image is an icon then it's taken from a slightly different place
path=path.replace('media','ficons');}}return path+imageUri;};const utils_getDevicePixelRatio=devicePixelRatio=>{// we should be able to force devicePixelRatio from url by using the query param -
const queryParams=window.location.search.split('&').map(query=>query.split('='));const devicePixelRatioQueryParam=queryParams.find(query=>{var _query$;return(_query$=query[0])==null?void 0:_query$.toLowerCase().includes('devicepixelratio');});const devicePixelRatioValueForceFromUrl=devicePixelRatioQueryParam!=null&&devicePixelRatioQueryParam[1]?Number(devicePixelRatioQueryParam[1]):null;return devicePixelRatioValueForceFromUrl||devicePixelRatio||1;};const getImageSrc=imageNode=>imageNode.getAttribute('src');const isTransformedWEBP=(imageNode,imageUri)=>{const src=getImageSrc(imageNode)||'';const isTransformed=!!src.match(/.webp\/v1\//);return isWEBP(imageUri)&&isTransformed;};const utils_imageIsAnimated=(uri,hasAnimation)=>getFileExtension(uri)===fileType.GIF||getFileExtension(uri)===fileType.WEBP&&hasAnimation;const getMediaSizeQueryString=media=>{return Object.entries(media).filter(_ref=>{let[_,value]=_ref;return value||value===0;}).map(_ref2=>{let[key,value]=_ref2;return`(${camelToKebab(key)}: ${value}px)`;}).join(' and ');};
;// ./imageNG.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const imageNG_module = ({"image":"gebRUR"});
;// ./ImageNG.tsx
// TODO(ameerabuf) - in original comp these prefixes could be overriden by EnvConsts
const ImageNG_STATIC_MEDIA_URL='https://static.wixstatic.com/media/';const MEDIA_ROOT_URL='https://static.wixstatic.com/';function ImageNG_getURL(image,targetSize){if(!image.height||!image.width){return'';}let inverseAspectRatio=image.height/image.width;// TODO(ameerabuf) - are those the same? seemed to be used as the same in other places..
const pixelAspectRatio=1;const devicePixelRatio=1;const src=Object.fromEntries(['width','height','name'].filter(key=>image[key]).map(key=>[key,image[key]]));if(image.crop){const cropX=image.crop.x||0;const cropY=image.crop.y||0;const cropW=Math.min(image.crop.width||image.width,image.width-cropX);const cropH=Math.min(image.crop.height||image.height,image.height-cropY);inverseAspectRatio=cropH/cropW;src.crop={x:cropX,y:cropY,width:cropW,height:cropH};}src.id=image.uri;const target={width:targetSize,height:targetSize*inverseAspectRatio,pixelAspectRatio,alignment:'center',htmlTag:'img'};const options={// TODO(ameerabuf) - implement filter and upscale?
// filters?: ImageTransformFiltersOption;
// upscaleMethod?: UpscaleMethod;
quality:image.quality,hasAnimation:!!image.animated,devicePixelRatio};const{uri}=getData('fill',src,target,options);return uri&&getMediaUrlByContext(uri,ImageNG_STATIC_MEDIA_URL,MEDIA_ROOT_URL);}const ImageNG=props=>{const{id,alt,sources,priority,decorative,role,dataset}=props;if(!sources.length){return null;}const sourcesAttributes=sources.map(_ref=>{var _image$crop,_image$crop2,_image$crop3,_image$crop4;let{image,media,sizes,targetSizes}=_ref;return{sizes:sizes.map(s=>`${s.media?getMediaSizeQueryString(s.media)+' ':''}${s.size.value}${s.size.type}`).join(', '),srcset:targetSizes.map(s=>`${ImageNG_getURL(image,s)} ${s}w`).join(', '),...(media&&{media:getMediaSizeQueryString(media)}),width:Math.min(((_image$crop=image.crop)==null?void 0:_image$crop.width)||image.width,image.width-(((_image$crop2=image.crop)==null?void 0:_image$crop2.x)||0)),height:Math.min(((_image$crop3=image.crop)==null?void 0:_image$crop3.height)||image.height,image.height-(((_image$crop4=image.crop)==null?void 0:_image$crop4.y)||0))};});const defaultSource=sources[sources.length-1];const{image}=defaultSource;const fullSizeSrc=ImageNG_getURL(image,image.width);const dataAttrs=dataset?Object.fromEntries(Object.entries(dataset).map(_ref2=>{let[key,val]=_ref2;return[`data-${camelToKebab(key)}`,val];})):{};return/*#__PURE__*/external_React_.createElement("picture",extends_default()({id:id,className:`${imageNG_module.image}`},dataAttrs),sourcesAttributes.map(_ref3=>{let{sizes,srcset,media,width,height}=_ref3;return/*#__PURE__*/external_React_.createElement("source",{key:`${id}-${media}`,sizes:sizes,srcSet:srcset,media:media,width:width,height:height});}),/*#__PURE__*/external_React_.createElement("style",null,[...sourcesAttributes].reverse().map(_ref4=>{let{media,width,height}=_ref4;return`${media?`@media ${media} {`:''}#${id}{--aspect-ratio: ${width/height};}${media?'}':''}`;}).join(' ')),/*#__PURE__*/external_React_.createElement("img",extends_default()({},priority==='high'?{fetchpriority:'high'}:{loading:'lazy'},decorative&&{'aria-hidden':true},{src:fullSizeSrc,alt:decorative?'':alt,role:role,width:image.width,height:image.height})));};
// EXTERNAL MODULE: ../../../node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(929);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
;// ./custom-element/imageLayout.ts
const MOBILE_SAFE_ADDRESSBAR_HEIGHT=80;function getHeightOverride(height,mediaHeightOverrideType){// on mobile, documentElement.clientHeight changes when scrolling, because of address bar collapsing.
// avoiding re-fetching image by returning the same height
return mediaHeightOverrideType==='fixed'||mediaHeightOverrideType==='viewport'?document.documentElement.clientHeight+MOBILE_SAFE_ADDRESSBAR_HEIGHT:height;}function computeScaleOverrides(imageStyle,targetScale){if(targetScale===void 0){targetScale=1;}return targetScale!==1?{...imageStyle,width:'100%',height:'100%'}:imageStyle;}/**
 * compute specific overrides
 */function computeStyleOverrides(mediaHeightOverrideType,imageStyle,displayMode,targetScale,isResponsive){// image scaling override
const styleWithScale=computeScaleOverrides(imageStyle,targetScale);if(isResponsive){delete styleWithScale.height;styleWithScale.width='100%';}if(!mediaHeightOverrideType){return styleWithScale;}// siteBackground on mobile
const style={...styleWithScale};if(displayMode==='fill'){style.position='absolute';style.top='0';}else if(displayMode==='fit'){style.height='100%';}if(mediaHeightOverrideType==='fixed'){// eliminates white gap when address bar is collapsing
style['will-change']='transform';}// force image alignment to include top
if(style.objectPosition){style.objectPosition=imageStyle.objectPosition.replace(/(center|bottom)$/,'top');}return style;}function getSourceSetsTargetHeightByEffect(sourceSets,offsetWidth,offsetHeight,screenHeight,services){const sourceSetsTargetHeights={};sourceSets.forEach(_ref=>{let{mediaQuery,scrollEffect}=_ref;sourceSetsTargetHeights[mediaQuery]=(services.getMediaDimensionsByEffect==null?void 0:services.getMediaDimensionsByEffect(scrollEffect,offsetWidth,offsetHeight,screenHeight).height)||offsetHeight;});return sourceSetsTargetHeights;}function computeSrcSets(measures,imageInfo,envConsts){const{sourceSets}=imageInfo;if(!sourceSets||!sourceSets.length){return;}const mediaToUri={};sourceSets.forEach(_ref2=>{let{mediaQuery,crop,focalPoint}=_ref2;const imageInfoClone={...imageInfo,targetHeight:(measures.sourceSetsTargetHeights||{})[mediaQuery]||0,imageData:{...imageInfo.imageData,crop,focalPoint}};const imageComputedProperties=getImageComputedProperties(imageInfoClone,envConsts,'img');mediaToUri[mediaQuery]=imageComputedProperties.uri||'';});return mediaToUri;}function measure(id,measures,domNodes,_ref3,services){let{containerElm,bgEffect='none',sourceSets}=_ref3;const innerImage=domNodes.image;const wixImage=domNodes[id];const screenHeight=getScreenHeight(services.getScreenHeightOverride==null?void 0:services.getScreenHeightOverride());// override positioning and scaling of image (SiteBackground mobile override behaviour)
const mediaHeightOverrideType=containerElm==null?void 0:containerElm.dataset.mediaHeightOverrideType;const hasBgEffect=bgEffect&&bgEffect!=='none'||sourceSets&&sourceSets.some(srcset=>srcset.scrollEffect);const sourceOfDimensions=containerElm&&hasBgEffect?containerElm:wixImage;// default to self
const cssBgEffect=window.getComputedStyle(wixImage).getPropertyValue('--bg-scrub-effect');const{width,height}=(services.getMediaDimensionsByEffect==null?void 0:services.getMediaDimensionsByEffect(cssBgEffect||bgEffect,sourceOfDimensions.offsetWidth,sourceOfDimensions.offsetHeight,screenHeight))||{width:wixImage.offsetWidth,height:wixImage.offsetHeight};if(sourceSets){measures.sourceSetsTargetHeights=getSourceSetsTargetHeightByEffect(sourceSets,sourceOfDimensions.offsetWidth,sourceOfDimensions.offsetHeight,screenHeight,services);}if(!innerImage){return;}const imgSrc=getImageSrc(innerImage);if(cssBgEffect){measures.top=0.5*(wixImage.offsetHeight-height);measures.left=0.5*(wixImage.offsetWidth-width);}measures.width=width;measures.height=getHeightOverride(height,mediaHeightOverrideType);measures.screenHeight=screenHeight;measures.imgSrc=imgSrc;measures.boundingRect=wixImage.getBoundingClientRect();measures.mediaHeightOverrideType=mediaHeightOverrideType;measures.srcset=innerImage.srcset;}function patch(id,measures,domNodes,imageInfo,envConsts,loadImage,isResponsive,bgEffect,loadImageImmediately){var _imageComputedPropert;if(!Object.keys(measures).length){return;}const{imageData}=imageInfo;const wixImageNode=domNodes[id];const image=domNodes.image;// no retina scaling for background scroll effects
if(bgEffect){imageData.devicePixelRatio=1;}const targetScale=imageInfo.targetScale||1;const extendedImageInfo={...imageInfo,...(!imageInfo.skipMeasure&&{targetWidth:(measures.width||0)*targetScale,targetHeight:(measures.height||0)*targetScale}),displayMode:imageData.displayMode};const imageComputedProperties=getImageComputedProperties(extendedImageInfo,envConsts,'img');const computedStyle=(imageComputedProperties==null||(_imageComputedPropert=imageComputedProperties.css)==null?void 0:_imageComputedPropert.img)||{};const imageStyle=computeStyleOverrides(measures.mediaHeightOverrideType,computedStyle,imageData.displayMode,targetScale,isResponsive);setStyle(image,imageStyle);if(measures.top||measures.left){setStyle(wixImageNode,{top:`${measures.top}px`,left:`${measures.left}px`});}const src=(imageComputedProperties==null?void 0:imageComputedProperties.uri)||'';const hasAnimation=(imageData==null?void 0:imageData.hasAnimation)||(imageInfo==null?void 0:imageInfo.hasAnimation);const mediaToUri=computeSrcSets(measures,extendedImageInfo,envConsts);if(loadImageImmediately){// flag that this image has been processed
image.dataset.ssrSrcDone='true';}if(imageInfo.isLQIP&&imageInfo.lqipTransition&&!('transitioned'in wixImageNode.dataset)){wixImageNode.dataset.transitioned='';if(image.complete){image.onload=function(){image.dataset.loadDone='';};}else{image.onload=function(){if(image.complete){image.dataset.loadDone='';}else{image.onload=function(){image.dataset.loadDone='';};}};}}if(loadImage){if(utils_imageIsAnimated(imageData.uri,hasAnimation)){image.setAttribute('fetchpriority','low');image.setAttribute('loading','lazy');image.setAttribute('decoding','async');}else{image.setAttribute('fetchpriority','high');}image.currentSrc!==src&&image.setAttribute('src',src);const srcIsMissingFromSrcset=measures.srcset&&!measures.srcset.split(', ').some(source=>source.split(' ')[0]===src);if(srcIsMissingFromSrcset){image.setAttribute('srcset',src);}if(domNodes.picture&&extendedImageInfo.sourceSets){Array.from(domNodes.picture.querySelectorAll('source')).forEach(sourceNode=>{const mediaQuery=sourceNode.media||'';const uri=mediaToUri==null?void 0:mediaToUri[mediaQuery];if(sourceNode.srcset!==uri){sourceNode.setAttribute('srcset',uri||'');}});}}}/* harmony default export */ const imageLayout = ({measure,patch});
;// ./custom-element/WowImage.ts
const TIMEOUT=250;const imageEffectMap={parallax:'ImageParallax',fixed:'ImageReveal'};function wowImageFactory(services,environmentConsts,contextWindow){return class WowImage extends contextWindow.HTMLElement{constructor(){// eslint-disable-line no-useless-constructor
super();defineProperty_default()(this,"childListObserver",void 0);defineProperty_default()(this,"timeoutId",void 0);this.childListObserver=null;this.timeoutId=null;}attributeChangedCallback(_,oldValue){if(oldValue){this.reLayout();}}connectedCallback(){if(environmentConsts.disableImagesLazyLoading){this.reLayout();}else{this.observeIntersect();}}disconnectedCallback(){this.unobserveResize();this.unobserveIntersect();this.unobserveChildren();}static get observedAttributes(){return['data-image-info'];}reLayout(){const domNodes={};const measures={};const imageId=this.getAttribute('id');const imageInfo=JSON.parse(this.dataset.imageInfo||'');const isResponsive=this.dataset.isResponsive==='true';const{bgEffectName}=this.dataset;const{scrollEffect}=imageInfo.imageData;const{sourceSets}=imageInfo;const bgEffect=bgEffectName||scrollEffect&&imageEffectMap[scrollEffect];if(sourceSets&&sourceSets.length){sourceSets.forEach(sourceSet=>{if(sourceSet.scrollEffect){sourceSet.scrollEffect=imageEffectMap[sourceSet.scrollEffect];}});}domNodes[imageId]=this;if(imageInfo.containerId){domNodes[imageInfo.containerId]=contextWindow.document.getElementById(`${imageInfo.containerId}`);}const containerElm=imageInfo.containerId?domNodes[imageInfo.containerId]:undefined;domNodes.image=this.querySelector('img');domNodes.picture=this.querySelector('picture');if(!domNodes.image){// missing children, can't layout, wait for children to be created first
const target=this;this.observeChildren(target);return;}// clean up
this.unobserveChildren();// from now on just observe changes to children of top level
this.observeChildren(this);services.mutationService.measure(()=>{imageLayout.measure(imageId,measures,domNodes,{containerElm,bgEffect,sourceSets},services);});const patchImage=(shouldLoadImage,loadImageImmediately)=>{services.mutationService.mutate(()=>{imageLayout.patch(imageId,measures,domNodes,imageInfo,environmentConsts,shouldLoadImage,isResponsive,bgEffect,loadImageImmediately);});};const imageElement=domNodes.image;const ssrSrcNeedProcessing=this.dataset.hasSsrSrc&&!imageElement.dataset.ssrSrcDone;// if image has no src or current src if from ssr render stage  -
// load the image immediately, otherwise - debounce the reload
const loadImageImmediately=!getImageSrc(imageElement)||ssrSrcNeedProcessing;if(loadImageImmediately){patchImage(true,true);}else{this.debounceImageLoad(patchImage);}}/**
     * Debounce consecutive image loads
     *
     * @param {function} patchImage closure for patching the image
     */debounceImageLoad(patchImage){clearTimeout(this.timeoutId);this.timeoutId=contextWindow.setTimeout(()=>{patchImage(true);},TIMEOUT);patchImage(false);}observeResize(){var _services$resizeServi;(_services$resizeServi=services.resizeService)==null||_services$resizeServi.observe(this);}unobserveResize(){var _services$resizeServi2;(_services$resizeServi2=services.resizeService)==null||_services$resizeServi2.unobserve(this);}observeIntersect(){var _services$intersectio;(_services$intersectio=services.intersectionService)==null||_services$intersectio.observe(this);}unobserveIntersect(){var _services$intersectio2;(_services$intersectio2=services.intersectionService)==null||_services$intersectio2.unobserve(this);}/**
     * Observe DOM mutations to wait for addition of missing children
     *
     * @param {HTMLElement} parent
     */observeChildren(parent){if(!this.childListObserver){this.childListObserver=new contextWindow.MutationObserver(()=>{this.reLayout();});}this.childListObserver.observe(parent,{childList:true});}/**
     * Remove DOM MutationObserver if one was created
     */unobserveChildren(){if(this.childListObserver){this.childListObserver.disconnect();this.childListObserver=null;}}};}/* harmony default export */ const custom_element_WowImage = (wowImageFactory);
// EXTERNAL MODULE: ../../../node_modules/fastdom/fastdom.js
var fastdom = __webpack_require__(709);
var fastdom_default = /*#__PURE__*/__webpack_require__.n(fastdom);
;// ./custom-element/registry.ts
function init(contextWindow,services){const elementName='wow-image';contextWindow=contextWindow||window;if(contextWindow.customElements.get(elementName)===undefined){let resizeObserver;if(contextWindow.ResizeObserver){resizeObserver=new contextWindow.ResizeObserver(entries=>entries.map(entry=>entry.target.reLayout()));}let intersectionObserver;if(contextWindow.IntersectionObserver){intersectionObserver=new IntersectionObserver(entries=>entries.map(entry=>{if(entry.isIntersecting){const wowImage=entry.target;wowImage.unobserveIntersect();// resize Observe will invoke relayout imidiatly.
// "Observation will fire when observation starts if Element is being rendered, and Element’s size is not 0,0,"
// https://drafts.csswg.org/resize-observer/#dom-resizeobserver-observe
wowImage.observeResize();}return entry;}),{/**
           * old: 50% from 1080 (desktop) is 540px, 800 (mobile) 400px
           * new: 150% from 1080 (desktop) is 1620, 800 (mobile) 1200
           * chrome [loading=lazy]: 4g - 1250px, lower then 3g - 2500px
           * @see https://web.dev/articles/browser-level-image-lazy-loading#improved-thresholds
           */rootMargin:'150% 100%'});}return function(env){const WowImage=custom_element_WowImage({resizeService:resizeObserver,intersectionService:intersectionObserver,mutationService:(fastdom_default()),...services},env,contextWindow);contextWindow.customElements.define(elementName,WowImage);};}return;}
;// ./customElementInit.ts
const customElementInit_getDevicePixelRatio=()=>{const isMSMobileDevice=/iemobile/i.test(navigator.userAgent);if(isMSMobileDevice){return Math.round(window.screen.availWidth/(window.screen.width||window.document.documentElement.clientWidth));}return window.devicePixelRatio;};const customElementInit_STATIC_MEDIA_URL='https://static.wixstatic.com/media';const customElementInit_MEDIA_ROOT_URL='https://static.wixstatic.com';function initCustomElement(services,contextWindow,envConsts){if(services===void 0){services={};}if(contextWindow===void 0){contextWindow=null;}if(envConsts===void 0){envConsts={};}if(typeof window==='undefined'){return;}const env={staticMediaUrl:customElementInit_STATIC_MEDIA_URL,mediaRootUrl:customElementInit_MEDIA_ROOT_URL,experiments:{},devicePixelRatio:customElementInit_getDevicePixelRatio(),...envConsts};const define=init(contextWindow,services);if(define){define(env);}}
;// ./index.ts

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=image.umd.js.map