import { defineService, implementService } from "@wix/services-definitions";
import { SignalsServiceDefinition, } from "@wix/services-definitions/core-services/signals";
import * as productsV3 from "@wix/auto_sdk_stores_products-v-3";
import * as customizationsV3 from "@wix/auto_sdk_stores_customizations-v-3";
const { SortDirection, SortType: SDKSortType } = productsV3;
// Helper functions
const extractAggregationValues = (aggregationResponse, name) => {
    const aggregation = aggregationResponse.aggregations?.[name] ||
        aggregationResponse.aggregationData?.results?.find((r) => r.name === name);
    return aggregation?.values?.results?.map((item) => item.value) || [];
};
const extractScalarAggregationValue = (aggregationResponse, name) => {
    const aggregation = aggregationResponse.aggregations?.[name] ||
        aggregationResponse.aggregationData?.results?.find((r) => r.name === name);
    const value = aggregation?.scalar?.value;
    return value !== undefined && value !== null ? parseFloat(value) : null;
};
const matchesAggregationName = (name, aggregationNames) => {
    return aggregationNames.some((aggName) => aggName.toLowerCase() === name.toLowerCase());
};
const sortChoicesIntelligently = (choices) => {
    return [...choices].sort((a, b) => {
        const aIsNumber = /^\d+$/.test(a.name);
        const bIsNumber = /^\d+$/.test(b.name);
        if (aIsNumber && bIsNumber) {
            return parseInt(b.name) - parseInt(a.name);
        }
        if (aIsNumber && !bIsNumber)
            return -1;
        if (!aIsNumber && bIsNumber)
            return 1;
        return a.name.localeCompare(b.name);
    });
};
const buildCategoryFilter = (categoryId) => {
    if (!categoryId) {
        return { visible: true };
    }
    return {
        visible: true,
        "allCategoriesInfo.categories": {
            $matchItems: [{ _id: { $in: [categoryId] } }],
        },
    };
};
export const CatalogServiceDefinition = defineService("catalog");
export const CatalogService = implementService.withConfig()(CatalogServiceDefinition, ({ getService }) => {
    const signalsService = getService(SignalsServiceDefinition);
    const catalogOptions = signalsService.signal(null);
    const catalogPriceRange = signalsService.signal(null);
    const isLoading = signalsService.signal(false);
    const error = signalsService.signal(null);
    const loadCatalogData = async (categoryId) => {
        isLoading.set(true);
        error.set(null);
        try {
            // Single aggregation request to get ALL catalog data at once
            const aggregationRequest = {
                aggregations: [
                    // Price range aggregations
                    {
                        name: "minPrice",
                        fieldPath: "actualPriceRange.minValue.amount",
                        type: "SCALAR",
                        scalar: { type: "MIN" },
                    },
                    {
                        name: "maxPrice",
                        fieldPath: "actualPriceRange.maxValue.amount",
                        type: "SCALAR",
                        scalar: { type: "MAX" },
                    },
                    // Options aggregations
                    {
                        name: "optionNames",
                        fieldPath: "options.name",
                        type: SDKSortType.VALUE,
                        value: {
                            limit: 20,
                            sortType: SDKSortType.VALUE,
                            sortDirection: SortDirection.ASC,
                        },
                    },
                    {
                        name: "choiceNames",
                        fieldPath: "options.choicesSettings.choices.name",
                        type: SDKSortType.VALUE,
                        value: {
                            limit: 50,
                            sortType: SDKSortType.VALUE,
                            sortDirection: SortDirection.ASC,
                        },
                    },
                    {
                        name: "inventoryStatus",
                        fieldPath: "inventory.availabilityStatus",
                        type: SDKSortType.VALUE,
                        value: {
                            limit: 10,
                            sortType: SDKSortType.VALUE,
                            sortDirection: SortDirection.ASC,
                        },
                    },
                ],
                filter: buildCategoryFilter(categoryId),
                includeProducts: false,
                cursorPaging: { limit: 0 },
            };
            // Make the single aggregation request
            const [aggregationResponse, customizationsResponse] = await Promise.all([
                productsV3.searchProducts(aggregationRequest),
                customizationsV3.queryCustomizations().find(),
            ]);
            // Process price range data
            const minPrice = extractScalarAggregationValue(aggregationResponse, "minPrice");
            const maxPrice = extractScalarAggregationValue(aggregationResponse, "maxPrice");
            if (minPrice !== null &&
                maxPrice !== null &&
                (minPrice > 0 || maxPrice > 0)) {
                catalogPriceRange.set({
                    minPrice,
                    maxPrice,
                });
            }
            else {
                catalogPriceRange.set(null);
            }
            // Process options data
            const optionNames = extractAggregationValues(aggregationResponse, "optionNames");
            const choiceNames = extractAggregationValues(aggregationResponse, "choiceNames");
            const inventoryStatuses = extractAggregationValues(aggregationResponse, "inventoryStatus");
            const customizations = customizationsResponse.items || [];
            // Build options by matching customizations with aggregation data
            const options = customizations
                .filter((customization) => customization.name &&
                customization._id &&
                customization.customizationType ===
                    customizationsV3.CustomizationType.PRODUCT_OPTION &&
                matchesAggregationName(customization.name, optionNames))
                .map((customization) => {
                const choices = (customization.choicesSettings?.choices || [])
                    .filter((choice) => choice._id &&
                    choice.name &&
                    matchesAggregationName(choice.name, choiceNames))
                    .map((choice) => ({
                    id: choice._id,
                    name: choice.name,
                    colorCode: choice.colorCode,
                }));
                return {
                    id: customization._id,
                    name: customization.name,
                    choices: sortChoicesIntelligently(choices),
                    optionRenderType: customization.customizationRenderType,
                };
            })
                .filter((option) => option.choices.length > 0);
            // Add inventory filter if there are multiple inventory statuses
            if (inventoryStatuses.length > 1) {
                const inventoryChoices = inventoryStatuses.map((status) => ({
                    id: status.toUpperCase(),
                    name: status.toUpperCase(),
                }));
                options.push({
                    id: "inventory-filter",
                    name: "Availability",
                    choices: inventoryChoices,
                    optionRenderType: productsV3.ModifierRenderType.TEXT_CHOICES,
                });
            }
            catalogOptions.set(options);
        }
        catch (err) {
            console.error("Failed to load catalog data:", err);
            error.set(err instanceof Error ? err.message : "Failed to load catalog data");
            catalogOptions.set([]);
            catalogPriceRange.set(null);
        }
        finally {
            isLoading.set(false);
        }
    };
    return {
        catalogOptions,
        catalogPriceRange,
        isLoading,
        error,
        loadCatalogData,
    };
});
export async function loadCatalogServiceConfig() {
    return {};
}
