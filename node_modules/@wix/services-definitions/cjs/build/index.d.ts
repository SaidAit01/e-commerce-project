export type ServiceDefinition<TAPI, TConfig> = string & {
    __api: TAPI;
    __config: TConfig;
    isServiceDefinition?: boolean;
};
export type ServiceConfig<T extends ServiceDefinition<any, any>> = T extends ServiceDefinition<any, infer TConfig> ? TConfig : never;
export type ServiceAPI<T extends ServiceDefinition<any, any>> = T extends ServiceDefinition<infer TAPI, any> ? TAPI : never;
export type GetService = <T extends ServiceDefinition<any, any>>(definition: T, getService?: GetService) => ServiceAPI<T>;
export type ServiceFactoryOpts<TConfig = {}> = {
    config: TConfig;
    getService: GetService;
};
export type ServiceFactory<T extends ServiceDefinition<any, any>, TConfig = {}> = (opts: ServiceFactoryOpts<TConfig>) => ServiceAPI<T>;
export type ServiceFactoryConfig<T extends ServiceFactory<any, any>> = T extends ServiceFactory<any, infer TConfig> ? TConfig : never;
export type ServiceBinding<T extends ServiceDefinition<any, any>, Impl extends ServiceFactory<T, any>> = {
    definition: T;
    impl: Impl;
    config: ServiceConfig<T> & ServiceFactoryConfig<Impl>;
};
export declare function defineService<TAPI, TConfig = {}>(id: string): ServiceDefinition<TAPI, TConfig> & TAPI;
export declare function implementService<T extends ServiceDefinition<any, any>, ImplConfig>(_: T, factory: ServiceFactory<T, ImplConfig>): ServiceFactory<T, ImplConfig>;
export declare namespace implementService {
    var withConfig: <TConfig>() => <T extends ServiceDefinition<any, any>>(_: T, factory: ServiceFactory<T, TConfig>) => ServiceFactory<T, TConfig>;
}
