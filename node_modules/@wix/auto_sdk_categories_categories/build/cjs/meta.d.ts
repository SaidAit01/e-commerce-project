import { cL as CreateCategoryRequest$1, cM as CreateCategoryResponse$1, cN as GetCategoryRequest$1, cO as GetCategoryResponse$1, cP as UpdateCategoryRequest$1, cQ as UpdateCategoryResponse$1, cR as DeleteCategoryRequest$1, cS as DeleteCategoryResponse$1, cT as QueryCategoriesRequest$1, cY as QueryCategoriesResponse$1, d2 as SearchCategoriesRequest$1, g as SearchCategoriesResponse$1, dK as CountCategoriesRequest$1, i as CountCategoriesResponse$1, dL as MoveCategoryRequest$1, j as MoveCategoryResponse$1, dM as BulkUpdateCategoriesRequest$1, m as BulkUpdateCategoriesResponse$1, dR as UpdateCategoryVisibilityRequest$1, p as UpdateCategoryVisibilityResponse$1, dS as BulkShowCategoriesRequest$1, s as BulkShowCategoriesResponse$1, dW as BulkAddItemsToCategoryRequest$1, u as BulkAddItemsToCategoryResponse$1, dZ as BulkAddItemToCategoriesRequest$1, x as BulkAddItemToCategoriesResponse$1, d$ as BulkRemoveItemsFromCategoryRequest$1, A as BulkRemoveItemsFromCategoryResponse$1, e0 as BulkRemoveItemFromCategoriesRequest$1, H as BulkRemoveItemFromCategoriesResponse$1, e1 as ListItemsInCategoryRequest$1, K as ListItemsInCategoryResponse$1, e4 as ListCategoriesForItemRequest$1, O as ListCategoriesForItemResponse$1, e5 as ListCategoriesForItemsRequest$1, R as ListCategoriesForItemsResponse$1, e7 as ListTreesRequest$1, V as ListTreesResponse$1, ea as SetArrangedItemsRequest$1, X as SetArrangedItemsResponse$1, eb as GetArrangedItemsRequest$1, Z as GetArrangedItemsResponse$1, ec as BulkSetItemCategoriesRequest$1, ed as BulkSetItemCategoriesResponse$1 } from './categories-v1-category-categories.universal-DWEZmpMq.js';
import '@wix/sdk-types';

interface Category {
    /**
     * Category ID.
     * @format GUID
     * @immutable
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the category is updated.
     * To prevent conflicting changes, the current revision must be passed when updating.
     *
     * Ignored when creating a category.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the category was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the category was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Category name.
     * @minLength 1
     * @maxLength 80
     */
    name?: string | null;
    /**
     * Category image.
     *
     * + Pass WixMedia image ID for media previously saved in the [Wix Media Manager](https://support.wix.com/en/article/wix-media-about-the-media-manager).
     * + Pass full image URL to upload to Wix Media Manager.
     */
    image?: Image;
    /**
     * Number of items in this category.
     * @readonly
     */
    itemCounter?: number;
    /**
     * Category description.
     * > **Note:** This field is returned only when you pass `fields: "DESCRIPTION"` in the request.
     * @minLength 1
     * @maxLength 600
     */
    description?: string | null;
    /**
     * Whether the category is visible to site visitors in dynamic pages.
     *
     * + If the parent category's visibility is set to `false`, all the children categories' visibility will also be set to `false`.
     * + Passing `true` will fail if the visibility of any parent categories is `false`.
     * + Default: `false`.
     * @immutable
     */
    visible?: boolean | null;
    /**
     * Category breadcrumbs.
     *
     * > **Note:** Returned only when you pass `"BREADCRUMBS_INFO"` to the `fields` array in Categories API requests.
     * @readonly
     */
    breadcrumbsInfo?: BreadcrumbsInfo;
    /**
     * Parent category reference data.
     * @immutable
     */
    parentCategory?: ParentCategory;
    /**
     * Category slug.
     *
     * If not provided, the slug is autogenerated based on the category name.
     * @format URL_SLUG
     */
    slug?: string | null;
    /** Custom SEO data for the category. */
    seoData?: SeoSchema;
    /**
     * Category description using rich content.
     * > **Note:** Returned only when you pass `"RICH_CONTENT_DESCRIPTION"` to the `fields` array in Categories API requests.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    richContentDescription?: RichContent;
    /**
     * ID of the app responsible for managing the items in this category.
     *
     * Pass your app ID to restrict updating and deleting items in this category to your app only.
     * @format GUID
     * @immutable
     */
    managingAppId?: string | null;
    /**
     * Custom extended fields for the category object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the [app dashboard](https://dev.wix.com/dc3/my-apps/) before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
interface Image {
    /**
     * WixMedia image ID.
     * @maxLength 400
     */
    id?: string;
    /**
     * Image URL.
     * @format WEB_URL
     */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /**
     * Image alt text.
     * @maxLength 200
     */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     * @maxLength 200
     */
    filename?: string | null;
}
interface BreadcrumbsInfo {
    /**
     * List of breadcrumb data. The current category isn't included in the list.
     * @readonly
     * @maxSize 5
     */
    breadcrumbs?: Breadcrumb[];
}
interface Breadcrumb {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId?: string;
    /**
     * Category name.
     * @minLength 1
     * @maxLength 80
     */
    categoryName?: string;
    /**
     * Category slug.
     * @minLength 1
     * @maxLength 100
     */
    categorySlug?: string;
}
interface ParentCategory {
    /**
     * Parent category ID.
     *
     * Default: root category ID
     * @format GUID
     */
    id?: string | null;
    /**
     * Index position of the category within the parent category.
     * @readonly
     */
    index?: number | null;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /**
     * The source that added the keyword terms to the SEO settings.
     * @maxLength 1000
     */
    origin?: string | null;
}
interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
     * For example: `{"name": "description", "content": "the description itself"}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag metadata. For example, `{"height": 300, "width": 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a [custom tag](https://support.wix.com/en/article/adding-additional-meta-tags-to-your-sites-pages). */
    custom?: boolean;
    /** Whether the tag is disabled. If the tag is disabled, people can't find your page when searching for this phrase in search engines. */
    disabled?: boolean;
}
interface Settings {
    /**
     * Whether the [automatical redirect visits](https://support.wix.com/en/article/customizing-your-pages-seo-settings-in-the-seo-panel) from the old URL to the new one is enabled.
     *
     *
     * Default: `false` (automatical redirect is enabled).
     */
    preventAutoRedirect?: boolean;
    /**
     * User-selected keyword terms for a specific page.
     * @maxSize 5
     */
    keywords?: Keyword[];
}
interface RichContent {
    /** Node objects representing a rich content document. */
    nodes?: Node[];
    /** Object metadata. */
    metadata?: Metadata;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle;
}
interface Node extends NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** @deprecated */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
    /** LayoutData layout_data = 31; // Data for a layout node. Reserved for future use. */
    layoutCellData?: LayoutCellData;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeTypeWithLiterals;
    /** Node ID. */
    id?: string;
    /** A list of child nodes. */
    nodes?: Node[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle;
}
/** @oneof */
interface NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** @deprecated */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
    /** LayoutData layout_data = 31; // Data for a layout node. Reserved for future use. */
    layoutCellData?: LayoutCellData;
}
declare enum NodeType {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    /** @deprecated */
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION",
    LAYOUT = "LAYOUT",
    LAYOUT_CELL = "LAYOUT_CELL"
}
/** @enumType */
type NodeTypeWithLiterals = NodeType | 'PARAGRAPH' | 'TEXT' | 'HEADING' | 'BULLETED_LIST' | 'ORDERED_LIST' | 'LIST_ITEM' | 'BLOCKQUOTE' | 'CODE_BLOCK' | 'VIDEO' | 'DIVIDER' | 'FILE' | 'GALLERY' | 'GIF' | 'HTML' | 'IMAGE' | 'LINK_PREVIEW' | 'MAP' | 'POLL' | 'APP_EMBED' | 'BUTTON' | 'COLLAPSIBLE_LIST' | 'TABLE' | 'EMBED' | 'COLLAPSIBLE_ITEM' | 'COLLAPSIBLE_ITEM_TITLE' | 'COLLAPSIBLE_ITEM_BODY' | 'TABLE_CELL' | 'TABLE_ROW' | 'EXTERNAL' | 'AUDIO' | 'CAPTION' | 'LAYOUT' | 'LAYOUT_CELL';
interface NodeStyle {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData {
    /** Styling for the button's container. */
    containerData?: PluginContainerData;
    /** The button type. */
    type?: ButtonDataTypeWithLiterals;
    /** Styling for the button. */
    styles?: Styles;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link;
}
interface Border {
    /**
     * Deprecated: Use `borderWidth` in `styles` instead.
     * @deprecated
     */
    width?: number | null;
    /**
     * Deprecated: Use `borderRadius` in `styles` instead.
     * @deprecated
     */
    radius?: number | null;
}
interface Colors {
    /**
     * Deprecated: Use `textColor` in `styles` instead.
     * @deprecated
     */
    text?: string | null;
    /**
     * Deprecated: Use `borderColor` in `styles` instead.
     * @deprecated
     */
    border?: string | null;
    /**
     * Deprecated: Use `backgroundColor` in `styles` instead.
     * @deprecated
     */
    background?: string | null;
}
interface PluginContainerData {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignmentWithLiterals;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler;
    /** The height of the node when it's displayed. */
    height?: Height;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
/** @enumType */
type WidthTypeWithLiterals = WidthType | 'CONTENT' | 'SMALL' | 'ORIGINAL' | 'FULL_WIDTH';
interface PluginContainerDataWidth extends PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthTypeWithLiterals;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthTypeWithLiterals;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
/** @enumType */
type PluginContainerDataAlignmentWithLiterals = PluginContainerDataAlignment | 'CENTER' | 'LEFT' | 'RIGHT';
interface Spoiler {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum ButtonDataType {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
/** @enumType */
type ButtonDataTypeWithLiterals = ButtonDataType | 'LINK' | 'ACTION';
interface Styles {
    /**
     * Deprecated: Use `borderWidth` and `borderRadius` instead.
     * @deprecated
     */
    border?: Border;
    /**
     * Deprecated: Use `textColor`, `borderColor` and `backgroundColor` instead.
     * @deprecated
     */
    colors?: Colors;
    /** Border width in pixels. */
    borderWidth?: number | null;
    /**
     * Deprecated: Use `borderWidth` for normal/hover states instead.
     * @deprecated
     */
    borderWidthHover?: number | null;
    /** Border radius in pixels. */
    borderRadius?: number | null;
    /**
     * Border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    borderColor?: string | null;
    /**
     * Border color as a hexadecimal value (hover state).
     * @format COLOR_HEX
     */
    borderColorHover?: string | null;
    /**
     * Text color as a hexadecimal value.
     * @format COLOR_HEX
     */
    textColor?: string | null;
    /**
     * Text color as a hexadecimal value (hover state).
     * @format COLOR_HEX
     */
    textColorHover?: string | null;
    /**
     * Background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
    /**
     * Background color as a hexadecimal value (hover state).
     * @format COLOR_HEX
     */
    backgroundColorHover?: string | null;
    /** Button size option, one of `SMALL`, `MEDIUM` or `LARGE`. Defaults to `MEDIUM`. */
    buttonSize?: string | null;
}
interface Link extends LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: TargetWithLiterals;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
/** @enumType */
type TargetWithLiterals = Target | 'SELF' | 'BLANK' | 'PARENT' | 'TOP';
interface Rel {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData {
    /** Styling for the code block's text. */
    textStyle?: TextStyle;
}
interface TextStyle {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignmentWithLiterals;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
/** @enumType */
type TextAlignmentWithLiterals = TextAlignment | 'AUTO' | 'LEFT' | 'RIGHT' | 'CENTER' | 'JUSTIFY';
interface DividerData {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData;
    /** Divider line style. */
    lineStyle?: LineStyleWithLiterals;
    /** Divider width. */
    width?: WidthWithLiterals;
    /** Divider alignment. */
    alignment?: DividerDataAlignmentWithLiterals;
}
declare enum LineStyle {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
/** @enumType */
type LineStyleWithLiterals = LineStyle | 'SINGLE' | 'DOUBLE' | 'DASHED' | 'DOTTED';
declare enum Width {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
/** @enumType */
type WidthWithLiterals = Width | 'LARGE' | 'MEDIUM' | 'SMALL';
declare enum DividerDataAlignment {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
/** @enumType */
type DividerDataAlignmentWithLiterals = DividerDataAlignment | 'CENTER' | 'LEFT' | 'RIGHT';
interface FileData {
    /** Styling for the file's container. */
    containerData?: PluginContainerData;
    /** The source for the file's data. */
    src?: FileSource;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
/** @enumType */
type ViewModeWithLiterals = ViewMode | 'NONE' | 'FULL' | 'MINI';
interface FileSource extends FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
}
interface PDFSettings {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewModeWithLiterals;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData;
    /** The items in the gallery. */
    items?: Item[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface Media {
    /** The source for the media's data. */
    src?: FileSource;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface ItemImage {
    /** Image file details. */
    media?: Media;
    /** Link details for images that are links. */
    link?: Link;
}
interface Video {
    /** Video file details. */
    media?: Media;
    /** Video thumbnail file details. */
    thumbnail?: Media;
}
interface Item extends ItemDataOneOf {
    /** An image item. */
    image?: ItemImage;
    /** A video item. */
    video?: Video;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf {
    /** An image item. */
    image?: ItemImage;
    /** A video item. */
    video?: Video;
}
interface GalleryOptions {
    /** Gallery layout. */
    layout?: GalleryOptionsLayout;
    /** Styling for gallery items. */
    item?: ItemStyle;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails;
}
declare enum LayoutType {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
/** @enumType */
type LayoutTypeWithLiterals = LayoutType | 'COLLAGE' | 'MASONRY' | 'GRID' | 'THUMBNAIL' | 'SLIDER' | 'SLIDESHOW' | 'PANORAMA' | 'COLUMN' | 'MAGIC' | 'FULLSIZE';
declare enum Orientation {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
/** @enumType */
type OrientationWithLiterals = Orientation | 'ROWS' | 'COLUMNS';
declare enum Crop {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
/** @enumType */
type CropWithLiterals = Crop | 'FILL' | 'FIT';
declare enum ThumbnailsAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
/** @enumType */
type ThumbnailsAlignmentWithLiterals = ThumbnailsAlignment | 'TOP' | 'RIGHT' | 'BOTTOM' | 'LEFT' | 'NONE';
interface GalleryOptionsLayout {
    /** Gallery layout type. */
    type?: LayoutTypeWithLiterals;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: OrientationWithLiterals;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: CropWithLiterals;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignmentWithLiterals;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData;
    /** The source of the full size GIF. */
    original?: GIF;
    /** The source of the downsized GIF. */
    downsized?: GIF;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
    /** Type of GIF (Sticker or NORMAL). Defaults to `NORMAL`. */
    gifType?: GIFTypeWithLiterals;
}
interface GIF {
    /**
     * GIF format URL.
     * @format WEB_URL
     */
    gif?: string | null;
    /**
     * MP4 format URL.
     * @format WEB_URL
     */
    mp4?: string | null;
    /**
     * Thumbnail URL.
     * @format WEB_URL
     */
    still?: string | null;
}
declare enum GIFType {
    NORMAL = "NORMAL",
    STICKER = "STICKER"
}
/** @enumType */
type GIFTypeWithLiterals = GIFType | 'NORMAL' | 'STICKER';
interface HeadingData {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData extends HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. Height property is irrelevant for HTML embeds when autoHeight is set to `true`. */
    containerData?: PluginContainerData;
    /** The type of HTML code. */
    source?: SourceWithLiterals;
    /** If container height is aligned with its content height. Defaults to `true`. */
    autoHeight?: boolean | null;
}
/** @oneof */
interface HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
/** @enumType */
type SourceWithLiterals = Source | 'HTML' | 'ADSENSE';
interface ImageData {
    /** Styling for the image's container. */
    containerData?: PluginContainerData;
    /** Image file details. */
    image?: Media;
    /** Link details for images that are links. */
    link?: Link;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the image is decorative and does not need an explanation. Defaults to `false`. */
    decorative?: boolean | null;
    /** Styling for the image. */
    styles?: ImageDataStyles;
}
interface StylesBorder {
    /** Border width in pixels. */
    width?: number | null;
    /**
     * Border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    color?: string | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface ImageDataStyles {
    /** Border attributes. */
    border?: StylesBorder;
}
interface LinkPreviewData {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData;
    /** Link details. */
    link?: Link;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
    /** Styling for the link preview. */
    styles?: LinkPreviewDataStyles;
}
declare enum StylesPosition {
    /** Thumbnail positioned at the start (left in LTR layouts, right in RTL layouts) */
    START = "START",
    /** Thumbnail positioned at the end (right in LTR layouts, left in RTL layouts) */
    END = "END",
    /** Thumbnail positioned at the top */
    TOP = "TOP",
    /** Thumbnail hidden and not displayed */
    HIDDEN = "HIDDEN"
}
/** @enumType */
type StylesPositionWithLiterals = StylesPosition | 'START' | 'END' | 'TOP' | 'HIDDEN';
interface LinkPreviewDataStyles {
    /**
     * Background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
    /**
     * Title color as a hexadecimal value.
     * @format COLOR_HEX
     */
    titleColor?: string | null;
    /**
     * Subtitle color as a hexadecimal value.
     * @format COLOR_HEX
     */
    subtitleColor?: string | null;
    /**
     * Link color as a hexadecimal value.
     * @format COLOR_HEX
     */
    linkColor?: string | null;
    /** Border width in pixels. */
    borderWidth?: number | null;
    /** Border radius in pixels. */
    borderRadius?: number | null;
    /**
     * Border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    borderColor?: string | null;
    /** Position of thumbnail. Defaults to `START`. */
    thumbnailPosition?: StylesPositionWithLiterals;
}
interface MapData {
    /** Styling for the map's container. */
    containerData?: PluginContainerData;
    /** Map settings. */
    mapSettings?: MapSettings;
}
interface MapSettings {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapTypeWithLiterals;
}
declare enum MapType {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
/** @enumType */
type MapTypeWithLiterals = MapType | 'ROADMAP' | 'SATELITE' | 'HYBRID' | 'TERRAIN';
interface ParagraphData {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData;
    /** Poll data. */
    poll?: Poll;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout;
    /** Styling for the poll and voting options. */
    design?: Design;
}
declare enum ViewRole {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
/** @enumType */
type ViewRoleWithLiterals = ViewRole | 'CREATOR' | 'VOTERS' | 'EVERYONE';
declare enum VoteRole {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
/** @enumType */
type VoteRoleWithLiterals = VoteRole | 'SITE_MEMBERS' | 'ALL';
interface Permissions {
    /** Sets who can view the poll results. */
    view?: ViewRoleWithLiterals;
    /** Sets who can vote. */
    vote?: VoteRoleWithLiterals;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option {
    /** Option ID. */
    id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: Media;
}
interface PollSettings {
    /** Permissions settings for voting. */
    permissions?: Permissions;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
/** @enumType */
type PollLayoutTypeWithLiterals = PollLayoutType | 'LIST' | 'GRID';
declare enum PollLayoutDirection {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
/** @enumType */
type PollLayoutDirectionWithLiterals = PollLayoutDirection | 'LTR' | 'RTL';
interface PollLayout {
    /** The layout for displaying the voting options. */
    type?: PollLayoutTypeWithLiterals;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirectionWithLiterals;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
/** @enumType */
type BackgroundTypeWithLiterals = BackgroundType | 'COLOR' | 'IMAGE' | 'GRADIENT';
interface Gradient {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /**
     * The start color as a hexademical value.
     * @format COLOR_HEX
     */
    startColor?: string | null;
    /**
     * The end color as a hexademical value.
     * @format COLOR_HEX
     */
    lastColor?: string | null;
}
interface Background extends BackgroundBackgroundOneOf {
    /**
     * The background color as a hexademical value.
     * @format COLOR_HEX
     */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundTypeWithLiterals;
}
/** @oneof */
interface BackgroundBackgroundOneOf {
    /**
     * The background color as a hexademical value.
     * @format COLOR_HEX
     */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
}
interface PollDesign {
    /** Background styling. */
    background?: Background;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll {
    /** Poll ID. */
    id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: Media;
    /** Voting options. */
    options?: Option[];
    /** The poll's permissions and display settings. */
    settings?: PollSettings;
}
interface PollDataLayout {
    /** Poll layout settings. */
    poll?: PollLayout;
    /** Voting otpions layout settings. */
    options?: OptionLayout;
}
interface Design {
    /** Styling for the poll. */
    poll?: PollDesign;
    /** Styling for voting options. */
    options?: OptionDesign;
}
interface TextData {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration[];
}
/** Adds appearence changes to text */
interface Decoration extends DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
    /** Data for a strikethrough decoration. Defaults to `true`. */
    strikethroughData?: boolean | null;
    /** Data for a superscript decoration. Defaults to `true`. */
    superscriptData?: boolean | null;
    /** Data for a subscript decoration. Defaults to `true`. */
    subscriptData?: boolean | null;
    /** The type of decoration to apply. */
    type?: DecorationTypeWithLiterals;
}
/** @oneof */
interface DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
    /** Data for a strikethrough decoration. Defaults to `true`. */
    strikethroughData?: boolean | null;
    /** Data for a superscript decoration. Defaults to `true`. */
    superscriptData?: boolean | null;
    /** Data for a subscript decoration. Defaults to `true`. */
    subscriptData?: boolean | null;
}
declare enum DecorationType {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL",
    STRIKETHROUGH = "STRIKETHROUGH",
    SUPERSCRIPT = "SUPERSCRIPT",
    SUBSCRIPT = "SUBSCRIPT"
}
/** @enumType */
type DecorationTypeWithLiterals = DecorationType | 'BOLD' | 'ITALIC' | 'UNDERLINE' | 'SPOILER' | 'ANCHOR' | 'MENTION' | 'LINK' | 'COLOR' | 'FONT_SIZE' | 'EXTERNAL' | 'STRIKETHROUGH' | 'SUPERSCRIPT' | 'SUBSCRIPT';
interface AnchorData {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData {
    /** Link details. */
    link?: Link;
}
interface MentionData {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    id?: string | null;
}
interface FontSizeData {
    /** The units used for the font size. */
    unit?: FontTypeWithLiterals;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType {
    PX = "PX",
    EM = "EM"
}
/** @enumType */
type FontTypeWithLiterals = FontType | 'PX' | 'EM';
interface SpoilerData {
    /** Spoiler ID. */
    id?: string | null;
}
interface AppEmbedData extends AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
    /** The type of Wix App content being embedded. */
    type?: AppTypeWithLiterals;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: Media;
    /** Whether to hide the image. */
    hideImage?: boolean | null;
    /** Whether to hide the title. */
    hideTitle?: boolean | null;
    /** Whether to hide the price. */
    hidePrice?: boolean | null;
    /** Whether to hide the description (Event and Booking). */
    hideDescription?: boolean | null;
    /** Whether to hide the date and time (Event). */
    hideDateTime?: boolean | null;
    /** Whether to hide the location (Event). */
    hideLocation?: boolean | null;
    /** Whether to hide the duration (Booking). */
    hideDuration?: boolean | null;
    /** Whether to hide the button. */
    hideButton?: boolean | null;
    /** Whether to hide the ribbon. */
    hideRibbon?: boolean | null;
    /** Button styling options. */
    buttonStyles?: ButtonStyles;
    /** Image styling options. */
    imageStyles?: ImageStyles;
    /** Ribbon styling options. */
    ribbonStyles?: RibbonStyles;
    /** Card styling options. */
    cardStyles?: CardStyles;
    /** Styling for the app embed's container. */
    containerData?: PluginContainerData;
    /** Pricing data for embedded Wix App content. */
    pricingData?: PricingData;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
}
declare enum ImageStylesPosition {
    /** Image positioned at the start (left in LTR layouts, right in RTL layouts) */
    START = "START",
    /** Image positioned at the end (right in LTR layouts, left in RTL layouts) */
    END = "END",
    /** Image positioned at the top */
    TOP = "TOP"
}
/** @enumType */
type ImageStylesPositionWithLiterals = ImageStylesPosition | 'START' | 'END' | 'TOP';
declare enum AspectRatio {
    /** 1:1 aspect ratio */
    SQUARE = "SQUARE",
    /** 16:9 aspect ratio */
    RECTANGLE = "RECTANGLE"
}
/** @enumType */
type AspectRatioWithLiterals = AspectRatio | 'SQUARE' | 'RECTANGLE';
declare enum Resizing {
    /** Fill the container, may crop the image */
    FILL = "FILL",
    /** Fit the image within the container */
    FIT = "FIT"
}
/** @enumType */
type ResizingWithLiterals = Resizing | 'FILL' | 'FIT';
declare enum Placement {
    /** Ribbon placed on the image */
    IMAGE = "IMAGE",
    /** Ribbon placed on the product information */
    PRODUCT_INFO = "PRODUCT_INFO"
}
/** @enumType */
type PlacementWithLiterals = Placement | 'IMAGE' | 'PRODUCT_INFO';
declare enum Type {
    /** Card with visible border and background */
    CONTAINED = "CONTAINED",
    /** Card without visible border */
    FRAMELESS = "FRAMELESS"
}
/** @enumType */
type TypeWithLiterals = Type | 'CONTAINED' | 'FRAMELESS';
declare enum Alignment {
    /** Content aligned to start (left in LTR layouts, right in RTL layouts) */
    START = "START",
    /** Content centered */
    CENTER = "CENTER",
    /** Content aligned to end (right in LTR layouts, left in RTL layouts) */
    END = "END"
}
/** @enumType */
type AlignmentWithLiterals = Alignment | 'START' | 'CENTER' | 'END';
declare enum Layout {
    /** Elements stacked vertically */
    STACKED = "STACKED",
    /** Elements arranged horizontally */
    SIDE_BY_SIDE = "SIDE_BY_SIDE"
}
/** @enumType */
type LayoutWithLiterals = Layout | 'STACKED' | 'SIDE_BY_SIDE';
declare enum AppType {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
/** @enumType */
type AppTypeWithLiterals = AppType | 'PRODUCT' | 'EVENT' | 'BOOKING';
interface BookingData {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface ButtonStyles {
    /** Text to display on the button. */
    buttonText?: string | null;
    /** Border width in pixels. */
    borderWidth?: number | null;
    /** Border radius in pixels. */
    borderRadius?: number | null;
    /**
     * Border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    borderColor?: string | null;
    /**
     * Text color as a hexadecimal value.
     * @format COLOR_HEX
     */
    textColor?: string | null;
    /**
     * Background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
    /**
     * Border color as a hexadecimal value (hover state).
     * @format COLOR_HEX
     */
    borderColorHover?: string | null;
    /**
     * Text color as a hexadecimal value (hover state).
     * @format COLOR_HEX
     */
    textColorHover?: string | null;
    /**
     * Background color as a hexadecimal value (hover state).
     * @format COLOR_HEX
     */
    backgroundColorHover?: string | null;
    /** Button size option, one of `SMALL`, `MEDIUM` or `LARGE`. Defaults to `MEDIUM`. */
    buttonSize?: string | null;
}
interface ImageStyles {
    /** Whether to hide the image. */
    hideImage?: boolean | null;
    /** Position of image. Defaults to `START`. */
    imagePosition?: ImageStylesPositionWithLiterals;
    /** Aspect ratio for the image. Defaults to `SQUARE`. */
    aspectRatio?: AspectRatioWithLiterals;
    /** How the image should be resized. Defaults to `FILL`. */
    resizing?: ResizingWithLiterals;
    /**
     * Image border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    borderColor?: string | null;
    /** Image border width in pixels. */
    borderWidth?: number | null;
    /** Image border radius in pixels. */
    borderRadius?: number | null;
}
interface RibbonStyles {
    /** Text to display on the ribbon. */
    ribbonText?: string | null;
    /**
     * Ribbon background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
    /**
     * Ribbon text color as a hexadecimal value.
     * @format COLOR_HEX
     */
    textColor?: string | null;
    /**
     * Ribbon border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    borderColor?: string | null;
    /** Ribbon border width in pixels. */
    borderWidth?: number | null;
    /** Ribbon border radius in pixels. */
    borderRadius?: number | null;
    /** Placement of the ribbon. Defaults to `IMAGE`. */
    ribbonPlacement?: PlacementWithLiterals;
}
interface CardStyles {
    /**
     * Card background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
    /**
     * Card border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    borderColor?: string | null;
    /** Card border width in pixels. */
    borderWidth?: number | null;
    /** Card border radius in pixels. */
    borderRadius?: number | null;
    /** Card type. Defaults to `CONTAINED`. */
    type?: TypeWithLiterals;
    /** Content alignment. Defaults to `START`. */
    alignment?: AlignmentWithLiterals;
    /** Layout for title and price. Defaults to `STACKED`. */
    titlePriceLayout?: LayoutWithLiterals;
    /**
     * Title text color as a hexadecimal value.
     * @format COLOR_HEX
     */
    titleColor?: string | null;
    /**
     * Text color as a hexadecimal value.
     * @format COLOR_HEX
     */
    textColor?: string | null;
}
interface PricingData {
    /**
     * Minimum numeric price value as string (e.g., "10.99").
     * @decimalValue options { maxScale:2 }
     */
    valueFrom?: string | null;
    /**
     * Maximum numeric price value as string (e.g., "19.99").
     * @decimalValue options { maxScale:2 }
     */
    valueTo?: string | null;
    /**
     * Numeric price value as string after discount application (e.g., "15.99").
     * @decimalValue options { maxScale:2 }
     */
    discountedValue?: string | null;
    /**
     * Currency of the value in ISO 4217 format (e.g., "USD", "EUR").
     * @format CURRENCY
     */
    currency?: string | null;
    /**
     * Pricing plan ID.
     * @format GUID
     */
    pricingPlanId?: string | null;
}
interface VideoData {
    /** Styling for the video's container. */
    containerData?: PluginContainerData;
    /** Video details. */
    video?: Media;
    /** Video thumbnail details. */
    thumbnail?: Media;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions;
}
interface PlaybackOptions {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItemsWithLiterals;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: DirectionWithLiterals;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
/** @enumType */
type InitialExpandedItemsWithLiterals = InitialExpandedItems | 'FIRST' | 'ALL' | 'NONE';
declare enum Direction {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
/** @enumType */
type DirectionWithLiterals = Direction | 'LTR' | 'RTL';
interface TableData {
    /** Styling for the table's container. */
    containerData?: PluginContainerData;
    /** The table's dimensions. */
    dimensions?: Dimensions;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle;
    /** The cell's border colors. */
    borderColors?: BorderColors;
}
declare enum VerticalAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
/** @enumType */
type VerticalAlignmentWithLiterals = VerticalAlignment | 'TOP' | 'MIDDLE' | 'BOTTOM';
interface CellStyle {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignmentWithLiterals;
    /**
     * Cell background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
}
interface BorderColors {
    /**
     * Left border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    left?: string | null;
    /**
     * Right border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    right?: string | null;
    /**
     * Top border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    top?: string | null;
    /**
     * Bottom border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    bottom?: string | null;
}
interface AudioData {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData;
    /** Audio file details. */
    audio?: Media;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: Media;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData {
    textStyle?: TextStyle;
}
interface LayoutCellData {
    /** Size of the cell in 12 columns grid. */
    colSpan?: number | null;
}
interface Metadata {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    id?: string | null;
}
interface DocumentStyle {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle;
}
interface TextNodeStyle {
    /** The decorations to apply to the node. */
    decorations?: Decoration[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface TreeReference {
    /**
     * Namespace of the app that manages the tree.
     *
     * For example, `"@wix/stores"`, `"@bookings/bookingslist"`, `"@achievements/quizzes"`.
     * @minLength 4
     * @maxLength 150
     */
    appNamespace?: string;
    /**
     * Tree key. You must pass this when a single app manages more than one tree.
     * @minLength 1
     * @maxLength 44
     */
    treeKey?: string | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface ItemReference {
    /**
     * ID of the item within the catalog it belongs to.
     *
     * For example, `product.id` for Wix Stores or `event.id` for Wix Events.
     * @minLength 1
     * @maxLength 36
     */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     * @minLength 1
     * @maxLength 36
     */
    appId?: string;
}
interface CreateCategoryRequest {
    /** Category to create. */
    category: Category;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: SingleEntityOpsRequestedFieldsWithLiterals[];
}
declare enum SingleEntityOpsRequestedFields {
    /** Not implemented. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    BREADCRUMBS_INFO = "BREADCRUMBS_INFO",
    DESCRIPTION = "DESCRIPTION",
    RICH_CONTENT_DESCRIPTION = "RICH_CONTENT_DESCRIPTION"
}
/** @enumType */
type SingleEntityOpsRequestedFieldsWithLiterals = SingleEntityOpsRequestedFields | 'UNKNOWN_REQUESTED_FIELD' | 'BREADCRUMBS_INFO' | 'DESCRIPTION' | 'RICH_CONTENT_DESCRIPTION';
interface CreateCategoryResponse {
    /** Created category. */
    category?: Category;
}
interface GetCategoryRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: SingleEntityOpsRequestedFieldsWithLiterals[];
}
interface GetCategoryResponse {
    /** Category. */
    category?: Category;
}
interface UpdateCategoryRequest {
    /** Category to update. */
    category: Category;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: SingleEntityOpsRequestedFieldsWithLiterals[];
}
interface UpdateCategoryResponse {
    /** Updated category. */
    category?: Category;
}
interface DeleteCategoryRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface DeleteCategoryResponse {
}
interface QueryCategoriesRequest {
    /** Query options. */
    query?: CursorQuery;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Whether to return non-visible categories.
     *
     * Default: `false` (only visible categories are returned)
     */
    returnNonVisibleCategories?: boolean;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: RequestedFieldsWithLiterals[];
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 5
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    /** Ascending order. */
    ASC = "ASC",
    /** Descending order. */
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 1000
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
declare enum RequestedFields {
    /** Not implemented. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    BREADCRUMBS_INFO = "BREADCRUMBS_INFO"
}
/** @enumType */
type RequestedFieldsWithLiterals = RequestedFields | 'UNKNOWN_REQUESTED_FIELD' | 'BREADCRUMBS_INFO';
interface QueryCategoriesResponse {
    /**
     * List of categories.
     * @maxSize 1000
     */
    categories?: Category[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface SearchCategoriesRequest {
    /**
     * Search criteria including filter, sort, aggregations, and paging options.
     *
     * Refer to the [supported filters & sorting table](https://dev.wix.com/docs/sdk/backend-modules/categories/categories/search-categories) (SDK)
     * or the [supported filters article](https://dev.wix.com/docs/rest/business-management/categories/supported-filters-and-sorting) (REST)
     * for a complete list of supported filters and sorting options.
     */
    search?: CursorSearch;
    /**
     * Category tree reference details.
     * > **Note:** Pass `treeReference` only in the first request. Pass the cursor token in subsequent requests.
     */
    treeReference: TreeReference;
    /**
     * Whether to return the categories with `visible` set to `false`.
     *
     * Default: `false`. Only visible categories are returned in the response
     */
    returnNonVisibleCategories?: boolean;
    /**
     * Array of projected fields. A list of specific field names to return.
     * @maxSize 100
     */
    fields?: RequestedFieldsWithLiterals[];
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor-based paging for result navigation. When requesting `cursor_paging.cursor`,
     * `filter`, `sort`, or `search` can't be specified.
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object for narrowing search results. For example, to return only categories from the Stores app: `"filter": {"appNamespace": "@wix/stores"}`.
     *
     * Learn more about the filter format in the [supported filters & sorting table](https://dev.wix.com/docs/sdk/backend-modules/categories/categories/search-categories) (SDK)
     * or the [supported filters article](https://dev.wix.com/docs/rest/business-management/categories/supported-filters-and-sorting) (REST).
     */
    filter?: Record<string, any> | null;
    /**
     * Array of sort objects specifying result order. For example, to sort by creation date in ascending order: `"sort": [{"fieldName": "createdDate", "order": "ASC"}]`.
     *
     * Learn more about the sort format in the [supported filters & sorting table](https://dev.wix.com/docs/sdk/backend-modules/categories/categories/search-categories) (SDK)
     * or the [supported filters article](https://dev.wix.com/docs/rest/business-management/categories/supported-filters-and-sorting) (REST).
     * @maxSize 10
     */
    sort?: Sorting[];
    /**
     * Aggregations for grouping data into categories (facets) and providing summaries for each category.
     * For example, use aggregations to categorize search results by service type, payment options, or locations.
     * @maxSize 10
     */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * Time zone in [IANA tz database format](https://en.wikipedia.org/wiki/Tz_database) or [ISO 8601 UTC offset format](https://en.wikipedia.org/wiki/ISO_8601#Time_offsets_from_UTC) for adjusting time fields in the specified filters and returned aggregation data. For example, `America/New_York`, `UTC`, or `+02:00`.
     *
     * Default: Time zone specified in the business site properties ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/site-properties/get-site-properties) | [REST](https://dev.wix.com/docs/rest/business-management/site-properties/properties/get-site-properties)).
     * @maxLength 50
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor-based paging for result navigation. When requesting `cursor_paging.cursor`,
     * `filter`, `sort`, or `search` can't be specified.
     */
    cursorPaging?: CursorPaging;
}
interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
    /** Range aggregation configuration. */
    range?: RangeAggregation;
    /** Scalar aggregation configuration. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation configuration. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation configuration. */
    nested?: NestedAggregation;
    /**
     * User-defined name of aggregation. Must be unique and will appear in aggregation results.
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation. Client must specify matching aggregation field below. */
    type?: AggregationTypeWithLiterals;
    /**
     * Path to the field to aggregate by in dot notation. For example `name` or `paymentOptions.online`.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface AggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
    /** Range aggregation configuration. */
    range?: RangeAggregation;
    /** Scalar aggregation configuration. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation configuration. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation configuration. */
    nested?: NestedAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if `to` isn't specified. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` isn't specified. */
    to?: number | null;
}
declare enum SortType {
    /** Sort by number of matches. */
    COUNT = "COUNT",
    /** Sort alphabetically by field value. */
    VALUE = "VALUE"
}
/** @enumType */
type SortTypeWithLiterals = SortType | 'COUNT' | 'VALUE';
declare enum SortDirection {
    /** Descending order. */
    DESC = "DESC",
    /** Ascending order. */
    ASC = "ASC"
}
/** @enumType */
type SortDirectionWithLiterals = SortDirection | 'DESC' | 'ASC';
declare enum MissingValues {
    /** Exclude missing values from the aggregation results. */
    EXCLUDE = "EXCLUDE",
    /** Include missing values in the aggregation results. */
    INCLUDE = "INCLUDE"
}
/** @enumType */
type MissingValuesWithLiterals = MissingValues | 'EXCLUDE' | 'INCLUDE';
interface IncludeMissingValuesOptions {
    /**
     * Custom bucket name for missing values.
     *
     * Default values:
     * - string: `N/A`
     * - int: `0`
     * - bool: `false`
     * @maxLength 20
     */
    addToBucket?: string;
}
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Total number of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX"
}
/** @enumType */
type ScalarTypeWithLiterals = ScalarType | 'UNKNOWN_SCALAR_TYPE' | 'COUNT_DISTINCT' | 'MIN' | 'MAX';
interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values in the aggregation results. */
    includeOptions?: IncludeMissingValuesOptions;
    /** Whether to sort by number of matches or value of the field. */
    sortType?: SortTypeWithLiterals;
    /** Whether to sort in ascending or descending order. */
    sortDirection?: SortDirectionWithLiterals;
    /**
     * Number of aggregations to return.
     *
     * Min: `1`
     * Max: `250`
     * Default: `10`
     */
    limit?: number | null;
    /**
     * Whether missing values should be included or excluded from the aggregation results.
     *
     * Default: `EXCLUDE`
     */
    missingValues?: MissingValuesWithLiterals;
}
/** @oneof */
interface ValueAggregationOptionsOneOf {
    /** Options for including missing values in the aggregation results. */
    includeOptions?: IncludeMissingValuesOptions;
}
declare enum NestedAggregationType {
    /** Unknown aggregation type. */
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
    VALUE = "VALUE",
    /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
    RANGE = "RANGE",
    /** Calculates a single numerical value from a dataset, summarizing the dataset into 1 key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    SCALAR = "SCALAR",
    /** Calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
/** @enumType */
type NestedAggregationTypeWithLiterals = NestedAggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM';
interface RangeAggregation {
    /**
     * List of range buckets defining the ranges for aggregation. During aggregation, each entity is placed in the first bucket where its value falls within the specified range bounds.
     * @maxSize 50
     */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Operator for the scalar aggregation, for example `COUNT_DISTINCT`, `MIN`, `MAX`. */
    type?: ScalarTypeWithLiterals;
}
interface DateHistogramAggregation {
    /** Time interval for date histogram aggregation, for example `DAY`, `HOUR`, `MONTH`. */
    interval?: IntervalWithLiterals;
}
declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval. */
    YEAR = "YEAR",
    /** Monthly interval. */
    MONTH = "MONTH",
    /** Weekly interval. */
    WEEK = "WEEK",
    /** Daily interval. */
    DAY = "DAY",
    /** Hourly interval. */
    HOUR = "HOUR",
    /** Minute interval. */
    MINUTE = "MINUTE",
    /** Second interval. */
    SECOND = "SECOND"
}
/** @enumType */
type IntervalWithLiterals = Interval | 'UNKNOWN_INTERVAL' | 'YEAR' | 'MONTH' | 'WEEK' | 'DAY' | 'HOUR' | 'MINUTE' | 'SECOND';
interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation configuration. Calculates the distribution of field values within the dataset. */
    value?: ValueAggregation;
    /** Range aggregation configuration. Calculates counts within user-defined value ranges. */
    range?: RangeAggregation;
    /** Scalar aggregation configuration. Calculates single numerical metrics like count, min, max, sum, or average. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation configuration. Calculates counts within time intervals. */
    dateHistogram?: DateHistogramAggregation;
    /**
     * User-defined name of aggregation. Must be unique and will appear in aggregation results.
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation. Client must specify matching aggregation field below. */
    type?: NestedAggregationTypeWithLiterals;
    /**
     * Path to the field to aggregate by in dot notation. For example `name` or `paymentOptions.online`.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf {
    /** Value aggregation configuration. Calculates the distribution of field values within the dataset. */
    value?: ValueAggregation;
    /** Range aggregation configuration. Calculates counts within user-defined value ranges. */
    range?: RangeAggregation;
    /** Scalar aggregation configuration. Calculates single numerical metrics like count, min, max, sum, or average. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation configuration. Calculates counts within time intervals. */
    dateHistogram?: DateHistogramAggregation;
}
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
    VALUE = "VALUE",
    /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
    RANGE = "RANGE",
    /** Calculates a single numerical value from a dataset, summarizing the dataset into 1 key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    SCALAR = "SCALAR",
    /** Calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Flattened list of aggregations, where each aggregation is nested within previous 1. */
    NESTED = "NESTED"
}
/** @enumType */
type AggregationTypeWithLiterals = AggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM' | 'NESTED';
/** Nested aggregation for multi-level faceted search. Allows exploring large amounts of data through multiple levels of categorization, where each subsequent aggregation is nested within the previous aggregation to create hierarchical data summaries. */
interface NestedAggregation {
    /**
     * Flattened list of aggregations, where each next aggregation is nested within the previous 1.
     * @minSize 2
     * @maxSize 3
     */
    nestedAggregations?: NestedAggregationItem[];
}
interface SearchDetails {
    /** Search mode. Defines the search logic for combining multiple terms in the `expression`. */
    mode?: ModeWithLiterals;
    /**
     * Search term or expression.
     * @maxLength 100
     */
    expression?: string | null;
    /**
     * Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `parentCategory.index`.
     * @maxLength 200
     * @maxSize 20
     */
    fields?: string[];
    /** Whether to enable the search method to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions. */
    fuzzy?: boolean;
}
declare enum Mode {
    /** At least 1 of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
/** @enumType */
type ModeWithLiterals = Mode | 'OR' | 'AND';
interface SearchCategoriesResponse {
    /**
     * Retrieved categories that match the search criteria specified in the request.
     *
     * Each category includes all standard category information.
     * @maxSize 1000
     */
    categories?: Category[];
    /**
     * Cursor-based paging metadata for navigating search results.
     *
     * Contains the current page's cursor information, whether there are more results available,
     * and count details. Use the `next` cursor to retrieve subsequent pages of results.
     */
    pagingMetadata?: CursorPagingMetadata;
    /**
     * Aggregation results based on the aggregations specified in the search request.
     *
     * Provides categorized data summaries. Only available when aggregations
     * are requested in the search criteria.
     */
    aggregationData?: AggregationData;
}
interface AggregationData {
    /**
     * Array of aggregation results, each containing the aggregation metadata and its calculated values for the specified search criteria.
     * @maxSize 10000
     */
    results?: AggregationResults[];
}
interface ValueAggregationResult {
    /**
     * Value of the field
     * @maxLength 100
     */
    value?: string;
    /** Count of entities with this value */
    count?: number;
}
interface RangeAggregationResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number;
}
interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /**
     * User-defined name of aggregation, matches the one specified in request.
     * @maxLength 100
     */
    name?: string;
    /** Type of aggregation that matches result. */
    type?: AggregationTypeWithLiterals;
    /**
     * Path to the field to aggregate by in dot notation. For example `appNamespace`.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
}
interface ValueResults {
    /**
     * Array of value aggregation results, each containing a field value and the count of entities with that value.
     * @maxSize 250
     */
    results?: ValueAggregationResult[];
}
interface RangeResults {
    /**
     * Array of range aggregation results returned in the same order as requested, each containing range bounds and count of entities within that range.
     * @maxSize 50
     */
    results?: RangeAggregationResult[];
}
interface AggregationResultsScalarResult {
    /** Type of scalar aggregation. */
    type?: ScalarTypeWithLiterals;
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedValueAggregationResult {
    /**
     * Value of the field.
     * @maxLength 1000
     */
    value?: string;
    /** Nested aggregations. */
    nestedResults?: NestedAggregationResults;
}
interface ValueResult {
    /**
     * Value of the field.
     * @maxLength 1000
     */
    value?: string;
    /** Count of entities with this value. */
    count?: number | null;
}
interface RangeResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number | null;
}
interface ScalarResult {
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedResultValue extends NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
/** @oneof */
interface NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
interface Results {
    /** Map of nested aggregation results, keyed by aggregation name. */
    results?: Record<string, NestedResultValue>;
}
interface DateHistogramResult {
    /**
     * Date in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601).
     * @maxLength 100
     */
    value?: string;
    /** Count of documents in the bucket. */
    count?: number;
}
interface GroupByValueResults {
    /**
     * Array of nested value aggregation results, each containing a field value and the associated nested aggregation data.
     * @maxSize 1000
     */
    results?: NestedValueAggregationResult[];
}
interface DateHistogramResults {
    /**
     * Array of date histogram aggregation results, each containing a date bucket and its count.
     * @maxSize 200
     */
    results?: DateHistogramResult[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form.
 * Aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface NestedResults {
    /**
     * Array of nested aggregation result groups, each containing multiple aggregation results.
     * @maxSize 1000
     */
    results?: Results[];
}
interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
    /**
     * User-defined name of aggregation as derived from search request.
     * @maxLength 100
     */
    name?: string;
    /** Type of aggregation that must match specified kind as derived from search request. */
    type?: AggregationTypeWithLiterals;
    /**
     * Path to the field to aggregate by in dot notation. For example `appNamespace`.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
}
interface CountCategoriesRequest {
    /**
     * Filter object.
     *
     * Learn more about the [filter object structure](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /** Search options. */
    search?: SearchDetails;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Whether to return categories with `visible: false` (hidden categories).
     *
     * Default: `false` - only visible categories are returned in the response
     */
    returnNonVisibleCategories?: boolean;
}
interface CountCategoriesResponse {
    /** Total count of categories which satisfy the given filter and/or search. */
    count?: number;
}
interface MoveCategoryRequest {
    /**
     * ID of the category to move.
     * @format GUID
     */
    categoryId: string;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Parent category ID.
     *
     * Default: root category ID
     * @format GUID
     */
    parentCategoryId?: string | null;
    /**
     * Where to place the subcategory.
     *
     * + `FIRST`: Position the category as the first subcategory.
     * + `LAST`: Position the category as the last subcategory.
     * + `AFTER`: Position the category after the category ID passed in `moveAfterCategoryId`.
     */
    position: PositionWithLiterals;
    /**
     * Required when passing `position: AFTER`.
     * @format GUID
     */
    moveAfterCategoryId?: string | null;
}
declare enum Position {
    UNKNOWN_POSITION = "UNKNOWN_POSITION",
    FIRST = "FIRST",
    LAST = "LAST",
    AFTER = "AFTER"
}
/** @enumType */
type PositionWithLiterals = Position | 'UNKNOWN_POSITION' | 'FIRST' | 'LAST' | 'AFTER';
interface MoveCategoryResponse {
    /**
     * Parent category ID.
     * @format GUID
     */
    parentCategoryId?: string | null;
    /**
     * List of category IDs in the new order of arrangement.
     * @format GUID
     * @maxSize 100
     */
    categoriesAfterMove?: string[];
}
interface BulkUpdateCategoriesRequest {
    /**
     * List of categories to update.
     * @minSize 1
     * @maxSize 100
     */
    categories: MaskedCategory[];
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Whether to return the full category entity in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: RequestedFieldsWithLiterals[];
}
interface MaskedCategory {
    /** Category to update. */
    category?: Category;
}
interface BulkUpdateCategoriesResponse {
    /**
     * Categories updated by bulk action.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkCategoriesResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCategoriesResult {
    /** Bulk action metadata for category. */
    itemMetadata?: ItemMetadata;
    /**
     * Full category entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    category?: Category;
}
interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it's impossible (for example, when failing to create an item).
     * @format GUID
     */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateCategoryVisibilityRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /**
     * Whether the category is visible to site visitors in dynamic pages.
     *
     * + If a parent category's visibility is set to `false`, all the children categories' visibility will also be set to `false`.
     * + Passing `true` will fail if the visibility of any parent categories is `false`.
     */
    visible: boolean;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Latest revision of the category.
     * To prevent conflicting changes, the current revision must be passed on update.
     */
    revision: string | null;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: SingleEntityOpsRequestedFieldsWithLiterals[];
}
interface UpdateCategoryVisibilityResponse {
    /** Updated category. */
    category?: Category;
}
interface BulkShowCategoriesRequest {
    /**
     * IDs of the categories to update.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    categoryIds: string[];
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Whether to return the category entity in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     * @maxSize 100
     */
    fields?: RequestedFieldsWithLiterals[];
}
interface BulkShowCategoriesResponse {
    /**
     * Categories updated by bulk action.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkCategoriesResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkAddItemsToCategoryRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /**
     * List of items to add.
     * @minSize 1
     * @maxSize 1000
     */
    items: ItemReference[];
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface BulkAddItemsToCategoryResponse {
    /**
     * List of items added to a category by bulk action.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkItemsToCategoryResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkItemsToCategoryResult {
    /** Bulk action metadata for item reference. */
    itemMetadata?: ItemReferenceMetadata;
}
interface ItemReferenceMetadata {
    /** Catalog and item reference info. */
    item?: ItemReference;
    /** Original index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /**
     * Whether the action was successful.
     * When `false`, the `error` field is populated.
     */
    success?: boolean;
    /** Error details in the case of an unsuccessful action. */
    error?: ApplicationError;
}
interface BulkAddItemToCategoriesRequest {
    /** Item to add. */
    item: ItemReference;
    /**
     * IDs of categories to which to add the item.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    categoryIds: string[];
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface BulkAddItemToCategoriesResponse {
    /**
     * Items added by bulk action.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkItemToCategoriesResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkItemToCategoriesResult {
    /** Bulk action metadata for category. */
    itemMetadata?: ItemMetadata;
}
interface BulkRemoveItemsFromCategoryRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /**
     * List of items to remove.
     * @minSize 1
     * @maxSize 100
     */
    items: ItemReference[];
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface BulkRemoveItemsFromCategoryResponse {
    /**
     * Items removed by bulk action.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkItemsToCategoryResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkRemoveItemFromCategoriesRequest {
    /** Item to remove. */
    item: ItemReference;
    /**
     * IDs of categories from which to remove the item.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    categoryIds: string[];
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface BulkRemoveItemFromCategoriesResponse {
    /**
     * Items removed by bulk action.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkItemToCategoriesResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface ListItemsInCategoryRequest extends ListItemsInCategoryRequestPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * Whether to use category arrangement for sorting items.
     *
     * Default: `false`
     */
    useCategoryArrangement?: boolean;
    /**
     * Whether to include items from subcategories.
     *
     * Default: `false` (only direct items of the category will be returned)
     */
    includeItemsFromSubcategories?: boolean;
}
/** @oneof */
interface ListItemsInCategoryRequestPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
}
interface ListItemsInCategoryResponse {
    /**
     * List of items in the category.
     * @maxSize 100
     */
    items?: ItemReference[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface ListCategoriesForItemRequest {
    /** Item reference info. */
    item: ItemReference;
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface ListCategoriesForItemResponse {
    /**
     * List of IDs of categories that directly contain this item.
     * @format GUID
     * @maxSize 1000
     */
    directCategoryIds?: string[];
    /**
     * List of IDs of categories that directly contain this item, and their parent category IDs.
     * @format GUID
     * @maxSize 1000
     */
    allCategoryIds?: string[];
}
interface ListCategoriesForItemsRequest {
    /**
     * List of Item reference info.
     * @maxSize 100
     */
    items: ItemReference[];
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface ListCategoriesForItemsResponse {
    /**
     * Map of item references to lists of direct category IDs and all category IDs, including parent categories and direct ones.
     * @maxSize 100
     */
    categoriesForItems?: MapItemToCategories[];
}
interface MapItemToCategories {
    /** Item reference info. */
    item?: ItemReference;
    /**
     * List of IDs of categories that directly contain this item.
     * @format GUID
     * @maxSize 1000
     */
    directCategoryIds?: string[];
    /**
     * List of IDs of categories that indirectly contain this item, including all ancestors of its direct categories in the hierarchy.
     * @format GUID
     * @maxSize 1000
     */
    indirectCategoryIds?: string[];
}
interface ListTreesRequest {
}
interface ListTreesResponse {
    /**
     * List of trees.
     * @maxSize 20
     */
    trees?: TreeReference[];
}
interface SetArrangedItemsRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /** Category tree reference details. */
    treeReference: TreeReference;
    /**
     * List of items to set.
     * @maxSize 100
     */
    items?: ItemReference[];
}
interface SetArrangedItemsResponse {
    /**
     * List of arranged items.
     * @maxSize 100
     */
    items?: ItemReference[];
}
interface GetArrangedItemsRequest {
    /**
     * Category ID.
     * @format GUID
     */
    categoryId: string;
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface GetArrangedItemsResponse {
    /**
     * List of arranged items.
     * @maxSize 100
     */
    items?: ItemReference[];
}
interface BulkSetItemCategoriesRequest {
    /** The item to update. */
    item: ItemReference;
    /**
     * List of category IDs to set for the item.
     * @format GUID
     * @maxSize 1000
     */
    categoryIds?: string[];
    /** Category tree reference details. */
    treeReference: TreeReference;
}
interface BulkSetItemCategoriesResponse {
    /** Results for add operations */
    addResults?: BulkItemToCategoriesResult[];
    /** Results for remove operations */
    removeResults?: BulkItemToCategoriesResult[];
    /** Bulk action metadata */
    bulkActionMetadata?: BulkActionMetadata;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createCategory(): __PublicMethodMetaInfo<'POST', {}, CreateCategoryRequest$1, CreateCategoryRequest, CreateCategoryResponse$1, CreateCategoryResponse>;
declare function getCategory(): __PublicMethodMetaInfo<'GET', {
    categoryId: string;
}, GetCategoryRequest$1, GetCategoryRequest, GetCategoryResponse$1, GetCategoryResponse>;
declare function updateCategory(): __PublicMethodMetaInfo<'PATCH', {
    categoryId: string;
}, UpdateCategoryRequest$1, UpdateCategoryRequest, UpdateCategoryResponse$1, UpdateCategoryResponse>;
declare function deleteCategory(): __PublicMethodMetaInfo<'DELETE', {
    categoryId: string;
}, DeleteCategoryRequest$1, DeleteCategoryRequest, DeleteCategoryResponse$1, DeleteCategoryResponse>;
declare function queryCategories(): __PublicMethodMetaInfo<'POST', {}, QueryCategoriesRequest$1, QueryCategoriesRequest, QueryCategoriesResponse$1, QueryCategoriesResponse>;
declare function searchCategories(): __PublicMethodMetaInfo<'POST', {}, SearchCategoriesRequest$1, SearchCategoriesRequest, SearchCategoriesResponse$1, SearchCategoriesResponse>;
declare function countCategories(): __PublicMethodMetaInfo<'POST', {}, CountCategoriesRequest$1, CountCategoriesRequest, CountCategoriesResponse$1, CountCategoriesResponse>;
declare function moveCategory(): __PublicMethodMetaInfo<'POST', {
    categoryId: string;
}, MoveCategoryRequest$1, MoveCategoryRequest, MoveCategoryResponse$1, MoveCategoryResponse>;
declare function bulkUpdateCategories(): __PublicMethodMetaInfo<'POST', {}, BulkUpdateCategoriesRequest$1, BulkUpdateCategoriesRequest, BulkUpdateCategoriesResponse$1, BulkUpdateCategoriesResponse>;
declare function updateCategoryVisibility(): __PublicMethodMetaInfo<'PATCH', {}, UpdateCategoryVisibilityRequest$1, UpdateCategoryVisibilityRequest, UpdateCategoryVisibilityResponse$1, UpdateCategoryVisibilityResponse>;
declare function bulkShowCategories(): __PublicMethodMetaInfo<'POST', {}, BulkShowCategoriesRequest$1, BulkShowCategoriesRequest, BulkShowCategoriesResponse$1, BulkShowCategoriesResponse>;
declare function bulkAddItemsToCategory(): __PublicMethodMetaInfo<'POST', {
    categoryId: string;
}, BulkAddItemsToCategoryRequest$1, BulkAddItemsToCategoryRequest, BulkAddItemsToCategoryResponse$1, BulkAddItemsToCategoryResponse>;
declare function bulkAddItemToCategories(): __PublicMethodMetaInfo<'POST', {}, BulkAddItemToCategoriesRequest$1, BulkAddItemToCategoriesRequest, BulkAddItemToCategoriesResponse$1, BulkAddItemToCategoriesResponse>;
declare function bulkRemoveItemsFromCategory(): __PublicMethodMetaInfo<'POST', {
    categoryId: string;
}, BulkRemoveItemsFromCategoryRequest$1, BulkRemoveItemsFromCategoryRequest, BulkRemoveItemsFromCategoryResponse$1, BulkRemoveItemsFromCategoryResponse>;
declare function bulkRemoveItemFromCategories(): __PublicMethodMetaInfo<'POST', {}, BulkRemoveItemFromCategoriesRequest$1, BulkRemoveItemFromCategoriesRequest, BulkRemoveItemFromCategoriesResponse$1, BulkRemoveItemFromCategoriesResponse>;
declare function listItemsInCategory(): __PublicMethodMetaInfo<'GET', {
    categoryId: string;
}, ListItemsInCategoryRequest$1, ListItemsInCategoryRequest, ListItemsInCategoryResponse$1, ListItemsInCategoryResponse>;
declare function listCategoriesForItem(): __PublicMethodMetaInfo<'GET', {}, ListCategoriesForItemRequest$1, ListCategoriesForItemRequest, ListCategoriesForItemResponse$1, ListCategoriesForItemResponse>;
declare function listCategoriesForItems(): __PublicMethodMetaInfo<'GET', {}, ListCategoriesForItemsRequest$1, ListCategoriesForItemsRequest, ListCategoriesForItemsResponse$1, ListCategoriesForItemsResponse>;
declare function listTrees(): __PublicMethodMetaInfo<'GET', {}, ListTreesRequest$1, ListTreesRequest, ListTreesResponse$1, ListTreesResponse>;
declare function setArrangedItems(): __PublicMethodMetaInfo<'POST', {
    categoryId: string;
}, SetArrangedItemsRequest$1, SetArrangedItemsRequest, SetArrangedItemsResponse$1, SetArrangedItemsResponse>;
declare function getArrangedItems(): __PublicMethodMetaInfo<'GET', {
    categoryId: string;
}, GetArrangedItemsRequest$1, GetArrangedItemsRequest, GetArrangedItemsResponse$1, GetArrangedItemsResponse>;
declare function bulkSetItemCategories(): __PublicMethodMetaInfo<'POST', {}, BulkSetItemCategoriesRequest$1, BulkSetItemCategoriesRequest, BulkSetItemCategoriesResponse$1, BulkSetItemCategoriesResponse>;

export { type __PublicMethodMetaInfo, bulkAddItemToCategories, bulkAddItemsToCategory, bulkRemoveItemFromCategories, bulkRemoveItemsFromCategory, bulkSetItemCategories, bulkShowCategories, bulkUpdateCategories, countCategories, createCategory, deleteCategory, getArrangedItems, getCategory, listCategoriesForItem, listCategoriesForItems, listItemsInCategory, listTrees, moveCategory, queryCategories, searchCategories, setArrangedItems, updateCategory, updateCategoryVisibility };
