import { NonNullablePaths } from '@wix/sdk-types';

interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
interface PaymentReceiptInfoOneOf {
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
    /**
     * Record of chargebacks made by the buyer.
     * @maxSize 6
     */
    chargebacks?: Chargeback[];
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
/** @enumType */
type TransactionStatusWithLiterals = TransactionStatus | 'UNDEFINED' | 'APPROVED' | 'PENDING' | 'PENDING_MERCHANT' | 'CANCELED' | 'DECLINED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'AUTHORIZED' | 'VOIDED';
interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatusWithLiterals;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationCaptureStatusWithLiterals = AuthorizationCaptureStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatusWithLiterals;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: ReasonWithLiterals;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationVoidStatusWithLiterals = AuthorizationVoidStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
/** Reason the authorization was voided. */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'MANUAL' | 'SCHEDULED';
interface ScheduledAction {
    /** Type of the action. */
    actionType?: ActionTypeWithLiterals;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ActionTypeWithLiterals = ActionType | 'UNKNOWN_ACTION_TYPE' | 'VOID' | 'CAPTURE';
interface Chargeback {
    /**
     * Chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    _id?: string;
    /**
     * Date and time the chargeback was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Date and time the chargeback was updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Amount.
     * @readonly
     * @immutable
     */
    amount?: Price;
    /**
     * Reversal amount. Present only when status is REVERSED.
     * @readonly
     */
    reversalAmount?: Price;
    /**
     * Status.
     *
     * Default: `"APPROVED"`.
     */
    status?: ChargebackStatusWithLiterals;
    /**
     * External chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    externalId?: string | null;
}
declare enum ChargebackStatus {
    UNSPECIFIED = "UNSPECIFIED",
    /** Chargeback was approved. */
    APPROVED = "APPROVED",
    /** Chargeback was reversed. */
    REVERSED = "REVERSED"
}
/** @enumType */
type ChargebackStatusWithLiterals = ChargebackStatus | 'UNSPECIFIED' | 'APPROVED' | 'REVERSED';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
interface MembershipPaymentDetails {
    /**
     * Membership ID.
     * @minLength 1
     * @maxLength 100
     */
    membershipId?: string;
    /**
     * ID of the line item this membership applies to.
     * @minLength 1
     * @maxLength 100
     */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatusWithLiterals;
    /** Membership name. */
    name?: MembershipName;
    /**
     * The transaction ID in the membership system. Can be used to void the transaction.
     * @minLength 1
     * @maxLength 100
     */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * ID of the application providing this payment option.
     * @format GUID
     */
    providerAppId?: string;
}
declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
/** @enumType */
type MembershipPaymentStatusWithLiterals = MembershipPaymentStatus | 'CHARGED' | 'CHARGE_FAILED';
interface MembershipName {
    /**
     * Membership name.
     * @maxLength 100
     */
    original?: string;
    /**
     * Translated membership name. Defaults to `original` when not provided.
     * @maxLength 100
     */
    translated?: string | null;
}
interface WixReceiptInfo {
    /**
     * Receipt ID
     * @format GUID
     */
    receiptId?: string;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface ExternalReceiptInfo {
    /**
     * External receipt ID
     * @maxLength 100
     */
    receiptId?: string | null;
    /**
     * ID of the app providing the receipt
     * @format GUID
     */
    appId?: string | null;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatusWithLiterals;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
/** @enumType */
type RefundStatusWithLiterals = RefundStatus | 'PENDING' | 'SUCCEEDED' | 'FAILED' | 'SCHEDULED' | 'STARTED';
interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: ShippingRefund;
}
interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
interface AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
interface SnapshotMessage {
    _id?: string;
    opType?: number;
}
interface IndexingMessage {
    _id?: string;
    opType?: number;
    requiredVersions?: string[];
}
interface DiffmatokyPayload {
    left?: string;
    right?: string;
    compareChannel?: string;
    entityId?: string;
    errorInformation?: ErrorInformation;
    tags?: string[];
}
interface ErrorInformation {
    stackTrace?: string;
}
interface OrderRefunded {
    /**
     * Refund ID.
     * @readonly
     */
    refundId?: string;
    /**
     * Refunded order data.
     * @readonly
     */
    order?: Order;
}
interface Order {
    /**
     * Order ID (auto-generated upon order creation).
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Order number displayed in the owner's store (auto-generated).
     * @readonly
     */
    number?: number;
    /**
     * Order creation date and time.
     * @readonly
     */
    dateCreated?: Date | null;
    /** Buyer information. */
    buyerInfo?: BuyerInfo;
    /**
     * Currency used for the pricing of this order in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency?: string | null;
    /** Weight unit used in this store. */
    weightUnit?: WeightUnitWithLiterals;
    /** Totals for order's line items. */
    totals?: Totals;
    /** Billing information. */
    billingInfo?: BillingInfo;
    /** Shipping information. */
    shippingInfo?: ShippingInfo;
    /**
     * A note added by the buyer.
     * @maxLength 1000
     */
    buyerNote?: string | null;
    /**
     * Deprecated.
     * @readonly
     * @deprecated
     */
    read?: boolean;
    /**
     * Whether or not the order was archived.
     * @readonly
     */
    archived?: boolean;
    /** Current status of the payment. */
    paymentStatus?: PaymentStatusWithLiterals;
    /**
     * Order's current fulfillment status (whether the order received a tracking number or was delivered/picked up).
     * @readonly
     */
    fulfillmentStatus?: FulfillmentStatusWithLiterals;
    /**
     * Line items ordered.
     * @minSize 1
     * @maxSize 300
     */
    lineItems?: LineItem[];
    /**
     * Log of updates related to the order.
     * @readonly
     */
    activities?: Activity[];
    /** Invoice information. */
    invoiceInfo?: V2InvoiceInfo;
    /**
     * Order fulfillment information.
     * @readonly
     */
    fulfillments?: Fulfillment[];
    /** Discount information. */
    discount?: Discount;
    /** Custom field information. */
    customField?: CustomField;
    /**
     * Shopping cart ID.
     * @format GUID
     */
    cartId?: string | null;
    /**
     * Language for communication with the buyer. Defaults to the site language.
     * For a site that supports multiple languages, this is the language the buyer selected.
     * @maxLength 10
     */
    buyerLanguage?: string | null;
    /** Information about the sales channel that submitted this order. */
    channelInfo?: ChannelInfo;
    /**
     * Identity of the order's initiator.
     * @readonly
     */
    enteredBy?: EnteredBy;
    /**
     * Date and time of latest update.
     * @readonly
     */
    lastUpdated?: Date | null;
    /** Subscription information. */
    subscriptionInfo?: SubscriptionInfo;
    /**
     * Order’s unique numeric ID.
     * Primarily used for sorting and filtering when crawling all orders.
     * @readonly
     */
    numericId?: string;
    /**
     * Refund information.
     * @readonly
     */
    refunds?: V2Refund[];
}
/** Buyer Info */
interface BuyerInfo {
    /**
     * Wix customer ID
     * @format GUID
     */
    _id?: string | null;
    /**
     * Deprecated (use identityType instead)
     * @readonly
     * @deprecated
     */
    type?: IdentityTypeWithLiterals;
    /** Customer type */
    identityType?: IdentityTypeWithLiterals;
    /**
     * Customer's first name
     * @readonly
     */
    firstName?: string;
    /**
     * Customer's last name
     * @readonly
     */
    lastName?: string;
    /**
     * Customer's phone number
     * @readonly
     */
    phone?: string | null;
    /**
     * Customer's email address
     * @readonly
     */
    email?: string;
}
declare enum IdentityType {
    UNSPECIFIED_IDENTITY_TYPE = "UNSPECIFIED_IDENTITY_TYPE",
    /** Site member */
    MEMBER = "MEMBER",
    /** Contact */
    CONTACT = "CONTACT"
}
/** @enumType */
type IdentityTypeWithLiterals = IdentityType | 'UNSPECIFIED_IDENTITY_TYPE' | 'MEMBER' | 'CONTACT';
declare enum WeightUnit {
    /** Weight unit can't be classified due to an error. */
    UNSPECIFIED_WEIGHT_UNIT = "UNSPECIFIED_WEIGHT_UNIT",
    /** Kilograms. */
    KG = "KG",
    /** Pounds. */
    LB = "LB"
}
/** @enumType */
type WeightUnitWithLiterals = WeightUnit | 'UNSPECIFIED_WEIGHT_UNIT' | 'KG' | 'LB';
interface Totals {
    /**
     * Subtotal of all the line items, before tax.
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /**
     * Total shipping price, before tax.
     * @format DECIMAL_VALUE
     */
    shipping?: string | null;
    /**
     * Total tax.
     * @format DECIMAL_VALUE
     */
    tax?: string | null;
    /**
     * Total calculated discount value.
     * @format DECIMAL_VALUE
     */
    discount?: string | null;
    /**
     * Total price charged.
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Total items weight.
     * @readonly
     */
    weight?: string;
    /**
     * Total number of line items.
     * @readonly
     */
    quantity?: number;
    /**
     * Total refund.
     * @format DECIMAL_VALUE
     * @readonly
     */
    refund?: string | null;
    /**
     * Total calculated gift card value.
     * @format DECIMAL_VALUE
     */
    giftCard?: string | null;
}
interface BillingInfo {
    /**
     * Payment method used for this order
     * @maxLength 50
     */
    paymentMethod?: string | null;
    /**
     * Deprecated (use paymentProviderTransactionId instead)
     * @readonly
     * @deprecated
     */
    externalTransactionId?: string | null;
    /**
     * Transaction ID from payment provider (e.g., PayPal, Square, Stripe) transaction ID
     * @maxLength 100
     */
    paymentProviderTransactionId?: string | null;
    /**
     * Transaction ID from payment gateway (e.g., Wix Payments)
     * @maxLength 100
     */
    paymentGatewayTransactionId?: string | null;
    /** Full billing address */
    address?: Address;
    /**
     * Payment date
     * @readonly
     */
    paidDate?: Date | null;
    /** Whether order can be refunded by payment provider (manually or automatic) */
    refundableByPaymentProvider?: boolean | null;
}
interface Address extends AddressAddressLine1OptionsOneOf {
    /**
     * Address line 1 (free text)
     * @maxLength 1000
     */
    addressLine1?: string;
    /** Address line 1 (street) */
    street?: Street;
    /** Addressee name */
    fullName?: FullName;
    /**
     * Country code (2 letters)
     * @format COUNTRY
     */
    country?: string | null;
    /**
     * State or district
     * @maxLength 50
     */
    subdivision?: string | null;
    /**
     * City name
     * @maxLength 150
     */
    city?: string | null;
    /**
     * ZIP/postal code
     * @maxLength 200
     */
    zipCode?: string | null;
    /**
     * Phone number
     * @maxLength 200
     */
    phone?: string | null;
    /**
     * Company name
     * @maxLength 500
     */
    company?: string | null;
    /**
     * Email address
     * @maxLength 500
     */
    email?: string | null;
    /**
     * address line
     * @maxLength 250
     */
    addressLine2?: string | null;
    /** Tax information (for Brazil only) */
    vatId?: VatId;
}
/** @oneof */
interface AddressAddressLine1OptionsOneOf {
    /**
     * Address line 1 (free text)
     * @maxLength 1000
     */
    addressLine1?: string;
    /** Address line 1 (street) */
    street?: Street;
}
interface FullName {
    /**
     * Customer's first name
     * @maxLength 1000
     */
    firstName?: string;
    /**
     * Customer's last name
     * @maxLength 1000
     */
    lastName?: string;
}
interface Street {
    /**
     * Street number
     * @maxLength 500
     */
    number?: string;
    /**
     * Street name
     * @maxLength 1000
     */
    name?: string;
}
interface VatId {
    /**
     * Customer's tax ID.
     * @maxLength 50
     */
    number?: string;
    /**
     * Tax type.
     * + `CPF`: For individual tax payers.
     * + `CNPJ`: For corporations.
     */
    type?: VatTypeWithLiterals;
}
/** Brazilian tax info types */
declare enum VatType {
    /** When the tax info type can't be classified, due to an error */
    UNSPECIFIED_TAX_TYPE = "UNSPECIFIED_TAX_TYPE",
    /** CPF - for individual tax payers */
    CPF = "CPF",
    /** CNPJ - for corporations */
    CNPJ = "CNPJ"
}
/** @enumType */
type VatTypeWithLiterals = VatType | 'UNSPECIFIED_TAX_TYPE' | 'CPF' | 'CNPJ';
interface ShippingInfo extends ShippingInfoDetailsOneOf {
    /** Shipment details (when this object describes shipment). */
    shipmentDetails?: ShipmentDetails;
    /** Pickup details (when this object describes pickup). */
    pickupDetails?: PickupDetails;
    /**
     * Shipping option name.
     * @maxLength 1000
     */
    deliveryOption?: string;
    /**
     * Shipping option delivery time.
     * @maxLength 500
     */
    estimatedDeliveryTime?: string | null;
    /**
     * Deprecated - Latest expected delivery date.
     * @deprecated
     */
    deliverByDate?: Date | null;
    /**
     * Shipping region.
     * @maxLength 100
     */
    shippingRegion?: string | null;
    /**
     * Unique code of provided shipping option. For example, `"usps_std_overnight"`.
     * @maxLength 100
     * @readonly
     */
    code?: string | null;
}
/** @oneof */
interface ShippingInfoDetailsOneOf {
    /** Shipment details (when this object describes shipment). */
    shipmentDetails?: ShipmentDetails;
    /** Pickup details (when this object describes pickup). */
    pickupDetails?: PickupDetails;
}
interface ShipmentDetails {
    /** Shipping destination address. */
    address?: Address;
    /**
     * Deprecated (use fulfillments instead).
     * @readonly
     * @deprecated
     */
    trackingInfo?: TrackingInfo;
    /**
     * Discount applied for shipping.
     * @format DECIMAL_VALUE
     */
    discount?: string | null;
    /**
     * Tax applied for shipping.
     * @format DECIMAL_VALUE
     */
    tax?: string | null;
    /** Price data. */
    priceData?: ShippingPriceData;
}
interface TrackingInfo {
    /**
     * Tracking number
     * @maxLength 100
     * @readonly
     */
    trackingNumber?: string | null;
    /**
     * Shipping provider
     * @maxLength 100
     * @readonly
     */
    shippingProvider?: string | null;
    /**
     * Tracking link
     * @format WEB_URL
     * @readonly
     */
    trackingLink?: string | null;
}
interface ShippingPriceData {
    /** Whether tax is included in the price. */
    taxIncludedInPrice?: boolean;
    /**
     * Shipping price.
     * @format DECIMAL_VALUE
     */
    price?: string | null;
}
interface PickupDetails {
    /** Pickup address. */
    pickupAddress?: PickupAddress;
    /**
     * Deprecated (use billingInfo instead).
     * @readonly
     * @deprecated
     */
    buyerDetails?: BuyerDetails;
    /**
     * Store owner's pickup instructions.
     * @maxLength 1000
     */
    pickupInstructions?: string | null;
}
interface PickupAddress {
    /** Country code (3 letters) */
    country?: string;
    /**
     * State/District
     * @maxLength 50
     */
    subdivision?: string | null;
    /**
     * Address
     * @maxLength 250
     */
    addressLine1?: string;
    /**
     * City
     * @maxLength 100
     */
    city?: string;
    /**
     * ZIP/postal code
     * @maxLength 50
     */
    zipCode?: string;
}
interface BuyerDetails {
    /** Addressee name */
    fullName?: FullName;
    /**
     * Email address
     * @maxLength 100
     * @format EMAIL
     */
    email?: string;
    /**
     * Phone number
     * @maxLength 30
     * @format PHONE
     */
    phone?: string;
}
/** This might be extended in the future with pending orders statuses */
declare enum PaymentStatus {
    /** Payment status can't be classified, due to an error */
    UNSPECIFIED_PAYMENT_STATUS = "UNSPECIFIED_PAYMENT_STATUS",
    /** Order is pending response from the payment provider */
    PENDING = "PENDING",
    /** Order is marked as not paid, and can be marked as paid later on. This is relevant for POS and offline orders */
    NOT_PAID = "NOT_PAID",
    /** The order is marked as paid */
    PAID = "PAID",
    /** Order was refunded, refund amount less than order total price */
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    /** Full order total price was refunded */
    FULLY_REFUNDED = "FULLY_REFUNDED",
    /** At least one payment was received and approved, covering less than total price amount */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
/** @enumType */
type PaymentStatusWithLiterals = PaymentStatus | 'UNSPECIFIED_PAYMENT_STATUS' | 'PENDING' | 'NOT_PAID' | 'PAID' | 'PARTIALLY_REFUNDED' | 'FULLY_REFUNDED' | 'PARTIALLY_PAID';
declare enum FulfillmentStatus {
    /** None of the order items are fulfilled */
    NOT_FULFILLED = "NOT_FULFILLED",
    /**
     * All of the order items are fulfilled
     * Orders without shipping info are fulfilled automatically
     */
    FULFILLED = "FULFILLED",
    /** Order is canceled */
    CANCELED = "CANCELED",
    /** Some, but not all of the order items are fulfilled */
    PARTIALLY_FULFILLED = "PARTIALLY_FULFILLED"
}
/** @enumType */
type FulfillmentStatusWithLiterals = FulfillmentStatus | 'NOT_FULFILLED' | 'FULFILLED' | 'CANCELED' | 'PARTIALLY_FULFILLED';
interface LineItem {
    /**
     * Line item ID (auto-generated, stable within this order only)
     * @readonly
     */
    index?: number | null;
    /**
     * Line item quantity
     * @min 1
     * @max 100000
     */
    quantity?: number;
    /**
     * Deprecated (use priceData instead)
     * @format DECIMAL_VALUE
     * @readonly
     * @deprecated
     */
    price?: string | null;
    /**
     * Line item name
     * @minLength 1
     * @maxLength 200
     */
    name?: string | null;
    /** Product name, translated into the customer's language */
    translatedName?: string | null;
    /**
     * Line item product ID (optional for POS orders)
     * @minLength 1
     */
    productId?: string | null;
    /**
     * Deprecated (use priceData instead)
     * @format DECIMAL_VALUE
     * @readonly
     * @deprecated
     */
    totalPrice?: string | null;
    /** Line item type (may be extended) */
    lineItemType?: LineItemTypeWithLiterals;
    /**
     * Line item options ordered
     * @maxSize 500
     */
    options?: OptionSelection[];
    /**
     * Line item custom text field entry
     * @maxSize 500
     */
    customTextFields?: CustomTextFieldSelection[];
    /**
     * Line item weight
     * @format DECIMAL_VALUE
     */
    weight?: string | null;
    /** Primary media for preview of the line item */
    mediaItem?: MediaItem;
    /**
     * Line item SKU
     * @maxLength 40
     */
    sku?: string | null;
    /**
     * Line item notes
     * @maxLength 1000
     */
    notes?: string | null;
    /** Line item variantId (from Stores Catalog) */
    variantId?: string | null;
    /**
     * Line item fulfillerId from stores fulfillers. No value equals self fulfilled
     * @format GUID
     */
    fulfillerId?: string | null;
    /**
     * Discount applied for this line item
     * @format DECIMAL_VALUE
     */
    discount?: string | null;
    /**
     * Tax applied for this line item
     * @format DECIMAL_VALUE
     */
    tax?: string | null;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    taxIncludedInPrice?: boolean;
    /**
     * Tax group ID
     * @format GUID
     */
    taxGroupId?: string | null;
    /** Price data */
    priceData?: LineItemPriceData;
}
declare enum LineItemType {
    /** Line item type can't be classified, due to an error */
    UNSPECIFIED_LINE_ITEM_TYPE = "UNSPECIFIED_LINE_ITEM_TYPE",
    /** Physical item type */
    PHYSICAL = "PHYSICAL",
    /** Digital item type */
    DIGITAL = "DIGITAL",
    /** Custom item price */
    CUSTOM_AMOUNT_ITEM = "CUSTOM_AMOUNT_ITEM"
}
/** @enumType */
type LineItemTypeWithLiterals = LineItemType | 'UNSPECIFIED_LINE_ITEM_TYPE' | 'PHYSICAL' | 'DIGITAL' | 'CUSTOM_AMOUNT_ITEM';
interface OptionSelection {
    /**
     * Option name
     * @maxLength 1000
     */
    option?: string;
    /**
     * Selected choice for this option
     * @maxLength 16000
     */
    selection?: string;
}
interface CustomTextFieldSelection {
    /**
     * Custom text field name
     * @maxLength 1000
     */
    title?: string;
    /**
     * Custom text field value
     * @maxLength 16000
     */
    value?: string;
}
interface MediaItem {
    /**
     * Media type
     * @readonly
     */
    mediaType?: MediaItemTypeWithLiterals;
    /**
     * Media URL
     * @format WEB_URL
     * @readonly
     */
    url?: string;
    /**
     * Media item width
     * @readonly
     */
    width?: number;
    /**
     * Media item height
     * @readonly
     */
    height?: number;
    /**
     * Deprecated
     * @deprecated
     */
    mediaId?: string | null;
    /** Media ID (for media items previously saved in Wix Media) */
    _id?: string | null;
    /** Media external URL */
    externalImageUrl?: string | null;
    /**
     * Alternative text for presentation when media cannot be displayed
     * @maxLength 256
     */
    altText?: string | null;
}
declare enum MediaItemType {
    /** Media item type can't be classified, due to an error */
    UNSPECIFIED_MEDIA_TYPE_ITEM = "UNSPECIFIED_MEDIA_TYPE_ITEM",
    /** Image item type */
    IMAGE = "IMAGE"
}
/** @enumType */
type MediaItemTypeWithLiterals = MediaItemType | 'UNSPECIFIED_MEDIA_TYPE_ITEM' | 'IMAGE';
interface LineItemPriceData {
    /** Whether tax is included in the price set for this line item */
    taxIncludedInPrice?: boolean;
    /**
     * Line item price
     * @format DECIMAL_VALUE
     */
    price?: string;
    /**
     * Total price charged to the customer (per line item) after computation of quantity and discount
     * @format DECIMAL_VALUE
     * @readonly
     */
    totalPrice?: string | null;
}
interface DigitalFile {
    /**
     * id of the secure file in media
     * @minLength 1
     * @maxLength 100
     */
    fileId?: string;
}
interface Activity {
    /**
     * Activity item type
     * @readonly
     */
    type?: ActivityTypeWithLiterals;
    /**
     * Activity item author
     * @maxLength 50
     * @readonly
     */
    author?: string | null;
    /**
     * Comment added to activity item
     * @maxLength 1000
     * @readonly
     */
    message?: string | null;
    /**
     * Activity item timestamp
     * @readonly
     */
    timestamp?: Date | null;
}
declare enum ActivityType {
    /** Activity item type can't be classified, due to an error */
    UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE = "UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE",
    /** Store owner added a comment */
    MERCHANT_COMMENT = "MERCHANT_COMMENT",
    /** Order placed */
    ORDER_PLACED = "ORDER_PLACED",
    /** Order marked as paid, either by the store owner (for offline orders), or when an online transaction was confirmed */
    ORDER_PAID = "ORDER_PAID",
    /** Order shipping status set as fulfilled */
    ORDER_FULFILLED = "ORDER_FULFILLED",
    /** Order shipping status set as not fulfilled */
    ORDER_NOT_FULFILLED = "ORDER_NOT_FULFILLED",
    /** A download link was sent (relevant for orders with digital line items) */
    DOWNLOAD_LINK_SENT = "DOWNLOAD_LINK_SENT",
    /** An email notification for pickup was sent */
    PICKUP_READY_EMAIL_SENT = "PICKUP_READY_EMAIL_SENT",
    /** Shipping tracking number was set */
    TRACKING_NUMBER_ADDED = "TRACKING_NUMBER_ADDED",
    /** Shipping tracking number was edited */
    TRACKING_NUMBER_EDITED = "TRACKING_NUMBER_EDITED",
    /** Shipping tracking link was set */
    TRACKING_LINK_WAS_SET = "TRACKING_LINK_WAS_SET",
    /** An email confirmation of order shipment was sent */
    SHIPPING_CONFIRMATION_EMAIL_SENT = "SHIPPING_CONFIRMATION_EMAIL_SENT",
    /** Invoice was set in the order */
    INVOICE_WAS_SET = "INVOICE_WAS_SET",
    /** Invoice was removed from the order */
    INVOICE_WAS_REMOVED = "INVOICE_WAS_REMOVED",
    /** Invoice was sent to customer via email */
    INVOICE_WAS_SENT = "INVOICE_WAS_SENT",
    /** Email was sent to fulfiller */
    FULFILLER_EMAIL_SENT = "FULFILLER_EMAIL_SENT",
    /** Shipping address was updated */
    SHIPPING_ADDRESS_EDITED = "SHIPPING_ADDRESS_EDITED",
    /** Order email was updated */
    EMAIL_EDITED = "EMAIL_EDITED",
    /** Order partially paid. During the checkout for orders with deposit items. */
    ORDER_PARTIALLY_PAID = "ORDER_PARTIALLY_PAID"
}
/** @enumType */
type ActivityTypeWithLiterals = ActivityType | 'UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE' | 'MERCHANT_COMMENT' | 'ORDER_PLACED' | 'ORDER_PAID' | 'ORDER_FULFILLED' | 'ORDER_NOT_FULFILLED' | 'DOWNLOAD_LINK_SENT' | 'PICKUP_READY_EMAIL_SENT' | 'TRACKING_NUMBER_ADDED' | 'TRACKING_NUMBER_EDITED' | 'TRACKING_LINK_WAS_SET' | 'SHIPPING_CONFIRMATION_EMAIL_SENT' | 'INVOICE_WAS_SET' | 'INVOICE_WAS_REMOVED' | 'INVOICE_WAS_SENT' | 'FULFILLER_EMAIL_SENT' | 'SHIPPING_ADDRESS_EDITED' | 'EMAIL_EDITED' | 'ORDER_PARTIALLY_PAID';
interface V2InvoiceInfo {
    /**
     * Invoice ID
     * @maxLength 100
     */
    _id?: string;
    /** Invoice source */
    source?: InvoiceSourceWithLiterals;
}
declare enum InvoiceSource {
    /** Invoice source can't be classified, due to an error */
    UNSPECIFIED_INVOICE_SOURCE = "UNSPECIFIED_INVOICE_SOURCE",
    /** Invoice created using the Invoices API */
    WIX = "WIX"
}
/** @enumType */
type InvoiceSourceWithLiterals = InvoiceSource | 'UNSPECIFIED_INVOICE_SOURCE' | 'WIX';
interface Fulfillment {
    /**
     * Fulfillment ID (auto generated upon fulfillment creation).
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Fulfillment creation date and time.
     * @readonly
     */
    dateCreated?: Date | null;
    /**
     * Information about the line items in the fulfilled order.
     * @minSize 1
     * @maxSize 300
     */
    lineItems?: FulfillmentLineItem[];
    /** Tracking information. */
    trackingInfo?: FulfillmentTrackingInfo;
}
interface FulfillmentLineItem {
    /**
     * Line item ID (mirrors the line item index of the order).
     * @min 1
     * @max 200
     */
    index?: number;
    /**
     * Line item quantity.
     * On creation, if this parameter isn't passed, the new fulfillment will automatically include all items of this line item that have not already been linked to a fulfillment.
     * If the order does not have the requested quantity of line items available to add to this fulfillment, the fulfillment will not be created and an error will be returned.
     * This property will always have a value when returned.
     * @min 1
     * @max 100000
     */
    quantity?: number | null;
}
interface FulfillmentTrackingInfo {
    /**
     * Tracking number.
     * @minLength 1
     * @maxLength 100
     */
    trackingNumber?: string;
    /**
     * Shipping provider. Using the following shipping providers will allow for autofilling the tracking link:
     * * `fedex`
     * * `ups`
     * * `usps`
     * * `dhl`
     * * `canadaPost`
     * @minLength 1
     * @maxLength 100
     */
    shippingProvider?: string;
    /**
     * Tracking link - autofilled if using a predefined shipping provider, otherwise provided on creation.
     * @minLength 1
     * @maxLength 2048
     * @format WEB_URL
     */
    trackingLink?: string | null;
}
interface Discount {
    /**
     * Deprecated (use Totals.discount instead)
     * @readonly
     * @deprecated
     */
    value?: string;
    /** Applied coupon */
    appliedCoupon?: AppliedCoupon;
}
interface AppliedCoupon {
    /**
     * Coupon ID
     * @minLength 1
     * @maxLength 100
     */
    couponId?: string;
    /**
     * Coupon name
     * @maxLength 100
     */
    name?: string;
    /**
     * Coupon code
     * @maxLength 100
     */
    code?: string;
}
/** Custom field */
interface CustomField {
    /**
     * Free text that the customer entered in the custom field during the checkout process
     * @maxLength 2000
     */
    value?: string;
    /**
     * Title for the custom field
     * @maxLength 1000
     */
    title?: string;
    /**
     * The title translated according to the buyer language
     * @maxLength 1000
     */
    translatedTitle?: string;
}
interface ChannelInfo {
    /** Sales channel that submitted the order */
    type?: ChannelTypeWithLiterals;
    /**
     * Reference to an order ID from an external system, as defined in channelInfo (e.g., eBay or Amazon)
     * @maxLength 100
     */
    externalOrderId?: string | null;
    /**
     * URL to the order in the external system, as defined in channelInfo (e.g., eBay or Amazon)
     * @maxLength 300
     */
    externalOrderUrl?: string | null;
}
declare enum ChannelType {
    UNSPECIFIED = "UNSPECIFIED",
    WEB = "WEB",
    POS = "POS",
    EBAY = "EBAY",
    AMAZON = "AMAZON",
    OTHER_PLATFORM = "OTHER_PLATFORM",
    WIX_APP_STORE = "WIX_APP_STORE",
    WIX_INVOICES = "WIX_INVOICES",
    BACKOFFICE_MERCHANT = "BACKOFFICE_MERCHANT",
    WISH = "WISH",
    CLASS_PASS = "CLASS_PASS",
    GLOBAL_E = "GLOBAL_E",
    FACEBOOK = "FACEBOOK",
    ETSY = "ETSY",
    TIKTOK = "TIKTOK",
    FAIRE_COM = "FAIRE_COM",
    PAYPAL_AGENTIC_CHECKOUT = "PAYPAL_AGENTIC_CHECKOUT"
}
/** @enumType */
type ChannelTypeWithLiterals = ChannelType | 'UNSPECIFIED' | 'WEB' | 'POS' | 'EBAY' | 'AMAZON' | 'OTHER_PLATFORM' | 'WIX_APP_STORE' | 'WIX_INVOICES' | 'BACKOFFICE_MERCHANT' | 'WISH' | 'CLASS_PASS' | 'GLOBAL_E' | 'FACEBOOK' | 'ETSY' | 'TIKTOK' | 'FAIRE_COM' | 'PAYPAL_AGENTIC_CHECKOUT';
interface EnteredBy {
    /** @format GUID */
    _id?: string;
    identityType?: EnteredByIdentityTypeWithLiterals;
}
declare enum EnteredByIdentityType {
    USER = "USER",
    MEMBER = "MEMBER",
    CONTACT = "CONTACT",
    APP = "APP"
}
/** @enumType */
type EnteredByIdentityTypeWithLiterals = EnteredByIdentityType | 'USER' | 'MEMBER' | 'CONTACT' | 'APP';
interface SubscriptionInfo {
    /**
     * Subscription ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Current cycle number. For example, if the subscription is in the 3rd month of a 4-month subscription, the value will be `3`.
     * @min 1
     */
    cycleNumber?: number;
    /** Subscription settings. */
    subscriptionSettings?: SubscriptionSettings;
    /** Subscription options info. */
    subscriptionOptionInfo?: SubscriptionOptionInfo;
}
interface SubscriptionSettings {
    /** Frequency of recurring payment. */
    frequency?: SubscriptionFrequencyWithLiterals;
    /** Whether subscription is renewed automatically at the end of each period. */
    autoRenewal?: boolean;
    /**
     * Number of billing cycles before subscription ends. Ignored if `autoRenewal: true`.
     * @min 2
     * @max 999
     */
    billingCycles?: number | null;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
/** @enumType */
type SubscriptionFrequencyWithLiterals = SubscriptionFrequency | 'UNDEFINED' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
interface SubscriptionOptionInfo {
    /**
     * Subscription option title.
     * @minLength 1
     * @maxLength 150
     */
    title?: string;
    /**
     * Subscription option description.
     * @maxLength 500
     */
    description?: string | null;
}
interface V2Refund {
    /** Refund created timestamp. */
    dateCreated?: Date | null;
    /**
     * Refund amount.
     * @format DECIMAL_VALUE
     */
    amount?: string;
    /** Reason for refund, given by user (optional). */
    reason?: string | null;
    /** Payment provider transaction ID. Used to find refund transaction info on the payment provider's side. */
    paymentProviderTransactionId?: string | null;
    /**
     * Refund ID.
     * @format GUID
     */
    _id?: string;
    /** Whether refund was made externally (on the payment provider's side). */
    externalRefund?: boolean;
}
interface GiftCard {
    /**
     * @minLength 1
     * @maxLength 100
     */
    transactionId?: string;
    /**
     * giftcard internal ID
     * @maxLength 36
     * @deprecated giftcard internal ID
     * @targetRemovalDate 2024-12-31
     */
    _id?: string;
    /**
     * giftcard provider appid
     * @format GUID
     */
    providerId?: string;
    /**
     * giftcard amount
     * @format DECIMAL_VALUE
     */
    amount?: string;
}
/** Triggered when a payment is updated. */
interface PaymentsUpdated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /**
     * List of IDs of the updated payments.
     * @maxSize 100
     */
    paymentIds?: string[];
    /**
     * List of IDs of the updated refunds.
     * @maxSize 300
     */
    refundIds?: string[];
}
/** Triggered when a payment is updated. */
interface PaymentDetailsUpdated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /**
     * List of IDs of the updated payments.
     * @format GUID
     * @maxSize 100
     */
    paymentIds?: string[];
    /**
     * List of IDs of the updated refunds.
     * @format GUID
     * @maxSize 300
     */
    refundIds?: string[];
}
/** Triggered when a refund is created. */
interface RefundCreated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** ID of the created refund. */
    refundId?: string;
    /** Inventory restock details as part of this refund.. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /** Custom message added to the refund confirmation email. */
    customMessage?: string | null;
    /** Refunded line items and quantities that are part of the created refund. */
    refundItems?: RefundItem[];
}
interface RestockInfo {
    /** Restock type. */
    type?: RestockTypeWithLiterals;
    /**
     * Restocked line items and quantities. Only relevant for `{"type": "SOME_ITEMS"}`.
     * @maxSize 300
     */
    items?: RestockItem[];
}
declare enum RestockType {
    NO_ITEMS = "NO_ITEMS",
    ALL_ITEMS = "ALL_ITEMS",
    SOME_ITEMS = "SOME_ITEMS"
}
/** @enumType */
type RestockTypeWithLiterals = RestockType | 'NO_ITEMS' | 'ALL_ITEMS' | 'SOME_ITEMS';
interface RestockItem {
    /**
     * ID of the line item being restocked.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity being restocked.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface RefundCompleted {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /** Completed refund. */
    refund?: Refund;
    /** Refund side effects. */
    sideEffects?: RefundSideEffects;
    /** Order transactions after refund is completed. */
    orderTransactions?: OrderTransactions;
}
interface RefundSideEffects {
    /** Inventory restock details as part of this refund. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /**
     * Custom message added to the refund confirmation email.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface ChargebackApproved {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Approved chargeback. */
    chargeback?: Chargeback;
    /** Order transactions after chargeback is approved. */
    orderTransactions?: OrderTransactions;
}
interface ChargebackReversed {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Reversed chargeback. */
    chargeback?: Chargeback;
    /** Order transactions after chargeback is reversed. */
    orderTransactions?: OrderTransactions;
}
interface ListTransactionsForSingleOrderRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId: string;
}
interface ListTransactionsForSingleOrderResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
}
interface ListTransactionsForMultipleOrdersRequest {
    /**
     * Order IDs for which to retrieve transactions.
     * @minSize 1
     * @maxSize 100
     * @minLength 1
     * @maxLength 100
     */
    orderIds: string[];
}
interface ListTransactionsForMultipleOrdersResponse {
    /** List of order IDs and their associated transactions. */
    orderTransactions?: OrderTransactions[];
}
interface AddPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payments to be added to order.
     * @minSize 1
     * @maxSize 50
     */
    payments: Payment[];
}
interface AddPaymentsResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** IDs of added order payments. */
    paymentsIds?: string[];
}
interface AddRefundRequest {
    /**
     * Order ID this refunds related to
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /** Refund with refund transactions to be added to order. */
    refund?: Refund;
    /** Side effect details related to refund */
    sideEffects?: RefundSideEffects;
}
interface AddRefundResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
interface UpdatePaymentStatusRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId: string;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
interface UpdatePaymentStatusResponse {
    /** Order ID and its associated transactions after update. */
    orderTransactions?: OrderTransactions;
}
interface BulkUpdatePaymentStatusesRequest {
    /**
     * Order and payment IDs for which to update payment status.
     * @minSize 1
     * @maxSize 300
     */
    paymentAndOrderIds: PaymentAndOrderId[];
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
interface PaymentAndOrderId {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * todo: remove comment once UI will use BulkMarkOrderAsPaid
     */
    paymentId?: string;
}
interface BulkUpdatePaymentStatusesResponse {
    /** Bulk operation results. */
    results?: BulkPaymentResult[];
    /** Bulk operation metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkPaymentResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Updated payment. Returned if `return_full_entity` set to `true`. */
    item?: Payment;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateRefundRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /** Refund with updated field values. */
    refund?: Refund;
}
interface UpdateRefundResponse {
    /** Refund after update. */
    refund?: Refund;
    /** Order transactions after update. */
    orderTransactions?: OrderTransactions;
}
interface UpdateRefundTransactionRequest {
}
interface UpdateRefundTransactionResponse {
}
interface UpdatePaymentsRequest {
}
interface MaskedPayment {
}
interface UpdatePaymentsResponse {
}
interface QueryOrderTransactionsRequest {
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 5
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    /** Ascending order. */
    ASC = "ASC",
    /** Descending order. */
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryOrderTransactionsResponse {
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface AddChargebackRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Chargeback. */
    chargeback?: Chargeback;
}
interface AddChargebackResponse {
    /** Chargeback. */
    chargeback?: Chargeback;
    /**
     * Payment ID of a payment which received chargeback.
     * @format GUID
     */
    paymentId?: string;
    /** Order transactions. */
    orderTransactions?: OrderTransactions;
}
interface ReverseChargebackRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Chargeback ID.
     * @format GUID
     */
    chargebackId?: string;
    /**
     * Reversal amount.
     *
     * Default: original chargeback amount.
     */
    reversalAmount?: Price;
}
interface ReverseChargebackResponse {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
}
interface TriggerRefundRequest {
    /**
     * The order this refund related to
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /**
     * Refund operations information
     * Currently, only *one* payment refund is supported per request
     * @minSize 1
     * @maxSize 1
     */
    payments?: PaymentRefund[];
    /** Business model of a refund */
    details?: RefundDetails;
    /** How to restock items as part of this refund */
    restockInfo?: RestockInfo;
    /** Should send a confirmation mail to the customer */
    sendOrderRefundedEmail?: boolean;
    /**
     * Personal note added to the email
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface PaymentRefund {
    /**
     * Specific payment within the order to refund
     * @format GUID
     */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Whether refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
interface TriggerRefundResponse {
    /** All order's transactions after the refunds were added */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
interface CalculateRefundRequest {
    /**
     * Order ID
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /**
     * Refunded line items and quantity
     * @maxSize 300
     */
    refundItems?: CalculateRefundItemRequest[];
    /** Should include shipping in refund calculation */
    refundShipping?: boolean;
}
interface CalculateRefundItemRequest {
    /**
     * ID of the line item being refunded
     * @format GUID
     */
    lineItemId?: string;
    /**
     * How much of that line item is being refunded
     * @min 1
     * @max 100000
     */
    quantity?: number;
    /** Should this item be restocked (used for validation purposes) */
    restock?: boolean;
}
interface CalculateRefundResponse {
    /**
     * Total refundable amount
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Tax cost of the order
     * @format DECIMAL_VALUE
     */
    tax?: string;
    /**
     * Discount given for this order
     * @format DECIMAL_VALUE
     */
    discount?: string;
    /**
     * Total cost of the order (without tax)
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /**
     * Previous refund given on that order
     * @format DECIMAL_VALUE
     */
    previouslyRefundedAmount?: string | null;
    /** The refundable items of that order */
    items?: CalculateRefundItemResponse[];
}
interface CalculateRefundItemResponse {
    /** Line item ID */
    lineItemId?: string;
    /** The line item's price */
    lineItemPrice?: number;
}
interface GetRefundabilityStatusRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
}
interface GetRefundabilityStatusResponse {
    /**
     * Refundability details.
     * @maxSize 1
     */
    refundabilities?: Refundability[];
    /** Whether the order supports refunding per item. */
    refundablePerItem?: boolean;
}
interface Refundability extends RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReasonWithLiterals;
    /** Payment ID. */
    paymentId?: string;
    /** Payment refundability status. */
    refundabilityStatus?: RefundableStatusWithLiterals;
    /** Link to payment provider dashboard. */
    providerLink?: string | null;
}
/** @oneof */
interface RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReasonWithLiterals;
}
declare enum RefundableStatus {
    /** Not refundable. */
    NOT_REFUNDABLE = "NOT_REFUNDABLE",
    /** Refundable manually. */
    MANUAL = "MANUAL",
    /** Refundable. */
    REFUNDABLE = "REFUNDABLE"
}
/** @enumType */
type RefundableStatusWithLiterals = RefundableStatus | 'NOT_REFUNDABLE' | 'MANUAL' | 'REFUNDABLE';
declare enum NonRefundableReason {
    /** No reason. */
    NONE = "NONE",
    /** Payment already refunded. */
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    /** Payment provider is down. */
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    /** Internal error occurred. */
    INTERNAL_ERROR = "INTERNAL_ERROR",
    /** Payment not made. */
    NOT_PAID = "NOT_PAID",
    /** Access denied. */
    ACCESS_DENIED = "ACCESS_DENIED",
    /** Payment amount is zero. */
    ZERO_PRICE = "ZERO_PRICE",
    /** Disabled by provider. */
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    /** Payment partially paid. */
    PARTIALLY_PAID = "PARTIALLY_PAID",
    /** Deposit for online item. */
    DEPOSIT_ONLINE_ITEM = "DEPOSIT_ONLINE_ITEM",
    /** Refund is pending. */
    PENDING_REFUND = "PENDING_REFUND",
    /** Action forbidden. */
    FORBIDDEN = "FORBIDDEN"
}
/** @enumType */
type NonRefundableReasonWithLiterals = NonRefundableReason | 'NONE' | 'ALREADY_REFUNDED' | 'PROVIDER_IS_DOWN' | 'INTERNAL_ERROR' | 'NOT_PAID' | 'ACCESS_DENIED' | 'ZERO_PRICE' | 'DISABLED_BY_PROVIDER' | 'PARTIALLY_PAID' | 'DEPOSIT_ONLINE_ITEM' | 'PENDING_REFUND' | 'FORBIDDEN';
declare enum ManuallyRefundableReason {
    /** Payment expired. */
    EXPIRED = "EXPIRED",
    /** Payment method not supported. */
    NOT_SUPPORTED = "NOT_SUPPORTED",
    /** Payment not found. */
    NOT_FOUND = "NOT_FOUND",
    /** Payment made offline. */
    OFFLINE = "OFFLINE",
    /** Refund requires interaction with card reader. */
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
/** @enumType */
type ManuallyRefundableReasonWithLiterals = ManuallyRefundableReason | 'EXPIRED' | 'NOT_SUPPORTED' | 'NOT_FOUND' | 'OFFLINE' | 'REQUIRES_CARD_READER';
interface ListInvoicesForSingleOrderRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
}
interface ListInvoicesForSingleOrderResponse {
    /** List of invoices. */
    invoices?: InvoiceInfo[];
}
interface InvoiceInfo {
    /** Invoice ID. */
    _id?: string;
    /** ID of the app that set the invoice. */
    appId?: string;
    /**
     * Invoice URL.
     * @deprecated
     */
    url?: string | null;
    /**
     * Invoice creation date and time.
     * @deprecated
     */
    _createdDate?: Date | null;
}
interface ListInvoicesForMultipleOrdersRequest {
    /**
     * Order IDs for which to retrieve invoices.
     * @maxSize 300
     * @minLength 1
     * @maxLength 100
     */
    orderIds?: string[];
}
interface ListInvoicesForMultipleOrdersResponse {
    /** List of order IDs and their associated invoices. */
    invoicesForOrder?: InvoicesForOrder[];
}
interface InvoicesForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoices info. */
    invoicesInfo?: InvoiceInfo[];
}
interface GenerateInvoiceRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
}
interface GenerateInvoiceResponse {
    /** Invoice ID. */
    invoiceId?: string;
}
interface BulkGenerateInvoicesRequest {
    /**
     * Order IDs.
     * @minSize 1
     * @maxSize 100
     * @minLength 1
     * @maxLength 100
     */
    orderIds?: string[];
}
interface BulkGenerateInvoicesResponse {
    results?: BulkInvoiceResult[];
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInvoiceResult {
    itemMetadata?: ItemMetadata;
    item?: InvoiceForOrder;
}
interface InvoiceForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoice ID. */
    invoiceId?: string;
}
interface AddInvoiceToOrderRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /** Invoice info. */
    invoiceInfo?: InvoiceInfo;
}
interface AddInvoiceToOrderResponse {
    /** List of order invoices. */
    orderInvoices?: InvoiceInfo[];
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type UpdateRefundTransactionApplicationErrors = {
    code?: 'ORDER_TRANSACTIONS_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'REFUND_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'REFUND_TRANSACTION_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type UpdatePaymentsApplicationErrors = {
    code?: 'ORDER_TRANSACTIONS_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface OrderTransactionsDetailsUpdatedEnvelope {
    data: PaymentDetailsUpdated;
    metadata: EventMetadata;
}
/**
 * Triggered when a payment or refund is added to an order, or when an existing payment is updated.
 *
 * Contains the ID of the updated order and details of its associated transactions,
 * as well as IDs of the updated payments and refunds.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_details_updated
 * @slug details_updated
 */
declare function onOrderTransactionsDetailsUpdated(handler: (event: OrderTransactionsDetailsUpdatedEnvelope) => void | Promise<void>): void;
interface OrderTransactionsRefundCompletedEnvelope {
    data: RefundCompleted;
    metadata: EventMetadata;
}
/**
 * Triggered when a refund has been fully processed and completed.
 *
 * This event is fired once when all refund transactions within a refund have reached
 * their final state (either `SUCCEEDED` or `FAILED`). Contains the order ID, completed
 * refund details, any side effects (such as inventory restocking or email notifications),
 * and the updated order transaction state.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_refund_completed
 * @slug refund_completed
 */
declare function onOrderTransactionsRefundCompleted(handler: (event: OrderTransactionsRefundCompletedEnvelope) => void | Promise<void>): void;
interface OrderTransactionsUpdatedEnvelope {
    data: PaymentsUpdated;
    metadata: EventMetadata;
}
/**
 * Triggered when a payment or refund is added to an order, or when an existing payment is updated.
 *
 * Contains the ID of the updated order and details of its associated transactions,
 * as well as IDs of the updated payments and refunds.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_updated
 * @slug updated
 * @deprecated
 * @replacedBy com.wix.ecom.orders.payments.v1.Payments.details_updated
 * @targetRemovalDate 2025-11-30
 */
declare function onOrderTransactionsUpdated(handler: (event: OrderTransactionsUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves information about payments and refunds associated with a specified order.
 *
 *
 * The `listTransactionsForSingleOrder()` function returns a Promise that resolves when the specified order's transaction records are retrieved.
 * @param orderId - Order ID.
 * @public
 * @requiredField orderId
 * @permissionId ECOM.READ_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.ListTransactionsForSingleOrder
 */
declare function listTransactionsForSingleOrder(orderId: string): Promise<NonNullablePaths<ListTransactionsForSingleOrderResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7>>;
/**
 * Retrieves information about payments and refunds associated with all specified orders.
 *
 *
 * The `listTransactionsForMultipleOrders()` function returns a Promise that resolves when the specified orders' transaction records are retrieved.
 * @param orderIds - Order IDs for which to retrieve transactions.
 * @public
 * @requiredField orderIds
 * @permissionId ECOM.READ_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.ListTransactionsForMultipleOrders
 */
declare function listTransactionsForMultipleOrders(orderIds: string[]): Promise<NonNullablePaths<ListTransactionsForMultipleOrdersResponse, `orderTransactions` | `orderTransactions.${number}.orderId`, 4>>;
/**
 * Adds up to 50 payment records to an order.
 *
 *
 * The `addPayments()` function returns a Promise that resolves when the payment records are added to an order.
 *
 * > **Note:** This does **NOT** perform the actual charging - the order is only updated with records of the payments.
 * @param orderId - Order ID.
 * @param payments - Payments to be added to order.
 * @public
 * @requiredField orderId
 * @requiredField payments
 * @requiredField payments.amount
 * @requiredField payments.paymentDetails
 * @requiredField payments.paymentDetails.giftcardPaymentDetails.giftCardPaymentId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.AddPayments
 */
declare function addPayments(orderId: string, payments: NonNullablePaths<Payment, `amount` | `giftcardPaymentDetails.giftCardPaymentId`, 3>[]): Promise<NonNullablePaths<AddPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending` | `paymentsIds`, 7>>;
/**
 * Updates the status of an order's payment.
 *
 *
 * The `updatePaymentStatus()` function returns a Promise that resolves when the payment status is updated.
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.orderId
 * @requiredField identifiers.paymentId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.UpdatePaymentStatus
 */
declare function updatePaymentStatus(identifiers: NonNullablePaths<UpdatePaymentStatusIdentifiers, `orderId` | `paymentId`, 2>, options?: UpdatePaymentStatusOptions): Promise<NonNullablePaths<UpdatePaymentStatusResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7>>;
interface UpdatePaymentStatusIdentifiers {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId: string;
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
interface UpdatePaymentStatusOptions {
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
/**
 * Updates multiple order payments with a specified status.
 *
 *
 * The `bulkUpdatePaymentStatus()` function returns a Promise that resolves when the payment statuses are updated.
 * @param paymentAndOrderIds - Order and payment IDs for which to update payment status.
 * @public
 * @requiredField paymentAndOrderIds
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.BulkUpdatePaymentStatuses
 */
declare function bulkUpdatePaymentStatuses(paymentAndOrderIds: PaymentAndOrderId[], options?: BulkUpdatePaymentStatusesOptions): Promise<NonNullablePaths<BulkUpdatePaymentStatusesResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.regularPaymentDetails.offlinePayment` | `results.${number}.item.regularPaymentDetails.status` | `results.${number}.item.regularPaymentDetails.savedPaymentMethod` | `results.${number}.item.giftcardPaymentDetails.giftCardPaymentId` | `results.${number}.item.giftcardPaymentDetails.appId` | `results.${number}.item.giftcardPaymentDetails.voided` | `results.${number}.item.amount.amount` | `results.${number}.item.amount.formattedAmount` | `results.${number}.item.refundDisabled` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdatePaymentStatusesOptions {
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}

export { type ActionEvent, ActionType, type ActionTypeWithLiterals, type Activity, ActivityType, type ActivityTypeWithLiterals, type AddChargebackRequest, type AddChargebackResponse, type AddInvoiceToOrderRequest, type AddInvoiceToOrderResponse, type AddPaymentsRequest, type AddPaymentsResponse, type AddRefundRequest, type AddRefundResponse, type AdditionalFeeRefund, type Address, type AddressAddressLine1OptionsOneOf, type AggregatedRefundSummary, type ApplicationError, type AppliedCoupon, type AuthorizationActionFailureDetails, type AuthorizationCapture, AuthorizationCaptureStatus, type AuthorizationCaptureStatusWithLiterals, type AuthorizationDetails, type AuthorizationVoid, AuthorizationVoidStatus, type AuthorizationVoidStatusWithLiterals, type BaseEventMetadata, type BillingInfo, type BulkActionMetadata, type BulkGenerateInvoicesRequest, type BulkGenerateInvoicesResponse, type BulkInvoiceResult, type BulkPaymentResult, type BulkUpdatePaymentStatusesOptions, type BulkUpdatePaymentStatusesRequest, type BulkUpdatePaymentStatusesResponse, type BuyerDetails, type BuyerInfo, type CalculateRefundItemRequest, type CalculateRefundItemResponse, type CalculateRefundRequest, type CalculateRefundResponse, type ChannelInfo, ChannelType, type ChannelTypeWithLiterals, type Chargeback, type ChargebackApproved, type ChargebackReversed, ChargebackStatus, type ChargebackStatusWithLiterals, type CreditCardPaymentMethodDetails, type CursorPaging, type CursorPagingMetadata, type CursorQuery, type CursorQueryPagingMethodOneOf, type Cursors, type CustomField, type CustomTextFieldSelection, type DiffmatokyPayload, type DigitalFile, type Discount, type DomainEvent, type DomainEventBodyOneOf, type EnteredBy, EnteredByIdentityType, type EnteredByIdentityTypeWithLiterals, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type ErrorInformation, type EventMetadata, type ExternalReceiptInfo, type Fulfillment, type FulfillmentLineItem, FulfillmentStatus, type FulfillmentStatusWithLiterals, type FulfillmentTrackingInfo, type FullName, type GenerateInvoiceRequest, type GenerateInvoiceResponse, type GetRefundabilityStatusRequest, type GetRefundabilityStatusResponse, type GiftCard, type GiftCardPaymentDetails, type IdentificationData, type IdentificationDataIdOneOf, IdentityType, type IdentityTypeWithLiterals, type IndexingMessage, type InvoiceForOrder, type InvoiceInfo, InvoiceSource, type InvoiceSourceWithLiterals, type InvoicesForOrder, type ItemMetadata, type LineItem, type LineItemPriceData, type LineItemRefund, type LineItemRefundSummary, LineItemType, type LineItemTypeWithLiterals, type ListInvoicesForMultipleOrdersRequest, type ListInvoicesForMultipleOrdersResponse, type ListInvoicesForSingleOrderRequest, type ListInvoicesForSingleOrderResponse, type ListTransactionsForMultipleOrdersRequest, type ListTransactionsForMultipleOrdersResponse, type ListTransactionsForSingleOrderRequest, type ListTransactionsForSingleOrderResponse, ManuallyRefundableReason, type ManuallyRefundableReasonWithLiterals, type MaskedPayment, type MediaItem, MediaItemType, type MediaItemTypeWithLiterals, type MembershipName, type MembershipPaymentDetails, MembershipPaymentStatus, type MembershipPaymentStatusWithLiterals, type MessageEnvelope, NonRefundableReason, type NonRefundableReasonWithLiterals, type OptionSelection, type Order, type OrderRefunded, type OrderTransactions, type OrderTransactionsDetailsUpdatedEnvelope, type OrderTransactionsRefundCompletedEnvelope, type OrderTransactionsUpdatedEnvelope, type Payment, type PaymentAndOrderId, type PaymentDetailsUpdated, type PaymentPaymentDetailsOneOf, type PaymentReceiptInfoOneOf, type PaymentRefund, PaymentStatus, type PaymentStatusWithLiterals, type PaymentsUpdated, type PickupAddress, type PickupDetails, type Price, type QueryOrderTransactionsRequest, type QueryOrderTransactionsResponse, Reason, type ReasonWithLiterals, type Refund, type RefundCompleted, type RefundCreated, type RefundDetails, type RefundItem, type RefundItemsBreakdown, type RefundSideEffects, RefundStatus, type RefundStatusInfo, type RefundStatusWithLiterals, type RefundTransaction, type Refundability, type RefundabilityAdditionalRefundabilityInfoOneOf, RefundableStatus, type RefundableStatusWithLiterals, type RegularPaymentDetails, type RegularPaymentDetailsPaymentMethodDetailsOneOf, type RestockInfo, type RestockItem, RestockType, type RestockTypeWithLiterals, type RestoreInfo, type ReverseChargebackRequest, type ReverseChargebackResponse, type ScheduledAction, type ShipmentDetails, type ShippingInfo, type ShippingInfoDetailsOneOf, type ShippingPriceData, type ShippingRefund, type SnapshotMessage, SortOrder, type SortOrderWithLiterals, type Sorting, type Street, SubscriptionFrequency, type SubscriptionFrequencyWithLiterals, type SubscriptionInfo, type SubscriptionOptionInfo, type SubscriptionSettings, type Totals, type TrackingInfo, TransactionStatus, type TransactionStatusWithLiterals, type TriggerRefundRequest, type TriggerRefundResponse, type UpdatePaymentStatusIdentifiers, type UpdatePaymentStatusOptions, type UpdatePaymentStatusRequest, type UpdatePaymentStatusResponse, type UpdatePaymentsApplicationErrors, type UpdatePaymentsRequest, type UpdatePaymentsResponse, type UpdateRefundRequest, type UpdateRefundResponse, type UpdateRefundTransactionApplicationErrors, type UpdateRefundTransactionRequest, type UpdateRefundTransactionResponse, type V2InvoiceInfo, type V2Refund, type VatId, VatType, type VatTypeWithLiterals, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, WeightUnit, type WeightUnitWithLiterals, type WixReceiptInfo, addPayments, bulkUpdatePaymentStatuses, listTransactionsForMultipleOrders, listTransactionsForSingleOrder, onOrderTransactionsDetailsUpdated, onOrderTransactionsRefundCompleted, onOrderTransactionsUpdated, updatePaymentStatus };
