import { HttpClient, NonNullablePaths, EventDefinition, MaybeContext, BuildRESTFunction, BuildEventDefinition } from '@wix/sdk-types';
import { I as InventoryItem, C as CreateInventoryItemApplicationErrors, a as CreateInventoryItemValidationErrors, B as BulkCreateInventoryItemsOptions, b as BulkCreateInventoryItemsResponse, c as BulkCreateInventoryItemsApplicationErrors, d as BulkCreateInventoryItemsValidationErrors, U as UpdateInventoryItem, e as UpdateInventoryItemOptions, f as UpdateInventoryItemApplicationErrors, M as MaskedInventoryItem, g as BulkUpdateInventoryItemsOptions, h as BulkUpdateInventoryItemsResponse, i as BulkUpdateInventoryItemsApplicationErrors, j as BulkUpdateInventoryItemsByFilterOptions, k as BulkUpdateInventoryItemsByFilterResponse, l as BulkUpdateInventoryItemsByFilterApplicationErrors, m as BulkDeleteInventoryItemsResponse, n as InventoryItemsQueryBuilder, o as InventoryItemSearch, S as SearchInventoryItemsResponse, D as DecrementDataById, p as BulkDecrementInventoryItemsOptions, q as BulkDecrementInventoryItemsResponse, r as BulkDecrementInventoryItemsApplicationErrors, s as IncrementDataById, t as BulkIncrementInventoryItemsOptions, u as BulkIncrementInventoryItemsResponse, v as BulkIncrementInventoryItemsApplicationErrors, w as DecrementDataByVariantAndLocation, x as BulkDecrementInventoryItemsByVariantAndLocationOptions, y as BulkDecrementInventoryItemsByVariantAndLocationResponse, z as BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors, A as IncrementDataByVariantAndLocation, E as BulkIncrementInventoryItemsByVariantAndLocationOptions, F as BulkIncrementInventoryItemsByVariantAndLocationResponse, G as BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors, H as BulkSetOrAdjustInventoryItemsByFilterOptions, J as BulkSetOrAdjustInventoryItemsByFilterResponse, K as BulkSetOrAdjustInventoryItemsByFilterApplicationErrors, L as InventoryItemCreatedEnvelope, N as InventoryItemDeletedEnvelope, O as InventoryItemStockStatusUpdatedEnvelope, P as InventoryItemUpdatedEnvelope, Q as InventoryItemUpdatedWithReasonEnvelope } from './stores-catalog-v3-inventory-item-inventory-items-v-3.universal-Dduc6wNZ.mjs';
export { bA as ActionEvent, bD as AdjustInventoryAction, bE as AdjustInventoryActionActionOneOf, aM as Aggregation, b0 as AggregationData, aN as AggregationKindOneOf, bj as AggregationResults, bk as AggregationResultsResultOneOf, b7 as AggregationResultsScalarResult, a2 as AggregationType, bX as AggregationTypeWithLiterals, aa as App, al as ApplicationError, R as AvailabilityStatus, bM as AvailabilityStatusWithLiterals, bI as BaseEventMetadata, am as BulkActionMetadata, ai as BulkCreateInventoryItemsRequest, bs as BulkDecrementInventoryItemsByVariantAndLocationRequest, bq as BulkDecrementInventoryItemsRequest, ay as BulkDeleteInventoryItemsRequest, bt as BulkIncrementInventoryItemsByVariantAndLocationRequest, br as BulkIncrementInventoryItemsRequest, af as BulkInventoryItemAction, az as BulkInventoryItemResult, bC as BulkSetOrAdjustInventoryItemsByFilterRequest, au as BulkUpdateInventoryItemsByFilterRequest, at as BulkUpdateInventoryItemsRequest, aI as CommonCursors, bZ as CommonSearchWithEntityContext, ag as CreateInventoryItemRequest, ah as CreateInventoryItemResponse, aF as CursorPaging, a_ as CursorPagingMetadata, aK as CursorSearch, aL as CursorSearchPagingMethodOneOf, a$ as Cursors, ae as CustomTag, aU as DateHistogramAggregation, bf as DateHistogramResult, bh as DateHistogramResults, aw as DeleteInventoryItemRequest, ax as DeleteInventoryItemResponse, bu as DomainEvent, bv as DomainEventBodyOneOf, bB as Empty, bw as EntityCreatedEvent, bz as EntityDeletedEvent, by as EntityUpdatedEvent, bJ as EventMetadata, T as EventType, bN as EventTypeWithLiterals, a7 as ExtendedFields, ad as File, an as GetInventoryItemRequest, ao as GetInventoryItemResponse, aY as GroupByAggregation, aZ as GroupByAggregationKindOneOf, bg as GroupByValueResults, bG as IdentificationData, bH as IdentificationDataIdOneOf, aP as IncludeMissingValuesOptions, a1 as Interval, bW as IntervalWithLiterals, a8 as InvalidateCache, a9 as InvalidateCacheGetByOneOf, bL as InventoryItemSearchSpec, ar as InventoryItemStockStatusUpdatedEvent, a4 as InventoryItemTrackingMethodOneOf, as as InventoryItemUpdatedWithReason, bK as InventoryItemsQueryResult, ak as ItemMetadata, bF as MessageEnvelope, _ as MissingValues, bT as MissingValuesWithLiterals, W as Mode, bP as ModeWithLiterals, aX as NestedAggregation, aV as NestedAggregationItem, aW as NestedAggregationItemKindOneOf, b3 as NestedAggregationResults, b4 as NestedAggregationResultsResultOneOf, a0 as NestedAggregationType, bV as NestedAggregationTypeWithLiterals, bc as NestedResultValue, bd as NestedResultValueResultOneOf, bi as NestedResults, b8 as NestedValueAggregationResult, bm as OffsetSearch, bn as OffsetSearchPagingMethodOneOf, ab as Page, aE as Paging, bp as PagingMetadata, aH as PlatformPagingMetadataV2, a5 as PreorderInfo, a6 as Product, aA as QueryInventoryItemsRequest, aG as QueryInventoryItemsResponse, aB as QueryV2, aC as QueryV2PagingMethodOneOf, aS as RangeAggregation, b2 as RangeAggregationResult, aO as RangeBucket, ba as RangeResult, b6 as RangeResults, V as ReasonType, bO as ReasonTypeWithLiterals, bx as RestoreInfo, be as Results, aT as ScalarAggregation, bb as ScalarResult, $ as ScalarType, bU as ScalarTypeWithLiterals, av as SearchDetails, aJ as SearchInventoryItemsRequest, bl as SearchInventoryItemsWithOffsetRequest, bo as SearchInventoryItemsWithOffsetResponse, Z as SortDirection, bS as SortDirectionWithLiterals, X as SortOrder, bQ as SortOrderWithLiterals, Y as SortType, bR as SortTypeWithLiterals, aD as Sorting, ac as URI, ap as UpdateInventoryItemRequest, aq as UpdateInventoryItemResponse, aj as V3BulkInventoryItemResult, aQ as ValueAggregation, aR as ValueAggregationOptionsOneOf, b1 as ValueAggregationResult, b9 as ValueResult, b5 as ValueResults, a3 as WebhookIdentityType, bY as WebhookIdentityTypeWithLiterals } from './stores-catalog-v3-inventory-item-inventory-items-v-3.universal-Dduc6wNZ.mjs';

declare function createInventoryItem$1(httpClient: HttpClient): CreateInventoryItemSignature;
interface CreateInventoryItemSignature {
    /**
     * Creates an inventory item.
     * The combination of `variantId` and `locationId` is unique.
     * @param - Inventory item to create.
     * @returns Created inventory item.
     */
    (inventoryItem: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
        __applicationErrorsType?: CreateInventoryItemApplicationErrors;
        __validationErrorsType?: CreateInventoryItemValidationErrors;
    }>;
}
declare function bulkCreateInventoryItems$1(httpClient: HttpClient): BulkCreateInventoryItemsSignature;
interface BulkCreateInventoryItemsSignature {
    /**
     * Creates multiple inventory items.
     * @param - Inventory items to create.
     */
    (inventoryItems: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>[], options?: BulkCreateInventoryItemsOptions): Promise<NonNullablePaths<BulkCreateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkCreateInventoryItemsApplicationErrors;
        __validationErrorsType?: BulkCreateInventoryItemsValidationErrors;
    }>;
}
declare function getInventoryItem$1(httpClient: HttpClient): GetInventoryItemSignature;
interface GetInventoryItemSignature {
    /**
     * Retrieves an inventory item.
     * @param - Inventory item ID.
     * @returns Inventory item.
     */
    (inventoryItemId: string): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3>>;
}
declare function updateInventoryItem$1(httpClient: HttpClient): UpdateInventoryItemSignature;
interface UpdateInventoryItemSignature {
    /**
     * Updates an inventory item.
     *
     *
     * Each time the inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating the inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory item ID.
     * @returns Updated inventory item.
     */
    (_id: string, inventoryItem: NonNullablePaths<UpdateInventoryItem, `revision`, 2>, options?: UpdateInventoryItemOptions): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
        __applicationErrorsType?: UpdateInventoryItemApplicationErrors;
    }>;
}
declare function bulkUpdateInventoryItems$1(httpClient: HttpClient): BulkUpdateInventoryItemsSignature;
interface BulkUpdateInventoryItemsSignature {
    /**
     * Updates multiple inventory items.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory items to update.
     */
    (inventoryItems: NonNullablePaths<MaskedInventoryItem, `inventoryItem._id` | `inventoryItem.revision`, 3>[], options?: BulkUpdateInventoryItemsOptions): Promise<NonNullablePaths<BulkUpdateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkUpdateInventoryItemsApplicationErrors;
    }>;
}
declare function bulkUpdateInventoryItemsByFilter$1(httpClient: HttpClient): BulkUpdateInventoryItemsByFilterSignature;
interface BulkUpdateInventoryItemsByFilterSignature {
    /**
     * Updates multiple inventory items, given the provided filter.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Filter object.
     */
    (filter: Record<string, any>, options?: NonNullablePaths<BulkUpdateInventoryItemsByFilterOptions, `inventoryItem`, 2>): Promise<NonNullablePaths<BulkUpdateInventoryItemsByFilterResponse, `jobId`, 2> & {
        __applicationErrorsType?: BulkUpdateInventoryItemsByFilterApplicationErrors;
    }>;
}
declare function deleteInventoryItem$1(httpClient: HttpClient): DeleteInventoryItemSignature;
interface DeleteInventoryItemSignature {
    /**
     * Deletes an inventory item.
     * @param - Inventory item ID.
     */
    (inventoryItemId: string): Promise<void>;
}
declare function bulkDeleteInventoryItems$1(httpClient: HttpClient): BulkDeleteInventoryItemsSignature;
interface BulkDeleteInventoryItemsSignature {
    /**
     * Deletes multiple inventory items.
     * @param - IDs of inventory items to delete.
     */
    (inventoryItemIds: string[]): Promise<NonNullablePaths<BulkDeleteInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
}
declare function queryInventoryItems$1(httpClient: HttpClient): QueryInventoryItemsSignature;
interface QueryInventoryItemsSignature {
    /**
     * Retrieves a list of up to 1,000 inventory items, given the provided filtering, sorting, and cursor paging.
     *
     * For field support for filters and sorting,
     * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Query_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    (): InventoryItemsQueryBuilder;
}
declare function searchInventoryItems$1(httpClient: HttpClient): SearchInventoryItemsSignature;
interface SearchInventoryItemsSignature {
    /**
     * Retrieves a list of inventory items, given the provided filtering, sorting, and cursor paging.
     *
     *
     * Search Inventory Items runs with these defaults, which you can override:
     *
     * - `createdDate` is sorted in `DESC` order
     * - `cursorPaging.limit` is `100`
     *
     * For field support for filters and sorting,
     * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Search_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     * @param - Search options.
     */
    (search: InventoryItemSearch): Promise<NonNullablePaths<SearchInventoryItemsResponse, `inventoryItems` | `inventoryItems.${number}.inStock` | `inventoryItems.${number}.quantity` | `inventoryItems.${number}.variantId` | `inventoryItems.${number}.productId` | `inventoryItems.${number}.trackQuantity` | `inventoryItems.${number}.availabilityStatus` | `aggregationData.results` | `aggregationData.results.${number}.scalar.type` | `aggregationData.results.${number}.scalar.value` | `aggregationData.results.${number}.name` | `aggregationData.results.${number}.type` | `aggregationData.results.${number}.fieldPath`, 6>>;
}
declare function bulkDecrementInventoryItems$1(httpClient: HttpClient): BulkDecrementInventoryItemsSignature;
interface BulkDecrementInventoryItemsSignature {
    /**
     * Decrements quantities of multiple inventory items.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Inventory item IDs and decrement data.
     */
    (decrementData: NonNullablePaths<DecrementDataById, `decrementBy` | `inventoryItemId`, 2>[], options?: BulkDecrementInventoryItemsOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkDecrementInventoryItemsApplicationErrors;
    }>;
}
declare function bulkIncrementInventoryItems$1(httpClient: HttpClient): BulkIncrementInventoryItemsSignature;
interface BulkIncrementInventoryItemsSignature {
    /**
     * Increments quantities of multiple inventory items.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Inventory item IDs and increment data.
     */
    (incrementData: NonNullablePaths<IncrementDataById, `incrementBy` | `inventoryItemId`, 2>[], options?: BulkIncrementInventoryItemsOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkIncrementInventoryItemsApplicationErrors;
    }>;
}
declare function bulkDecrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkDecrementInventoryItemsByVariantAndLocationSignature;
interface BulkDecrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Decrements quantities of multiple inventory items by variant and location.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Variant and location IDs, as well as decrement data.
     */
    (decrementData: NonNullablePaths<DecrementDataByVariantAndLocation, `decrementBy` | `variantId`, 2>[], options?: BulkDecrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors;
    }>;
}
declare function bulkIncrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkIncrementInventoryItemsByVariantAndLocationSignature;
interface BulkIncrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Increments quantities of multiple inventory items by variant and location.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Variant and location IDs, as well as increment data.
     */
    (incrementData: NonNullablePaths<IncrementDataByVariantAndLocation, `incrementBy` | `variantId`, 2>[], options?: BulkIncrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors;
    }>;
}
/** @internal */
declare function bulkSetOrAdjustInventoryItemsByFilter$1(httpClient: HttpClient): BulkSetOrAdjustInventoryItemsByFilterSignature;
interface BulkSetOrAdjustInventoryItemsByFilterSignature {
    /**
     * Set or Adjust inventory items which satisfy the provided filter.
     * If item track quantity, adjust it's quantity,
     * In case non-tracking, updates it to track and sets quantity to `incrementBy` or `decrementBy`.
     * @param - Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    (filter: Record<string, any>, options?: NonNullablePaths<BulkSetOrAdjustInventoryItemsByFilterOptions, `adjustedInventoryAction`, 2>): Promise<NonNullablePaths<BulkSetOrAdjustInventoryItemsByFilterResponse, `jobId`, 2> & {
        __applicationErrorsType?: BulkSetOrAdjustInventoryItemsByFilterApplicationErrors;
    }>;
}
declare const onInventoryItemCreated$1: EventDefinition<InventoryItemCreatedEnvelope, "wix.stores.catalog.v3.inventory_item_created">;
declare const onInventoryItemDeleted$1: EventDefinition<InventoryItemDeletedEnvelope, "wix.stores.catalog.v3.inventory_item_deleted">;
declare const onInventoryItemStockStatusUpdated$1: EventDefinition<InventoryItemStockStatusUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_stock_status_updated">;
declare const onInventoryItemUpdated$1: EventDefinition<InventoryItemUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_updated">;
declare const onInventoryItemUpdatedWithReason$1: EventDefinition<InventoryItemUpdatedWithReasonEnvelope, "wix.stores.catalog.v3.inventory_item_updated_with_reason">;

declare const createInventoryItem: MaybeContext<BuildRESTFunction<typeof createInventoryItem$1> & typeof createInventoryItem$1>;
declare const bulkCreateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkCreateInventoryItems$1> & typeof bulkCreateInventoryItems$1>;
declare const getInventoryItem: MaybeContext<BuildRESTFunction<typeof getInventoryItem$1> & typeof getInventoryItem$1>;
declare const updateInventoryItem: MaybeContext<BuildRESTFunction<typeof updateInventoryItem$1> & typeof updateInventoryItem$1>;
declare const bulkUpdateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItems$1> & typeof bulkUpdateInventoryItems$1>;
declare const bulkUpdateInventoryItemsByFilter: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItemsByFilter$1> & typeof bulkUpdateInventoryItemsByFilter$1>;
declare const deleteInventoryItem: MaybeContext<BuildRESTFunction<typeof deleteInventoryItem$1> & typeof deleteInventoryItem$1>;
declare const bulkDeleteInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDeleteInventoryItems$1> & typeof bulkDeleteInventoryItems$1>;
declare const queryInventoryItems: MaybeContext<BuildRESTFunction<typeof queryInventoryItems$1> & typeof queryInventoryItems$1>;
declare const searchInventoryItems: MaybeContext<BuildRESTFunction<typeof searchInventoryItems$1> & typeof searchInventoryItems$1>;
declare const bulkDecrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItems$1> & typeof bulkDecrementInventoryItems$1>;
declare const bulkIncrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItems$1> & typeof bulkIncrementInventoryItems$1>;
declare const bulkDecrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItemsByVariantAndLocation$1> & typeof bulkDecrementInventoryItemsByVariantAndLocation$1>;
declare const bulkIncrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItemsByVariantAndLocation$1> & typeof bulkIncrementInventoryItemsByVariantAndLocation$1>;
/** @internal */
declare const bulkSetOrAdjustInventoryItemsByFilter: MaybeContext<BuildRESTFunction<typeof bulkSetOrAdjustInventoryItemsByFilter$1> & typeof bulkSetOrAdjustInventoryItemsByFilter$1>;
/**
 * Triggered when an inventory item is created.
 */
declare const onInventoryItemCreated: BuildEventDefinition<typeof onInventoryItemCreated$1> & typeof onInventoryItemCreated$1;
/**
 * Triggered when an inventory item is deleted.
 */
declare const onInventoryItemDeleted: BuildEventDefinition<typeof onInventoryItemDeleted$1> & typeof onInventoryItemDeleted$1;
/**
 * Triggered when an inventory item's stock is updated.
 */
declare const onInventoryItemStockStatusUpdated: BuildEventDefinition<typeof onInventoryItemStockStatusUpdated$1> & typeof onInventoryItemStockStatusUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdated: BuildEventDefinition<typeof onInventoryItemUpdated$1> & typeof onInventoryItemUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdatedWithReason: BuildEventDefinition<typeof onInventoryItemUpdatedWithReason$1> & typeof onInventoryItemUpdatedWithReason$1;

export { BulkCreateInventoryItemsApplicationErrors, BulkCreateInventoryItemsOptions, BulkCreateInventoryItemsResponse, BulkCreateInventoryItemsValidationErrors, BulkDecrementInventoryItemsApplicationErrors, BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors, BulkDecrementInventoryItemsByVariantAndLocationOptions, BulkDecrementInventoryItemsByVariantAndLocationResponse, BulkDecrementInventoryItemsOptions, BulkDecrementInventoryItemsResponse, BulkDeleteInventoryItemsResponse, BulkIncrementInventoryItemsApplicationErrors, BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors, BulkIncrementInventoryItemsByVariantAndLocationOptions, BulkIncrementInventoryItemsByVariantAndLocationResponse, BulkIncrementInventoryItemsOptions, BulkIncrementInventoryItemsResponse, BulkSetOrAdjustInventoryItemsByFilterApplicationErrors, BulkSetOrAdjustInventoryItemsByFilterOptions, BulkSetOrAdjustInventoryItemsByFilterResponse, BulkUpdateInventoryItemsApplicationErrors, BulkUpdateInventoryItemsByFilterApplicationErrors, BulkUpdateInventoryItemsByFilterOptions, BulkUpdateInventoryItemsByFilterResponse, BulkUpdateInventoryItemsOptions, BulkUpdateInventoryItemsResponse, CreateInventoryItemApplicationErrors, CreateInventoryItemValidationErrors, DecrementDataById, DecrementDataByVariantAndLocation, IncrementDataById, IncrementDataByVariantAndLocation, InventoryItem, InventoryItemCreatedEnvelope, InventoryItemDeletedEnvelope, InventoryItemSearch, InventoryItemStockStatusUpdatedEnvelope, InventoryItemUpdatedEnvelope, InventoryItemUpdatedWithReasonEnvelope, InventoryItemsQueryBuilder, MaskedInventoryItem, SearchInventoryItemsResponse, UpdateInventoryItem, UpdateInventoryItemApplicationErrors, UpdateInventoryItemOptions, bulkCreateInventoryItems, bulkDecrementInventoryItems, bulkDecrementInventoryItemsByVariantAndLocation, bulkDeleteInventoryItems, bulkIncrementInventoryItems, bulkIncrementInventoryItemsByVariantAndLocation, bulkSetOrAdjustInventoryItemsByFilter, bulkUpdateInventoryItems, bulkUpdateInventoryItemsByFilter, createInventoryItem, deleteInventoryItem, getInventoryItem, onInventoryItemCreated, onInventoryItemDeleted, onInventoryItemStockStatusUpdated, onInventoryItemUpdated, onInventoryItemUpdatedWithReason, queryInventoryItems, searchInventoryItems, updateInventoryItem };
