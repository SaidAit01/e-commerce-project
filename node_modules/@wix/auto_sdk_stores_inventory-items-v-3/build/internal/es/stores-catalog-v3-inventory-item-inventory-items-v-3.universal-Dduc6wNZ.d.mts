import { SearchSpec, Search, NonNullablePaths } from '@wix/sdk-types';

/** Inventory Item. */
interface InventoryItem extends InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     * @min -99999
     * @max 99999
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Variant ID.
     * @format GUID
     * @immutable
     */
    variantId?: string;
    /**
     * Stores location ID.
     * @format GUID
     * @immutable
     */
    locationId?: string | null;
    /**
     * Product ID.
     * @minLength 1
     * @maxLength 36
     * @immutable
     */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatusWithLiterals;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo;
    /**
     * Product.
     * @readonly
     */
    product?: Product;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
/** @oneof */
interface InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     * @min -99999
     * @max 99999
     */
    quantity?: number;
}
declare enum AvailabilityStatus {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    /** Product is out of stock. */
    OUT_OF_STOCK = "OUT_OF_STOCK",
    /** Product is in stock. See `quantity` field for exact amount in stock. */
    IN_STOCK = "IN_STOCK",
    /** Product is only available for preorder. See `preorderInfo` field for more info. */
    PREORDER = "PREORDER"
}
/** @enumType */
type AvailabilityStatusWithLiterals = AvailabilityStatus | 'UNKNOWN_AVAILABILITY_STATUS' | 'OUT_OF_STOCK' | 'IN_STOCK' | 'PREORDER';
interface PreorderInfo {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /**
     * A message the customer will see when the item is out of stock and preorder is enabled.
     * @minLength 1
     * @maxLength 250
     */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     * @max 100000
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     * @max 99999
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
interface Product {
    /**
     * Product name.
     * @maxLength 80
     */
    name?: string | null;
    /**
     * List of category IDs that this product is included in directly.
     * @format GUID
     * @maxSize 2000
     */
    directCategoryIds?: string[];
    /**
     * Variant name.
     * @minLength 1
     * @maxLength 250
     */
    variantName?: string | null;
    /**
     * Variant SKU (stock keeping unit).
     * @minLength 1
     * @maxLength 40
     */
    variantSku?: string | null;
    /** Variant visible. */
    variantVisible?: boolean | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
    /**
     * tell us why you're invalidating the cache. You don't need to add your app name
     * @maxLength 256
     */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
}
interface App {
    /**
     * The AppDefId
     * @minLength 1
     */
    appDefId?: string;
    /**
     * The instance Id
     * @format GUID
     */
    instanceId?: string;
}
interface Page {
    /**
     * the msid the page is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Page ID
     * @minLength 1
     */
    pageId?: string;
}
interface URI {
    /**
     * the msid the URI is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes
     * @minLength 1
     */
    uriPath?: string;
}
interface File {
    /**
     * the msid the file is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by filename (for media files such as PDFs)
     * @minLength 1
     * @maxLength 256
     */
    fileName?: string;
}
interface CustomTag {
    /**
     * the msid the tag is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Tag to invalidate by
     * @minLength 1
     * @maxLength 256
     */
    tag?: string;
}
interface BulkInventoryItemAction {
    /**
     * Inventory items.
     * @maxSize 1000
     */
    inventoryItems?: InventoryItem[];
    /** Type of bulk inventory changed event - created, updated or deleted */
    eventType?: EventTypeWithLiterals;
}
declare enum EventType {
    UNKNOWN = "UNKNOWN",
    CREATED = "CREATED",
    UPDATED = "UPDATED",
    DELETED = "DELETED"
}
/** @enumType */
type EventTypeWithLiterals = EventType | 'UNKNOWN' | 'CREATED' | 'UPDATED' | 'DELETED';
interface CreateInventoryItemRequest {
    /** Inventory item to create. */
    inventoryItem: InventoryItem;
}
interface CreateInventoryItemResponse {
    /** Created inventory item. */
    inventoryItem?: InventoryItem;
}
interface BulkCreateInventoryItemsRequest {
    /**
     * Inventory items to create.
     * @minSize 1
     * @maxSize 1000
     */
    inventoryItems: InventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInventoryItemsResponse {
    /**
     * Inventory items created by bulk action.
     * @minSize 1
     * @maxSize 1000
     */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface V3BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem;
}
interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it's impossible (for example, when failing to create an item).
     * @format GUID
     */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface GetInventoryItemRequest {
    /**
     * Inventory item ID.
     * @format GUID
     */
    inventoryItemId: string;
}
interface GetInventoryItemResponse {
    /** Inventory item. */
    inventoryItem?: InventoryItem;
}
interface UpdateInventoryItemRequest {
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Reason for update. */
    reason?: ReasonTypeWithLiterals;
}
/** The reason for the inventory change. */
declare enum ReasonType {
    UNKNOWN = "UNKNOWN",
    ORDER = "ORDER",
    MANUAL = "MANUAL",
    REVERT_INVENTORY_CHANGE = "REVERT_INVENTORY_CHANGE"
}
/** @enumType */
type ReasonTypeWithLiterals = ReasonType | 'UNKNOWN' | 'ORDER' | 'MANUAL' | 'REVERT_INVENTORY_CHANGE';
interface UpdateInventoryItemResponse {
    /** Updated inventory item. */
    inventoryItem?: InventoryItem;
}
/** Report when Inventory item stock status changed from in stock to out of stock and the opposite. */
interface InventoryItemStockStatusUpdatedEvent {
    /** Inventory item new status. */
    inStock?: boolean;
}
interface InventoryItemUpdatedWithReason {
    /** Updated inventory item. */
    currentEntity?: InventoryItem;
    /** Reason for the update. */
    reason?: ReasonTypeWithLiterals;
    /**
     * ID of the app that updated this inventory item.
     *
     * When Wix Stores updates an inventory item, value will always be: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`.
     * @format GUID
     */
    appId?: string;
}
interface BulkUpdateInventoryItemsRequest {
    /**
     * Inventory items to update.
     * @minSize 1
     * @maxSize 1000
     */
    inventoryItems: MaskedInventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonTypeWithLiterals;
}
interface MaskedInventoryItem {
    /** Inventory item to update. */
    inventoryItem?: InventoryItem;
}
interface BulkUpdateInventoryItemsResponse {
    /**
     * Inventory items updated by bulk action.
     * @minSize 1
     * @maxSize 1000
     */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkUpdateInventoryItemsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
interface SearchDetails {
    /** Search mode. Defines the search logic for combining multiple terms in the `expression`. */
    mode?: ModeWithLiterals;
    /**
     * Search term or expression.
     * @maxLength 100
     */
    expression?: string | null;
    /**
     * Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
     * @maxLength 200
     * @maxSize 20
     */
    fields?: string[];
    /** Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions. */
    fuzzy?: boolean;
}
declare enum Mode {
    /** At least one of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
/** @enumType */
type ModeWithLiterals = Mode | 'OR' | 'AND';
interface BulkUpdateInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     * @format GUID
     */
    jobId?: string;
}
interface DeleteInventoryItemRequest {
    /**
     * Inventory item ID.
     * @format GUID
     */
    inventoryItemId: string;
}
interface DeleteInventoryItemResponse {
}
interface BulkDeleteInventoryItemsRequest {
    /**
     * IDs of inventory items to delete.
     * @format GUID
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 1000
     */
    inventoryItemIds: string[];
}
interface BulkDeleteInventoryItemsResponse {
    /**
     * Inventory items deleted by bulk action.
     * @minSize 1
     * @maxSize 1000
     */
    results?: BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
}
interface QueryInventoryItemsRequest {
    /** Query options. */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 10
     */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /**
     * Number of items to load.
     * @max 1000
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 1000
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryInventoryItemsResponse {
    /**
     * List of inventory items.
     * @minSize 1
     * @maxSize 1000
     */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. */
    pagingMetadata?: PlatformPagingMetadataV2;
}
interface PlatformPagingMetadataV2 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: CommonCursors;
}
interface CommonCursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface SearchInventoryItemsRequest {
    /** Search options. */
    search?: CursorSearch;
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * List of sort objects.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 10
     */
    sort?: Sorting[];
    /**
     * Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
     * @maxSize 10
     */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
     * Applies to all relevant filters and aggregations, unless overridden by providing timestamps including time zone. For example, "2023-12-20T10:52:34.795Z".
     * @maxLength 50
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
}
interface Aggregation extends AggregationKindOneOf {
    /** A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store. */
    value?: ValueAggregation;
    /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. */
    range?: RangeAggregation;
    /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    scalar?: ScalarAggregation;
    /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.) For example, use a date histogram to find how many reservations have been made at a restaurant each week. */
    dateHistogram?: DateHistogramAggregation;
    /** A nested aggregation is applied within the results of another aggregation. Rather than aggregating directly on the primary dataset, first group data using one aggregation and then apply another aggregation within each group. It allows for more complex analyses where you can summarize data at different levels of detail or hierarchy. For example, to get the number of products that are in stock and out of stock for each price listed, first perform a value aggregation on `discountedPriceNumeric`, and a second value aggregation on `inStock`. */
    nested?: NestedAggregation;
    /**
     * Aggregation name, returned in `aggregations.results.name`.
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation to perform. Must align with the corresponding aggregation field. */
    type?: AggregationTypeWithLiterals;
    /**
     * Field to aggregate by. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
     * @maxLength 200
     */
    fieldPath?: string;
    /**
     * Deprecated. Use `nested` instead.
     * @deprecated Deprecated. Use `nested` instead.
     * @replacedBy kind.nested
     * @targetRemovalDate 2024-03-30
     */
    groupBy?: GroupByAggregation;
}
/** @oneof */
interface AggregationKindOneOf {
    /** A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store. */
    value?: ValueAggregation;
    /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. */
    range?: RangeAggregation;
    /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    scalar?: ScalarAggregation;
    /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.) For example, use a date histogram to find how many reservations have been made at a restaurant each week. */
    dateHistogram?: DateHistogramAggregation;
    /** A nested aggregation is applied within the results of another aggregation. Rather than aggregating directly on the primary dataset, first group data using one aggregation and then apply another aggregation within each group. It allows for more complex analyses where you can summarize data at different levels of detail or hierarchy. For example, to get the number of products that are in stock and out of stock for each price listed, first perform a value aggregation on `discountedPriceNumeric`, and a second value aggregation on `inStock`. */
    nested?: NestedAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if `to` is not provided. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` is not provided. */
    to?: number | null;
}
declare enum SortType {
    /** Number of matches in the results. */
    COUNT = "COUNT",
    /** Alphabetically by the field value. */
    VALUE = "VALUE"
}
/** @enumType */
type SortTypeWithLiterals = SortType | 'COUNT' | 'VALUE';
declare enum SortDirection {
    /** Descending order. */
    DESC = "DESC",
    /** Ascending order. */
    ASC = "ASC"
}
/** @enumType */
type SortDirectionWithLiterals = SortDirection | 'DESC' | 'ASC';
declare enum MissingValues {
    /** Exclude missing values from the aggregation results. */
    EXCLUDE = "EXCLUDE",
    /** Include missing values in the aggregation results. */
    INCLUDE = "INCLUDE"
}
/** @enumType */
type MissingValuesWithLiterals = MissingValues | 'EXCLUDE' | 'INCLUDE';
interface IncludeMissingValuesOptions {
    /**
     * Specify a custom name for the bucket containing the missing values. Defaults are `"N/A"` for strings, `0` for integers, and `false` for booleans.
     * @maxLength 20
     */
    addToBucket?: string;
}
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Total number of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX"
}
/** @enumType */
type ScalarTypeWithLiterals = ScalarType | 'UNKNOWN_SCALAR_TYPE' | 'COUNT_DISTINCT' | 'MIN' | 'MAX';
interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values in results. */
    includeOptions?: IncludeMissingValuesOptions;
    /** Sort type. */
    sortType?: SortTypeWithLiterals;
    /** Sort direction. */
    sortDirection?: SortDirectionWithLiterals;
    /**
     * Number of aggregation results to return.
     * Min: `1`
     * Max: `250`
     * Default: `10`
     */
    limit?: number | null;
    /**
     * Whether to include or exclude missing values in the aggregation results.
     * Default: `EXCLUDE`.
     */
    missingValues?: MissingValuesWithLiterals;
}
/** @oneof */
interface ValueAggregationOptionsOneOf {
    /** Options for including missing values in results. */
    includeOptions?: IncludeMissingValuesOptions;
}
declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
    VALUE = "VALUE",
    /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
    RANGE = "RANGE",
    /** Calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    SCALAR = "SCALAR",
    /** Calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
/** @enumType */
type NestedAggregationTypeWithLiterals = NestedAggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM';
interface RangeAggregation {
    /**
     * List of range buckets, where during aggregation each entity will be placed in the first bucket its value falls into, based on the provided range bounds.
     * @maxSize 50
     */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Operator type for the scalar aggregation. */
    type?: ScalarTypeWithLiterals;
}
interface DateHistogramAggregation {
    /** Interval for date histogram aggregation. */
    interval?: IntervalWithLiterals;
}
declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
/** @enumType */
type IntervalWithLiterals = Interval | 'UNKNOWN_INTERVAL' | 'YEAR' | 'MONTH' | 'WEEK' | 'DAY' | 'HOUR' | 'MINUTE' | 'SECOND';
interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** A value aggregation calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of orders for each order status. */
    value?: ValueAggregation;
    /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
    range?: RangeAggregation;
    /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    scalar?: ScalarAggregation;
    /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). For example, use a date histogram to determine how many reservations have been made at a restaurant each week. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
    dateHistogram?: DateHistogramAggregation;
    /**
     * Unique, caller-defined aggregation name, returned in `aggregations.results`.
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation to perform. The matching aggregation field must be passed. */
    type?: NestedAggregationTypeWithLiterals;
    /**
     * Field to aggregate by. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf {
    /** A value aggregation calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of orders for each order status. */
    value?: ValueAggregation;
    /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
    range?: RangeAggregation;
    /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    scalar?: ScalarAggregation;
    /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). For example, use a date histogram to determine how many reservations have been made at a restaurant each week. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
    dateHistogram?: DateHistogramAggregation;
}
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
    VALUE = "VALUE",
    /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
    RANGE = "RANGE",
    /** Calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    SCALAR = "SCALAR",
    /** Calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Flattened list of aggregations, where each aggregation is nested within previous one. */
    NESTED = "NESTED"
}
/** @enumType */
type AggregationTypeWithLiterals = AggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM' | 'NESTED';
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one. */
interface NestedAggregation {
    /**
     * Flattened list of aggregations, where each next aggregation is nested within previous one.
     * @minSize 2
     * @maxSize 3
     */
    nestedAggregations?: NestedAggregationItem[];
}
interface GroupByAggregation extends GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
    /**
     * Unique, caller-defined aggregation name, returned in `aggregations.results`.
     * @maxLength 100
     */
    name?: string | null;
    /**
     * Field to aggregate by.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
}
interface SearchInventoryItemsResponse {
    /**
     * List of inventory items.
     * @minSize 1
     * @maxSize 1000
     */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
    /** Aggregation data. */
    aggregationData?: AggregationData;
}
interface CursorPagingMetadata {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface AggregationData {
    /**
     * List of the aggregated data results.
     * @maxSize 10000
     */
    results?: AggregationResults[];
}
interface ValueAggregationResult {
    /**
     * Value of the field.
     * @maxLength 100
     */
    value?: string;
    /** Number of entities with this value. */
    count?: number;
}
interface RangeAggregationResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Total number of entities in this range. */
    count?: number;
}
interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /**
     * Unique, caller-defined aggregation name, identifiable by the requested aggregation `name`.
     * @maxLength 100
     */
    name?: string;
    /** Aggregation type. */
    type?: AggregationTypeWithLiterals;
    /**
     * Field which the data was aggregated by.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
}
interface ValueResults {
    /**
     * List of value aggregations.
     * @maxSize 250
     */
    results?: ValueAggregationResult[];
}
interface RangeResults {
    /**
     * List of ranges returned in same order as requested.
     * @maxSize 50
     */
    results?: RangeAggregationResult[];
}
interface AggregationResultsScalarResult {
    /** Type of scalar aggregation. */
    type?: ScalarTypeWithLiterals;
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedValueAggregationResult {
    /**
     * Value of the field.
     * @maxLength 1000
     */
    value?: string;
    /** Nested aggregations. */
    nestedResults?: NestedAggregationResults;
}
interface ValueResult {
    /**
     * Value of the field.
     * @maxLength 1000
     */
    value?: string;
    /** Number of entities with this value. */
    count?: number | null;
}
interface RangeResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Total number of entities in this range. */
    count?: number | null;
}
interface ScalarResult {
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedResultValue extends NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
/** @oneof */
interface NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
interface Results {
    /** List of nested aggregations. */
    results?: Record<string, NestedResultValue>;
}
interface DateHistogramResult {
    /**
     * Date in ISO 8601 format.
     * @maxLength 100
     */
    value?: string;
    /** Count of documents in the bucket. */
    count?: number;
}
interface GroupByValueResults {
    /**
     * List of value aggregations.
     * @maxSize 1000
     */
    results?: NestedValueAggregationResult[];
}
interface DateHistogramResults {
    /**
     * List of date histogram aggregations.
     * @maxSize 200
     */
    results?: DateHistogramResult[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form.
 * Aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface NestedResults {
    /**
     * List of nested aggregations.
     * @maxSize 1000
     */
    results?: Results[];
}
interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
    /**
     * Aggregation name, returned in `aggregations.results.name`.
     * @maxLength 100
     */
    name?: string;
    /** Aggregation type. Must align with the corresponding aggregation field. */
    type?: AggregationTypeWithLiterals;
    /**
     * Field to aggregate by. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
}
interface SearchInventoryItemsWithOffsetRequest {
    /** WQL expression. */
    search?: OffsetSearch;
}
interface OffsetSearch extends OffsetSearchPagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: Paging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 10
     */
    sort?: Sorting[];
    /**
     * Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned.
     * @maxLength 200
     * @maxSize 20
     */
    fields?: string[];
    /**
     * Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned.
     * @maxLength 100
     * @maxSize 20
     */
    fieldsets?: string[];
    /**
     * Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
     * @maxSize 10
     */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
     * Applies to all relevant filters and aggregations, unless overridden by providing timestamps including time zone. For example, "2023-12-20T10:52:34.795Z".
     * @maxLength 50
     */
    timeZone?: string | null;
}
/** @oneof */
interface OffsetSearchPagingMethodOneOf {
    /** Paging options to limit and offset the number of items. */
    paging?: Paging;
}
interface SearchInventoryItemsWithOffsetResponse {
    /** InventoryItems which satisfy the provided query. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. Contains cursor which can be used in next query. */
    pagingMetadata?: PagingMetadata;
}
interface PagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
interface BulkDecrementInventoryItemsRequest {
    /**
     * Inventory item IDs and decrement data.
     * @minSize 1
     * @maxSize 300
     */
    decrementData: DecrementDataById[];
    /**
     * Whether inventory is restricted from going below zero.
     *
     * Default: `true` - inventory does not go below zero.
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonTypeWithLiterals;
}
interface DecrementDataById {
    /**
     * Inventory item ID.
     * @format GUID
     */
    inventoryItemId?: string;
    /**
     * Amount to decrement by.
     * @min 1
     * @max 99999
     */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsResponse {
    /**
     * Inventory items updated by bulk action.
     * @minSize 1
     * @maxSize 300
     */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkIncrementInventoryItemsRequest {
    /**
     * Inventory item IDs and increment data.
     * @minSize 1
     * @maxSize 300
     */
    incrementData: IncrementDataById[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonTypeWithLiterals;
}
interface IncrementDataById {
    /**
     * Inventory item ID.
     * @format GUID
     */
    inventoryItemId?: string;
    /**
     * Amount to increment by.
     * @min 1
     * @max 99999
     */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsResponse {
    /**
     * Inventory items updated by bulk action.
     * @minSize 1
     * @maxSize 300
     */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkDecrementInventoryItemsByVariantAndLocationRequest {
    /**
     * Variant and location IDs, as well as decrement data.
     * @minSize 1
     * @maxSize 300
     */
    decrementData: DecrementDataByVariantAndLocation[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonTypeWithLiterals;
}
interface DecrementDataByVariantAndLocation {
    /**
     * Variant ID.
     * @format GUID
     */
    variantId?: string;
    /**
     * Location ID.
     * @format GUID
     */
    locationId?: string | null;
    /**
     * Amount to decrement by.
     * @min 1
     * @max 99999
     */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponse {
    /**
     * Inventory items updated by bulk action.
     * @minSize 1
     * @maxSize 300
     */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkIncrementInventoryItemsByVariantAndLocationRequest {
    /**
     * Variant and location IDs, as well as increment data.
     * @minSize 1
     * @maxSize 300
     */
    incrementData: IncrementDataByVariantAndLocation[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonTypeWithLiterals;
}
interface IncrementDataByVariantAndLocation {
    /**
     * Variant ID.
     * @format GUID
     */
    variantId?: string;
    /**
     * Location ID.
     * @format GUID
     */
    locationId?: string | null;
    /**
     * Amount to increment by.
     * @min 1
     * @max 99999
     */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponse {
    /**
     * Inventory items updated by bulk action.
     * @minSize 1
     * @maxSize 300
     */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata details as: totalSuccess and totalFailure. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface BulkSetOrAdjustInventoryItemsByFilterRequest {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter: Record<string, any> | null;
    /** Action to adjust the inventory by. (e.g increment or decrement) */
    adjustedInventoryAction: AdjustInventoryAction;
    /** Free text to match in searchable fields */
    search?: SearchDetails;
}
interface AdjustInventoryAction extends AdjustInventoryActionActionOneOf {
    /**
     * Amount to increment by.
     * @min 1
     * @max 99999
     */
    incrementBy?: number;
    /**
     * Amount to decrement by.
     * @min 1
     * @max 99999
     */
    decrementBy?: number;
}
/** @oneof */
interface AdjustInventoryActionActionOneOf {
    /**
     * Amount to increment by.
     * @min 1
     * @max 99999
     */
    incrementBy?: number;
    /**
     * Amount to decrement by.
     * @min 1
     * @max 99999
     */
    decrementBy?: number;
}
interface BulkSetOrAdjustInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     * @format GUID
     */
    jobId?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type CreateInventoryItemApplicationErrors = {
    code?: 'ITEM_ALREADY_EXISTS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRE_ORDER_VALIDATION';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreateInventoryItemValidationErrors = {
    ruleName?: 'REQUESTED_QUANTITY_MUST_BE_NON_NEGATIVE';
} | {
    ruleName?: 'PREORDER_LIMIT_NOT_SUPPORTED_FOR_UNTRACKED_INVENTORY';
};
/** @docsIgnore */
type BulkCreateInventoryItemsApplicationErrors = {
    code?: 'PRE_ORDER_VALIDATION';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkCreateInventoryItemsValidationErrors = {
    ruleName?: 'REQUESTED_QUANTITY_MUST_BE_NON_NEGATIVE';
} | {
    ruleName?: 'PREORDER_LIMIT_NOT_SUPPORTED_FOR_UNTRACKED_INVENTORY';
};
/** @docsIgnore */
type UpdateInventoryItemApplicationErrors = {
    code?: 'REQUESTED_QUANTITY_MUST_BE_NON_NEGATIVE_DECREASING';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRE_ORDER_VALIDATION';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkUpdateInventoryItemsApplicationErrors = {
    code?: 'REQUESTED_QUANTITY_MUST_BE_NON_NEGATIVE_DECREASING';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRE_ORDER_VALIDATION';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkUpdateInventoryItemsByFilterApplicationErrors = {
    code?: 'REQUESTED_QUANTITY_MUST_BE_NON_NEGATIVE_DECREASING';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRE_ORDER_VALIDATION';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkDecrementInventoryItemsApplicationErrors = {
    code?: 'INVENTORY_QUANTITY_NOT_TRACKED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INSUFFICIENT_INVENTORY';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MIN_QUANTITY_LIMIT_REACHED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkIncrementInventoryItemsApplicationErrors = {
    code?: 'INVENTORY_QUANTITY_NOT_TRACKED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MAX_QUANTITY_LIMIT_REACHED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors = {
    code?: 'INVENTORY_QUANTITY_NOT_TRACKED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INSUFFICIENT_INVENTORY';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MIN_QUANTITY_LIMIT_REACHED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors = {
    code?: 'INVENTORY_QUANTITY_NOT_TRACKED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MAX_QUANTITY_LIMIT_REACHED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkSetOrAdjustInventoryItemsByFilterApplicationErrors = {
    code?: 'INVENTORY_QUANTITY_NOT_TRACKED';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface InventoryItemCreatedEnvelope {
    entity: InventoryItem;
    metadata: EventMetadata;
}
/**
 * Triggered when an inventory item is created.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId WIX_STORES.INVENTORY_READ
 * @webhook
 * @eventType wix.stores.catalog.v3.inventory_item_created
 * @serviceIdentifier com.wix.stores.catalog.inventory.api.v3.InventoryService
 * @slug created
 */
declare function onInventoryItemCreated(handler: (event: InventoryItemCreatedEnvelope) => void | Promise<void>): void;
interface InventoryItemDeletedEnvelope {
    entity: InventoryItem;
    metadata: EventMetadata;
}
/**
 * Triggered when an inventory item is deleted.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId WIX_STORES.INVENTORY_READ
 * @webhook
 * @eventType wix.stores.catalog.v3.inventory_item_deleted
 * @serviceIdentifier com.wix.stores.catalog.inventory.api.v3.InventoryService
 * @slug deleted
 */
declare function onInventoryItemDeleted(handler: (event: InventoryItemDeletedEnvelope) => void | Promise<void>): void;
interface InventoryItemStockStatusUpdatedEnvelope {
    data: InventoryItemStockStatusUpdatedEvent;
    metadata: EventMetadata;
}
/**
 * Triggered when an inventory item's stock is updated.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId WIX_STORES.INVENTORY_READ
 * @webhook
 * @eventType wix.stores.catalog.v3.inventory_item_stock_status_updated
 * @serviceIdentifier com.wix.stores.catalog.inventory.api.v3.InventoryService
 * @slug stock_status_updated
 */
declare function onInventoryItemStockStatusUpdated(handler: (event: InventoryItemStockStatusUpdatedEnvelope) => void | Promise<void>): void;
interface InventoryItemUpdatedEnvelope {
    entity: InventoryItem;
    metadata: EventMetadata;
}
/**
 * Triggered when an inventory item is updated.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId WIX_STORES.INVENTORY_READ
 * @webhook
 * @eventType wix.stores.catalog.v3.inventory_item_updated
 * @serviceIdentifier com.wix.stores.catalog.inventory.api.v3.InventoryService
 * @slug updated
 */
declare function onInventoryItemUpdated(handler: (event: InventoryItemUpdatedEnvelope) => void | Promise<void>): void;
interface InventoryItemUpdatedWithReasonEnvelope {
    data: InventoryItemUpdatedWithReason;
    metadata: EventMetadata;
}
/**
 * Triggered when an inventory item is updated.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId WIX_STORES.INVENTORY_READ
 * @webhook
 * @eventType wix.stores.catalog.v3.inventory_item_updated_with_reason
 * @serviceIdentifier com.wix.stores.catalog.inventory.api.v3.InventoryService
 * @slug updated_with_reason
 */
declare function onInventoryItemUpdatedWithReason(handler: (event: InventoryItemUpdatedWithReasonEnvelope) => void | Promise<void>): void;
/**
 * Creates an inventory item.
 * The combination of `variantId` and `locationId` is unique.
 * @param inventoryItem - Inventory item to create.
 * @public
 * @requiredField inventoryItem
 * @requiredField inventoryItem.productId
 * @requiredField inventoryItem.trackingMethod
 * @requiredField inventoryItem.variantId
 * @permissionId WIX_STORES.INVENTORY_CREATE
 * @applicableIdentity APP
 * @returns Created inventory item.
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.CreateInventoryItem
 */
declare function createInventoryItem(inventoryItem: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
    __applicationErrorsType?: CreateInventoryItemApplicationErrors;
    __validationErrorsType?: CreateInventoryItemValidationErrors;
}>;
/**
 * Creates multiple inventory items.
 * @param inventoryItems - Inventory items to create.
 * @public
 * @requiredField inventoryItems
 * @requiredField inventoryItems.productId
 * @requiredField inventoryItems.trackingMethod
 * @requiredField inventoryItems.variantId
 * @permissionId WIX_STORES.INVENTORY_CREATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkCreateInventoryItems
 */
declare function bulkCreateInventoryItems(inventoryItems: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>[], options?: BulkCreateInventoryItemsOptions): Promise<NonNullablePaths<BulkCreateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkCreateInventoryItemsApplicationErrors;
    __validationErrorsType?: BulkCreateInventoryItemsValidationErrors;
}>;
interface BulkCreateInventoryItemsOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
/**
 * Retrieves an inventory item.
 * @param inventoryItemId - Inventory item ID.
 * @public
 * @requiredField inventoryItemId
 * @permissionId WIX_STORES.INVENTORY_READ
 * @applicableIdentity APP
 * @returns Inventory item.
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.GetInventoryItem
 */
declare function getInventoryItem(inventoryItemId: string): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3>>;
/**
 * Updates an inventory item.
 *
 *
 * Each time the inventory item is updated, `revision` increments by 1.
 * The current `revision` must be passed when updating the inventory item.
 * This ensures you're working with the latest inventory item and prevents unintended overwrites.
 * @param _id - Inventory item ID.
 * @public
 * @requiredField _id
 * @requiredField inventoryItem
 * @requiredField inventoryItem.revision
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @returns Updated inventory item.
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.UpdateInventoryItem
 */
declare function updateInventoryItem(_id: string, inventoryItem: NonNullablePaths<UpdateInventoryItem, `revision`, 2>, options?: UpdateInventoryItemOptions): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
    __applicationErrorsType?: UpdateInventoryItemApplicationErrors;
}>;
interface UpdateInventoryItem {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     * @min -99999
     * @max 99999
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Variant ID.
     * @format GUID
     * @immutable
     */
    variantId?: string;
    /**
     * Stores location ID.
     * @format GUID
     * @immutable
     */
    locationId?: string | null;
    /**
     * Product ID.
     * @minLength 1
     * @maxLength 36
     * @immutable
     */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatusWithLiterals;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo;
    /**
     * Product.
     * @readonly
     */
    product?: Product;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
interface UpdateInventoryItemOptions {
    /** Reason for update. */
    reason?: ReasonTypeWithLiterals;
}
/**
 * Updates multiple inventory items.
 *
 * Each time an inventory item is updated, `revision` increments by 1.
 * The current `revision` must be passed when updating an inventory item.
 * This ensures you're working with the latest inventory item and prevents unintended overwrites.
 * @param inventoryItems - Inventory items to update.
 * @public
 * @requiredField inventoryItems
 * @requiredField inventoryItems.inventoryItem._id
 * @requiredField inventoryItems.inventoryItem.revision
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkUpdateInventoryItems
 */
declare function bulkUpdateInventoryItems(inventoryItems: NonNullablePaths<MaskedInventoryItem, `inventoryItem._id` | `inventoryItem.revision`, 3>[], options?: BulkUpdateInventoryItemsOptions): Promise<NonNullablePaths<BulkUpdateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkUpdateInventoryItemsApplicationErrors;
}>;
interface BulkUpdateInventoryItemsOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonTypeWithLiterals;
}
/**
 * Updates multiple inventory items, given the provided filter.
 *
 * Each time an inventory item is updated, `revision` increments by 1.
 * The current `revision` must be passed when updating an inventory item.
 * This ensures you're working with the latest inventory item and prevents unintended overwrites.
 * @param filter - Filter object.
 * @public
 * @requiredField filter
 * @requiredField options.inventoryItem
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkUpdateInventoryItemsByFilter
 */
declare function bulkUpdateInventoryItemsByFilter(filter: Record<string, any>, options?: NonNullablePaths<BulkUpdateInventoryItemsByFilterOptions, `inventoryItem`, 2>): Promise<NonNullablePaths<BulkUpdateInventoryItemsByFilterResponse, `jobId`, 2> & {
    __applicationErrorsType?: BulkUpdateInventoryItemsByFilterApplicationErrors;
}>;
interface BulkUpdateInventoryItemsByFilterOptions {
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
/**
 * Deletes an inventory item.
 * @param inventoryItemId - Inventory item ID.
 * @public
 * @requiredField inventoryItemId
 * @permissionId WIX_STORES.INVENTORY_DELETE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.DeleteInventoryItem
 */
declare function deleteInventoryItem(inventoryItemId: string): Promise<void>;
/**
 * Deletes multiple inventory items.
 * @param inventoryItemIds - IDs of inventory items to delete.
 * @public
 * @requiredField inventoryItemIds
 * @permissionId WIX_STORES.INVENTORY_DELETE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkDeleteInventoryItems
 */
declare function bulkDeleteInventoryItems(inventoryItemIds: string[]): Promise<NonNullablePaths<BulkDeleteInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
/**
 * Retrieves a list of up to 1,000 inventory items, given the provided filtering, sorting, and cursor paging.
 *
 * For field support for filters and sorting,
 * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
 *
 * To learn about working with _Query_ endpoints, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
 * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
 * @public
 * @permissionId WIX_STORES.INVENTORY_READ
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.QueryInventoryItems
 */
declare function queryInventoryItems(): InventoryItemsQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface InventoryItemsQueryResult extends QueryCursorResult {
    items: InventoryItem[];
    query: InventoryItemsQueryBuilder;
    next: () => Promise<InventoryItemsQueryResult>;
    prev: () => Promise<InventoryItemsQueryResult>;
}
interface InventoryItemsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'product.name' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'product.name' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'product.name' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'product.name' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: '_id' | 'variantId' | 'locationId' | 'productId' | 'product.name' | 'product.variantName' | 'product.variantSku', value: string) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku', value: any[]) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasAll: (propertyName: 'product.directCategoryIds', value: any[]) => InventoryItemsQueryBuilder;
    in: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku', value: any) => InventoryItemsQueryBuilder;
    exists: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku', value: boolean) => InventoryItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'inStock' | 'quantity' | '_createdDate' | '_updatedDate' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku'>) => InventoryItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'inStock' | 'quantity' | '_createdDate' | '_updatedDate' | 'productId' | 'trackQuantity' | 'availabilityStatus' | 'preorderInfo.enabled' | 'product.name' | 'product.directCategoryIds' | 'product.variantName' | 'product.variantSku'>) => InventoryItemsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => InventoryItemsQueryBuilder;
    /** @param cursor - A pointer to specific record */
    skipTo: (cursor: string) => InventoryItemsQueryBuilder;
    find: () => Promise<InventoryItemsQueryResult>;
}
interface InventoryItemSearchSpec extends SearchSpec {
    searchable: ['product.name', 'product.variantName', 'product.variantSku'];
    aggregatable: [
        '_createdDate',
        '_id',
        '_updatedDate',
        'availabilityStatus',
        'inStock',
        'locationId',
        'preorderInfo.enabled',
        'product.directCategoryIds',
        'product.name',
        'product.variantName',
        'product.variantSku',
        'productId',
        'quantity',
        'trackQuantity',
        'variantId'
    ];
    paging: 'cursor';
    wql: [
        {
            operators: '*';
            fields: ['_id', 'locationId', 'variantId'];
            sort: 'NONE';
        },
        {
            operators: ['$hasAll', '$hasSome'];
            fields: ['product.directCategoryIds'];
            sort: 'BOTH';
        },
        {
            operators: '*';
            fields: [
                '_createdDate',
                '_updatedDate',
                'availabilityStatus',
                'inStock',
                'preorderInfo.enabled',
                'product.name',
                'product.variantName',
                'product.variantSku',
                'productId',
                'quantity',
                'trackQuantity'
            ];
            sort: 'BOTH';
        }
    ];
}
type CommonSearchWithEntityContext = Search<InventoryItem, InventoryItemSearchSpec>;
type InventoryItemSearch = {
    /**
    Cursor paging options.
  
    Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
    */
    cursorPaging?: {
        /**
      Maximum number of items to return in the results.
      @max: 1000
      */
        limit?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['limit'] | null;
        /**
      Pointer to the next or previous page in the list of results.
    
      Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
      Not relevant for the first request.
      @maxLength: 16000
      */
        cursor?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['cursor'] | null;
    };
    /**
    Filter object.
  
    Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
    */
    filter?: CommonSearchWithEntityContext['filter'] | null;
    /**
    List of sort objects.
  
    Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
    @maxSize: 10
    */
    sort?: {
        /**
      Name of the field to sort by.
      @maxLength: 512
      */
        fieldName?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['fieldName'];
        /**
      Sort order.
      */
        order?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['order'];
    }[];
    /**
    Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
    @maxSize: 10
    */
    aggregations?: {
        /**
      A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store.
      */
        value?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['value'];
        /**
      A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more.
      */
        range?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['range'];
        /**
      A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`.
      */
        scalar?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['scalar'];
        /**
      A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.) For example, use a date histogram to find how many reservations have been made at a restaurant each week.
      */
        dateHistogram?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['dateHistogram'];
        /**
      A nested aggregation is applied within the results of another aggregation. Rather than aggregating directly on the primary dataset, first group data using one aggregation and then apply another aggregation within each group. It allows for more complex analyses where you can summarize data at different levels of detail or hierarchy. For example, to get the number of products that are in stock and out of stock for each price listed, first perform a value aggregation on `discountedPriceNumeric`, and a second value aggregation on `inStock`.
      */
        nested?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['nested'];
        /**
      Aggregation name, returned in `aggregations.results.name`.
      @maxLength: 100
      */
        name?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['name'] | null;
        /**
      Type of aggregation to perform. Must align with the corresponding aggregation field.
      */
        type?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['type'];
        /**
      Field to aggregate by. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
      @maxLength: 200
      */
        fieldPath?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['fieldPath'];
        /**
      Deprecated. Use `nested` instead.
      @deprecated: Deprecated. Use `nested` instead.,
      @replacedBy: kind.nested,
      @targetRemovalDate: 2024-03-30
      */
        groupBy?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['groupBy'];
    }[];
    /**
    Free text to match in searchable fields.
    */
    search?: {
        /**
      Search mode. Defines the search logic for combining multiple terms in the `expression`.
      */
        mode?: NonNullable<CommonSearchWithEntityContext['search']>['mode'];
        /**
      Search term or expression.
      @maxLength: 100
      */
        expression?: NonNullable<CommonSearchWithEntityContext['search']>['expression'] | null;
        /**
      Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
      @maxLength: 200,
      @maxSize: 20
      */
        fields?: NonNullable<CommonSearchWithEntityContext['search']>['fields'];
        /**
      Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions.
      */
        fuzzy?: NonNullable<CommonSearchWithEntityContext['search']>['fuzzy'];
    };
    /**
    Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
    Applies to all relevant filters and aggregations, unless overridden by providing timestamps including time zone. For example, "2023-12-20T10:52:34.795Z".
    @maxLength: 50
    */
    timeZone?: CommonSearchWithEntityContext['timeZone'] | null;
};
/**
 * Decrements quantities of multiple inventory items.
 *
 * > **Notes:**:
 * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
 * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
 * > + Pass `restrictInventory: false` to allow for negative quantities.
 * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
 * @param decrementData - Inventory item IDs and decrement data.
 * @public
 * @requiredField decrementData
 * @requiredField decrementData.decrementBy
 * @requiredField decrementData.inventoryItemId
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkDecrementInventoryItems
 */
declare function bulkDecrementInventoryItems(decrementData: NonNullablePaths<DecrementDataById, `decrementBy` | `inventoryItemId`, 2>[], options?: BulkDecrementInventoryItemsOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkDecrementInventoryItemsApplicationErrors;
}>;
interface BulkDecrementInventoryItemsOptions {
    /**
     * Whether inventory is restricted from going below zero.
     *
     * Default: `true` - inventory does not go below zero.
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonTypeWithLiterals;
}
/**
 * Increments quantities of multiple inventory items.
 *
 * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
 * @param incrementData - Inventory item IDs and increment data.
 * @public
 * @requiredField incrementData
 * @requiredField incrementData.incrementBy
 * @requiredField incrementData.inventoryItemId
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkIncrementInventoryItems
 */
declare function bulkIncrementInventoryItems(incrementData: NonNullablePaths<IncrementDataById, `incrementBy` | `inventoryItemId`, 2>[], options?: BulkIncrementInventoryItemsOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkIncrementInventoryItemsApplicationErrors;
}>;
interface BulkIncrementInventoryItemsOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonTypeWithLiterals;
}
/**
 * Decrements quantities of multiple inventory items by variant and location.
 *
 * > **Notes:**:
 * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
 * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
 * > + Pass `restrictInventory: false` to allow for negative quantities.
 * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
 * @param decrementData - Variant and location IDs, as well as decrement data.
 * @public
 * @requiredField decrementData
 * @requiredField decrementData.decrementBy
 * @requiredField decrementData.variantId
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkDecrementInventoryItemsByVariantAndLocation
 */
declare function bulkDecrementInventoryItemsByVariantAndLocation(decrementData: NonNullablePaths<DecrementDataByVariantAndLocation, `decrementBy` | `variantId`, 2>[], options?: BulkDecrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors;
}>;
interface BulkDecrementInventoryItemsByVariantAndLocationOptions {
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonTypeWithLiterals;
}
/**
 * Increments quantities of multiple inventory items by variant and location.
 *
 * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
 * @param incrementData - Variant and location IDs, as well as increment data.
 * @public
 * @requiredField incrementData
 * @requiredField incrementData.incrementBy
 * @requiredField incrementData.variantId
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkIncrementInventoryItemsByVariantAndLocation
 */
declare function bulkIncrementInventoryItemsByVariantAndLocation(incrementData: NonNullablePaths<IncrementDataByVariantAndLocation, `incrementBy` | `variantId`, 2>[], options?: BulkIncrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors;
}>;
interface BulkIncrementInventoryItemsByVariantAndLocationOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonTypeWithLiterals;
}
/**
 * Set or Adjust inventory items which satisfy the provided filter.
 * If item track quantity, adjust it's quantity,
 * In case non-tracking, updates it to track and sets quantity to `incrementBy` or `decrementBy`.
 * @param filter - Filter object in the following format:
 * `"filter" : {
 * "fieldName1": "value1",
 * "fieldName2":{"$operator":"value2"}
 * }`
 * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
 * @internal
 * @documentationMaturity preview
 * @requiredField filter
 * @requiredField options.adjustedInventoryAction
 * @permissionId WIX_STORES.INVENTORY_UPDATE
 * @applicableIdentity APP
 * @fqn com.wix.stores.catalog.inventory.api.v3.InventoryService.BulkSetOrAdjustInventoryItemsByFilter
 */
declare function bulkSetOrAdjustInventoryItemsByFilter(filter: Record<string, any>, options?: NonNullablePaths<BulkSetOrAdjustInventoryItemsByFilterOptions, `adjustedInventoryAction`, 2>): Promise<NonNullablePaths<BulkSetOrAdjustInventoryItemsByFilterResponse, `jobId`, 2> & {
    __applicationErrorsType?: BulkSetOrAdjustInventoryItemsByFilterApplicationErrors;
}>;
interface BulkSetOrAdjustInventoryItemsByFilterOptions {
    /** Action to adjust the inventory by. (e.g increment or decrement) */
    adjustedInventoryAction: AdjustInventoryAction;
    /** Free text to match in searchable fields */
    search?: SearchDetails;
}

export { ScalarType as $, type IncrementDataByVariantAndLocation as A, type BulkCreateInventoryItemsOptions as B, type CreateInventoryItemApplicationErrors as C, type DecrementDataById as D, type BulkIncrementInventoryItemsByVariantAndLocationOptions as E, type BulkIncrementInventoryItemsByVariantAndLocationResponse as F, type BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors as G, type BulkSetOrAdjustInventoryItemsByFilterOptions as H, type InventoryItem as I, type BulkSetOrAdjustInventoryItemsByFilterResponse as J, type BulkSetOrAdjustInventoryItemsByFilterApplicationErrors as K, type InventoryItemCreatedEnvelope as L, type MaskedInventoryItem as M, type InventoryItemDeletedEnvelope as N, type InventoryItemStockStatusUpdatedEnvelope as O, type InventoryItemUpdatedEnvelope as P, type InventoryItemUpdatedWithReasonEnvelope as Q, AvailabilityStatus as R, type SearchInventoryItemsResponse as S, EventType as T, type UpdateInventoryItem as U, ReasonType as V, Mode as W, SortOrder as X, SortType as Y, SortDirection as Z, MissingValues as _, type CreateInventoryItemValidationErrors as a, type Cursors as a$, NestedAggregationType as a0, Interval as a1, AggregationType as a2, WebhookIdentityType as a3, type InventoryItemTrackingMethodOneOf as a4, type PreorderInfo as a5, type Product as a6, type ExtendedFields as a7, type InvalidateCache as a8, type InvalidateCacheGetByOneOf as a9, type QueryInventoryItemsRequest as aA, type QueryV2 as aB, type QueryV2PagingMethodOneOf as aC, type Sorting as aD, type Paging as aE, type CursorPaging as aF, type QueryInventoryItemsResponse as aG, type PlatformPagingMetadataV2 as aH, type CommonCursors as aI, type SearchInventoryItemsRequest as aJ, type CursorSearch as aK, type CursorSearchPagingMethodOneOf as aL, type Aggregation as aM, type AggregationKindOneOf as aN, type RangeBucket as aO, type IncludeMissingValuesOptions as aP, type ValueAggregation as aQ, type ValueAggregationOptionsOneOf as aR, type RangeAggregation as aS, type ScalarAggregation as aT, type DateHistogramAggregation as aU, type NestedAggregationItem as aV, type NestedAggregationItemKindOneOf as aW, type NestedAggregation as aX, type GroupByAggregation as aY, type GroupByAggregationKindOneOf as aZ, type CursorPagingMetadata as a_, type App as aa, type Page as ab, type URI as ac, type File as ad, type CustomTag as ae, type BulkInventoryItemAction as af, type CreateInventoryItemRequest as ag, type CreateInventoryItemResponse as ah, type BulkCreateInventoryItemsRequest as ai, type V3BulkInventoryItemResult as aj, type ItemMetadata as ak, type ApplicationError as al, type BulkActionMetadata as am, type GetInventoryItemRequest as an, type GetInventoryItemResponse as ao, type UpdateInventoryItemRequest as ap, type UpdateInventoryItemResponse as aq, type InventoryItemStockStatusUpdatedEvent as ar, type InventoryItemUpdatedWithReason as as, type BulkUpdateInventoryItemsRequest as at, type BulkUpdateInventoryItemsByFilterRequest as au, type SearchDetails as av, type DeleteInventoryItemRequest as aw, type DeleteInventoryItemResponse as ax, type BulkDeleteInventoryItemsRequest as ay, type BulkInventoryItemResult as az, type BulkCreateInventoryItemsResponse as b, onInventoryItemDeleted as b$, type AggregationData as b0, type ValueAggregationResult as b1, type RangeAggregationResult as b2, type NestedAggregationResults as b3, type NestedAggregationResultsResultOneOf as b4, type ValueResults as b5, type RangeResults as b6, type AggregationResultsScalarResult as b7, type NestedValueAggregationResult as b8, type ValueResult as b9, type ActionEvent as bA, type Empty as bB, type BulkSetOrAdjustInventoryItemsByFilterRequest as bC, type AdjustInventoryAction as bD, type AdjustInventoryActionActionOneOf as bE, type MessageEnvelope as bF, type IdentificationData as bG, type IdentificationDataIdOneOf as bH, type BaseEventMetadata as bI, type EventMetadata as bJ, type InventoryItemsQueryResult as bK, type InventoryItemSearchSpec as bL, type AvailabilityStatusWithLiterals as bM, type EventTypeWithLiterals as bN, type ReasonTypeWithLiterals as bO, type ModeWithLiterals as bP, type SortOrderWithLiterals as bQ, type SortTypeWithLiterals as bR, type SortDirectionWithLiterals as bS, type MissingValuesWithLiterals as bT, type ScalarTypeWithLiterals as bU, type NestedAggregationTypeWithLiterals as bV, type IntervalWithLiterals as bW, type AggregationTypeWithLiterals as bX, type WebhookIdentityTypeWithLiterals as bY, type CommonSearchWithEntityContext as bZ, onInventoryItemCreated as b_, type RangeResult as ba, type ScalarResult as bb, type NestedResultValue as bc, type NestedResultValueResultOneOf as bd, type Results as be, type DateHistogramResult as bf, type GroupByValueResults as bg, type DateHistogramResults as bh, type NestedResults as bi, type AggregationResults as bj, type AggregationResultsResultOneOf as bk, type SearchInventoryItemsWithOffsetRequest as bl, type OffsetSearch as bm, type OffsetSearchPagingMethodOneOf as bn, type SearchInventoryItemsWithOffsetResponse as bo, type PagingMetadata as bp, type BulkDecrementInventoryItemsRequest as bq, type BulkIncrementInventoryItemsRequest as br, type BulkDecrementInventoryItemsByVariantAndLocationRequest as bs, type BulkIncrementInventoryItemsByVariantAndLocationRequest as bt, type DomainEvent as bu, type DomainEventBodyOneOf as bv, type EntityCreatedEvent as bw, type RestoreInfo as bx, type EntityUpdatedEvent as by, type EntityDeletedEvent as bz, type BulkCreateInventoryItemsApplicationErrors as c, onInventoryItemStockStatusUpdated as c0, onInventoryItemUpdated as c1, onInventoryItemUpdatedWithReason as c2, createInventoryItem as c3, bulkCreateInventoryItems as c4, getInventoryItem as c5, updateInventoryItem as c6, bulkUpdateInventoryItems as c7, bulkUpdateInventoryItemsByFilter as c8, deleteInventoryItem as c9, bulkDeleteInventoryItems as ca, queryInventoryItems as cb, bulkDecrementInventoryItems as cc, bulkIncrementInventoryItems as cd, bulkDecrementInventoryItemsByVariantAndLocation as ce, bulkIncrementInventoryItemsByVariantAndLocation as cf, bulkSetOrAdjustInventoryItemsByFilter as cg, type BulkCreateInventoryItemsValidationErrors as d, type UpdateInventoryItemOptions as e, type UpdateInventoryItemApplicationErrors as f, type BulkUpdateInventoryItemsOptions as g, type BulkUpdateInventoryItemsResponse as h, type BulkUpdateInventoryItemsApplicationErrors as i, type BulkUpdateInventoryItemsByFilterOptions as j, type BulkUpdateInventoryItemsByFilterResponse as k, type BulkUpdateInventoryItemsByFilterApplicationErrors as l, type BulkDeleteInventoryItemsResponse as m, type InventoryItemsQueryBuilder as n, type InventoryItemSearch as o, type BulkDecrementInventoryItemsOptions as p, type BulkDecrementInventoryItemsResponse as q, type BulkDecrementInventoryItemsApplicationErrors as r, type IncrementDataById as s, type BulkIncrementInventoryItemsOptions as t, type BulkIncrementInventoryItemsResponse as u, type BulkIncrementInventoryItemsApplicationErrors as v, type DecrementDataByVariantAndLocation as w, type BulkDecrementInventoryItemsByVariantAndLocationOptions as x, type BulkDecrementInventoryItemsByVariantAndLocationResponse as y, type BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors as z };
